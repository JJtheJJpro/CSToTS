export enum BOOL {
    FALSE = 0,
    TRUE = 1,
}

export class _ {
}

export class __StandardName__e__FixedBuffer extends ValueType {
    public FixedElementField: string;

}

export class SYSTEMTIME extends ValueType {
    private Year: number;
    private Month: number;
    private DayOfWeek: number;
    private Day: number;
    private Hour: number;
    private Minute: number;
    private Second: number;
    private Milliseconds: number;

    private Equals(ref other: SYSTEMTIME): boolean {
        throw new Error("not yet implemented");
    }
}

export class __DaylightName__e__FixedBuffer extends ValueType {
    public FixedElementField: string;

}

export class __TimeZoneKeyName__e__FixedBuffer extends ValueType {
    public FixedElementField: string;

}

export class TIME_DYNAMIC_ZONE_INFORMATION extends ValueType {
    private Bias: number;
    private StandardName: __StandardName__e__FixedBuffer;
    private StandardDate: SYSTEMTIME;
    private StandardBias: number;
    private DaylightName: __DaylightName__e__FixedBuffer;
    private DaylightDate: SYSTEMTIME;
    private DaylightBias: number;
    private TimeZoneKeyName: __TimeZoneKeyName__e__FixedBuffer;
    private DynamicDaylightTimeDisabled: number;

    private GetTimeZoneKeyName(): string {
        throw new Error("not yet implemented");
    }
}

export namespace TIME_DYNAMIC_ZONE_INFORMATION {
    export class __DaylightName__e__FixedBuffer extends ValueType {
        public FixedElementField: string;

    }

    export class __StandardName__e__FixedBuffer extends ValueType {
        public FixedElementField: string;

    }

    export class __TimeZoneKeyName__e__FixedBuffer extends ValueType {
        public FixedElementField: string;

    }
}

export class TIME_ZONE_INFORMATION extends ValueType {
    private Bias: number;
    private StandardName: __StandardName__e__FixedBuffer;
    private StandardDate: SYSTEMTIME;
    private StandardBias: number;
    private DaylightName: __DaylightName__e__FixedBuffer;
    private DaylightDate: SYSTEMTIME;
    private DaylightBias: number;

    protected constructor(dtzi: TIME_DYNAMIC_ZONE_INFORMATION) {
        throw new Error("not yet implemented");
    }

    private GetStandardName(): string {
        throw new Error("not yet implemented");
    }
    private GetDaylightName(): string {
        throw new Error("not yet implemented");
    }
}

export namespace TIME_ZONE_INFORMATION {
    export class __DaylightName__e__FixedBuffer extends ValueType {
        public FixedElementField: string;

    }

    export class __StandardName__e__FixedBuffer extends ValueType {
        public FixedElementField: string;

    }
}

export class REG_TZI_FORMAT extends ValueType {
    private Bias: number;
    private StandardBias: number;
    private DaylightBias: number;
    private StandardDate: SYSTEMTIME;
    private DaylightDate: SYSTEMTIME;

    protected constructor(tzi: TIME_ZONE_INFORMATION) {
        throw new Error("not yet implemented");
    }

}

export namespace Internal.Win32 {
    export class RegistryKey implements IDisposable {
        private _hkey: SafeRegistryHandle;

        private constructor(hkey: SafeRegistryHandle) {
            throw new Error("not yet implemented");
        }

        private __explicit__IDisposable_Dispose() {
            throw new Error("not yet implemented");
        }
        public Dispose() {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        public DeleteValue(name: string, throwOnMissingValue: boolean) {
            throw new Error("not yet implemented");
        }
        private static OpenBaseKey(hKey: number): RegistryKey {
            throw new Error("not yet implemented");
        }
        public OpenSubKey(name: string): RegistryKey {
            throw new Error("not yet implemented");
        }
        public OpenSubKey(name: string, writable: boolean): RegistryKey {
            throw new Error("not yet implemented");
        }
        public GetSubKeyNames(): string[] {
            throw new Error("not yet implemented");
        }
        public GetValueNames(): string[] {
            throw new Error("not yet implemented");
        }
        public GetValue(name: string): any {
            throw new Error("not yet implemented");
        }
        public GetValue(name: string, defaultValue: any): any {
            throw new Error("not yet implemented");
        }
        private SetValue(name: string, value: string) {
            throw new Error("not yet implemented");
        }
        private static Win32Error(errorCode: number, str: string) {
            throw new Error("not yet implemented");
        }
    }
}
export namespace Internal.Win32.SafeHandles {
    export class SafeRegistryHandle extends SafeHandleZeroOrMinusOneIsInvalid implements IDisposable {
        public constructor() {
            throw new Error("not yet implemented");
        }
        public constructor(preexistingHandle: number, ownsHandle: boolean) {
            throw new Error("not yet implemented");
        }

        private ReleaseHandle(): boolean {
            throw new Error("not yet implemented");
        }
    }
}
export namespace Microsoft.Win32.SafeHandles {
    export abstract class SafeHandleZeroOrMinusOneIsInvalid extends SafeHandle implements IDisposable {
        public get IsInvalid(): boolean {
            throw new Error("not yet implemented");
        }

        protected constructor(ownsHandle: boolean) {
            throw new Error("not yet implemented");
        }

    }
    export class SafeWaitHandle extends SafeHandleZeroOrMinusOneIsInvalid implements IDisposable {
        public constructor() {
            throw new Error("not yet implemented");
        }
        public constructor(existingHandle: number, ownsHandle: boolean) {
            throw new Error("not yet implemented");
        }

        private ReleaseHandle(): boolean {
            throw new Error("not yet implemented");
        }
    }
    export class SafeThreadPoolIOHandle extends SafeHandle implements IDisposable {
        public get IsInvalid(): boolean {
            throw new Error("not yet implemented");
        }

        public constructor() {
            throw new Error("not yet implemented");
        }

        private ReleaseHandle(): boolean {
            throw new Error("not yet implemented");
        }
    }
    export class OverlappedValueTaskSource implements IValueTaskSource<number>, IValueTaskSource {
        private static readonly s_ioCallback: IOCompletionCallback;

        private _preallocatedOverlapped: PreAllocatedOverlapped;
        private _fileHandle: SafeFileHandle;
        private _strategy: OSFileStreamStrategy;
        private _memoryHandle: MemoryHandle;
        private _bufferSize: number;
        private _source: ManualResetValueTaskSourceCore<number>;
        private _overlapped: NativeOverlapped*;
        private _cancellationRegistration: CancellationTokenRegistration;
        private _result: number;

        private get Version(): number {
            throw new Error("not yet implemented");
        }

        protected constructor(fileHandle: SafeFileHandle) {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

        private Dispose() {
            throw new Error("not yet implemented");
        }
        private static GetIOError(errorCode: number, path: string): Exception {
            throw new Error("not yet implemented");
        }
        private PrepareForOperation(memory: ReadOnlyMemory<number>, fileOffset: number, strategy: OSFileStreamStrategy): NativeOverlapped* {
            throw new Error("not yet implemented");
        }
        public GetStatus(token: number): ValueTaskSourceStatus {
            throw new Error("not yet implemented");
        }
        public OnCompleted(continuation: Action<any>, state: any, token: number, flags: ValueTaskSourceOnCompletedFlags) {
            throw new Error("not yet implemented");
        }
        private __explicit__IValueTaskSource_GetResult(token: number) {
            throw new Error("not yet implemented");
        }
        public GetResult(token: number): number {
            throw new Error("not yet implemented");
        }
        private RegisterForCancellation(cancellationToken: CancellationToken) {
            throw new Error("not yet implemented");
        }
        private ReleaseResources() {
            throw new Error("not yet implemented");
        }
        private FinishedScheduling() {
            throw new Error("not yet implemented");
        }
        private static IOCallback(errorCode: number, numBytes: number, pOverlapped: NativeOverlapped*) {
            throw new Error("not yet implemented");
        }
        private Complete(errorCode: number, numBytes: number) {
            throw new Error("not yet implemented");
        }
    }
    export namespace OverlappedValueTaskSource {
        export class ____c {
            public static readonly ____9: ____c;
            public static ____9__20_0: Action<any, CancellationToken>;

            private static staticctor_initialize = (() => {
                throw new Error("not yet implemented");
            })();
            private constructor() { }
            public constructor() {
                throw new Error("not yet implemented");
            }

            private __RegisterForCancellation__b__20_0(s: any, token: CancellationToken) {
                throw new Error("not yet implemented");
            }
        }
    }
    export class SafeFileHandle extends SafeHandleZeroOrMinusOneIsInvalid implements IDisposable {
        private _path: string;
        private _length: number;
        private _lengthCanBeCached: boolean;
        private _fileOptions: FileOptions;
        private _fileType: number;
        private __ThreadPoolBinding__k__BackingField: ThreadPoolBoundHandle;
        private _reusableOverlappedValueTaskSource: OverlappedValueTaskSource;

        private get Path(): string {
            throw new Error("not yet implemented");
        }
        public get IsAsync(): boolean {
            throw new Error("not yet implemented");
        }
        private get IsNoBuffering(): boolean {
            throw new Error("not yet implemented");
        }
        private get CanSeek(): boolean {
            throw new Error("not yet implemented");
        }
        private get ThreadPoolBinding(): ThreadPoolBoundHandle {
            throw new Error("not yet implemented");
        }
        private set ThreadPoolBinding(value: ThreadPoolBoundHandle) {
            throw new Error("not yet implemented");
        }

        public constructor(preexistingHandle: number, ownsHandle: boolean) {
            throw new Error("not yet implemented");
        }
        public constructor() {
            throw new Error("not yet implemented");
        }

        private TryGetCachedLength(out cachedLength: number): boolean {
            throw new Error("not yet implemented");
        }
        private static Open(fullPath: string, mode: FileMode, access: FileAccess, share: FileShare, options: FileOptions, preallocationSize: number, unixCreateMode: Nullable<UnixFileMode>): SafeFileHandle {
            throw new Error("not yet implemented");
        }
        private static CreateFile(fullPath: string, mode: FileMode, access: FileAccess, share: FileShare, options: FileOptions): SafeFileHandle {
            throw new Error("not yet implemented");
        }
        private static Preallocate(fullPath: string, preallocationSize: number, fileHandle: SafeFileHandle) {
            throw new Error("not yet implemented");
        }
        private EnsureThreadPoolBindingInitialized() {
            throw new Error("not yet implemented");
        }
        private InitThreadPoolBinding() {
            throw new Error("not yet implemented");
        }
        private GetFileOptions(): FileOptions {
            throw new Error("not yet implemented");
        }
        private GetFileType(): number {
            throw new Error("not yet implemented");
        }
        private GetFileLength(): number {
            throw new Error("not yet implemented");
        }
        private GetOverlappedValueTaskSource(): OverlappedValueTaskSource {
            throw new Error("not yet implemented");
        }
        private ReleaseHandle(): boolean {
            throw new Error("not yet implemented");
        }
        private TryToReuse(source: OverlappedValueTaskSource) {
            throw new Error("not yet implemented");
        }
        private __EnsureThreadPoolBindingInitialized__g__Init_24_0() {
            throw new Error("not yet implemented");
        }
        private __GetFileLength__g__GetFileLengthCore_28_0(): number {
            throw new Error("not yet implemented");
        }
    }
    export namespace SafeFileHandle {
        export class OverlappedValueTaskSource implements IValueTaskSource<number>, IValueTaskSource {
            private static readonly s_ioCallback: IOCompletionCallback;

            private _preallocatedOverlapped: PreAllocatedOverlapped;
            private _fileHandle: SafeFileHandle;
            private _strategy: OSFileStreamStrategy;
            private _memoryHandle: MemoryHandle;
            private _bufferSize: number;
            private _source: ManualResetValueTaskSourceCore<number>;
            private _overlapped: NativeOverlapped*;
            private _cancellationRegistration: CancellationTokenRegistration;
            private _result: number;

            private get Version(): number {
                throw new Error("not yet implemented");
            }

            protected constructor(fileHandle: SafeFileHandle) {
                throw new Error("not yet implemented");
            }
            private static staticctor_initialize = (() => {
                throw new Error("not yet implemented");
            })();
            private constructor() { }

            private Dispose() {
                throw new Error("not yet implemented");
            }
            private static GetIOError(errorCode: number, path: string): Exception {
                throw new Error("not yet implemented");
            }
            private PrepareForOperation(memory: ReadOnlyMemory<number>, fileOffset: number, strategy: OSFileStreamStrategy): NativeOverlapped* {
                throw new Error("not yet implemented");
            }
            public GetStatus(token: number): ValueTaskSourceStatus {
                throw new Error("not yet implemented");
            }
            public OnCompleted(continuation: Action<any>, state: any, token: number, flags: ValueTaskSourceOnCompletedFlags) {
                throw new Error("not yet implemented");
            }
            private __explicit__IValueTaskSource_GetResult(token: number) {
                throw new Error("not yet implemented");
            }
            public GetResult(token: number): number {
                throw new Error("not yet implemented");
            }
            private RegisterForCancellation(cancellationToken: CancellationToken) {
                throw new Error("not yet implemented");
            }
            private ReleaseResources() {
                throw new Error("not yet implemented");
            }
            private FinishedScheduling() {
                throw new Error("not yet implemented");
            }
            private static IOCallback(errorCode: number, numBytes: number, pOverlapped: NativeOverlapped*) {
                throw new Error("not yet implemented");
            }
            private Complete(errorCode: number, numBytes: number) {
                throw new Error("not yet implemented");
            }
        }
        export namespace OverlappedValueTaskSource {
            export class ____c {
                public static readonly ____9: ____c;
                public static ____9__20_0: Action<any, CancellationToken>;

                private static staticctor_initialize = (() => {
                    throw new Error("not yet implemented");
                })();
                private constructor() { }
                public constructor() {
                    throw new Error("not yet implemented");
                }

                private __RegisterForCancellation__b__20_0(s: any, token: CancellationToken) {
                    throw new Error("not yet implemented");
                }
            }
        }
    }
}
export namespace System {
    export interface IComparable {
        CompareTo(obj: any): number;
    }
    export enum TypeCode {
        Empty = 0,
        Object = 1,
        DBNull = 2,
        Boolean = 3,
        Char = 4,
        SByte = 5,
        Byte = 6,
        Int16 = 7,
        UInt16 = 8,
        Int32 = 9,
        UInt32 = 10,
        Int64 = 11,
        UInt64 = 12,
        Single = 13,
        Double = 14,
        Decimal = 15,
        DateTime = 16,
        String = 18,
    }
    export abstract class ValueType {
        protected constructor() {
            throw new Error("not yet implemented");
        }

        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        private static CanCompareBits(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
    }
    export interface IComparable<T> {
        CompareTo(other: T): number;
    }
    export interface IEquatable<T> {
        Equals(other: T): boolean;
    }
    export interface IDisposable {
        Dispose(): void;
    }
    export interface ICloneable {
        Clone(): any;
    }
    export class RuntimeMethodHandleInternal extends ValueType {
        private static get EmptyHandle(): RuntimeMethodHandleInternal {
            throw new Error("not yet implemented");
        }

        private m_handle: number;

        private get Value(): number {
            throw new Error("not yet implemented");
        }

        protected constructor(value: number) {
            throw new Error("not yet implemented");
        }

        private IsNullHandle(): boolean {
            throw new Error("not yet implemented");
        }
    }
    export interface IRuntimeMethodInfo {
        get Value(): RuntimeMethodHandleInternal;

    }
    export class Enumerator extends ValueType implements IEnumerator<T>, IDisposable, IEnumerator {
        private _array: T[];
        private _start: number;
        private _end: number;
        private _current: number;

        public get Current(): T {
            throw new Error("not yet implemented");
        }
        private get __explicit__IEnumerator_Current(): any {
            throw new Error("not yet implemented");
        }

        protected constructor(arraySegment: ArraySegment<T>) {
            throw new Error("not yet implemented");
        }

        public MoveNext(): boolean {
            throw new Error("not yet implemented");
        }
        private __explicit__IEnumerator_Reset() {
            throw new Error("not yet implemented");
        }
        public Reset() {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        public Dispose() {
            throw new Error("not yet implemented");
        }

        public readonly ExplicitAsIEnumerator__T__: IEnumerator<T> = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Current') {
                    return target.__explicit__IEnumerator_Current;
                }
        
                if (prop === 'Reset') {
                    return target.__explicit__IEnumerator_Reset.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIDisposable: IDisposable = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Current') {
                    return target.__explicit__IEnumerator_Current;
                }
        
                if (prop === 'Reset') {
                    return target.__explicit__IEnumerator_Reset.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIEnumerator: IEnumerator = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Current') {
                    return target.__explicit__IEnumerator_Current;
                }
        
                if (prop === 'Reset') {
                    return target.__explicit__IEnumerator_Reset.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
    }
    export class ArraySegment<T> extends ValueType implements IList<T>, ICollection<T>, IEnumerable<T>, IEnumerable, IReadOnlyList<T>, IReadOnlyCollection<T> {
        private static readonly __Empty__k__BackingField: ArraySegment<T>;

        public static get Empty(): ArraySegment<T> {
            throw new Error("not yet implemented");
        }

        private _array: T[];
        private _offset: number;
        private _count: number;

        public get Array(): T[] {
            throw new Error("not yet implemented");
        }
        public get Offset(): number {
            throw new Error("not yet implemented");
        }
        public get Count(): number {
            throw new Error("not yet implemented");
        }
        public get Item(): T {
            throw new Error("not yet implemented");
        }
        public set Item(index: number) {
            throw new Error("not yet implemented");
        }
        private get __explicit__IList__T___Item(): T {
            throw new Error("not yet implemented");
        }
        private set __explicit__IList__T___Item(index: number) {
            throw new Error("not yet implemented");
        }
        private get __explicit__IReadOnlyList__T___Item(): T {
            throw new Error("not yet implemented");
        }
        private get __explicit__ICollection__T___IsReadOnly(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsReadOnly(): boolean {
            throw new Error("Invalid call (use ExplicitAs property)");
        }

        public constructor(array: T[]) {
            throw new Error("not yet implemented");
        }
        public constructor(array: T[], offset: number, count: number) {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

        public GetEnumerator(): Enumerator {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public CopyTo(destination: T[]) {
            throw new Error("not yet implemented");
        }
        public CopyTo(destination: T[], destinationIndex: number) {
            throw new Error("not yet implemented");
        }
        public CopyTo(destination: ArraySegment<T>) {
            throw new Error("not yet implemented");
        }
        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public Equals(obj: ArraySegment<T>): boolean {
            throw new Error("not yet implemented");
        }
        public Slice(index: number): ArraySegment<T> {
            throw new Error("not yet implemented");
        }
        public Slice(index: number, count: number): ArraySegment<T> {
            throw new Error("not yet implemented");
        }
        public ToArray(): T[] {
            throw new Error("not yet implemented");
        }
        private __explicit__IList__T___IndexOf(item: T): number {
            throw new Error("not yet implemented");
        }
        public IndexOf(item: T): number {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__IList__T___Insert(index: number, item: T) {
            throw new Error("not yet implemented");
        }
        public Insert(index: number, item: T) {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__IList__T___RemoveAt(index: number) {
            throw new Error("not yet implemented");
        }
        public RemoveAt(index: number) {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__ICollection__T___Add(item: T) {
            throw new Error("not yet implemented");
        }
        public Add(item: T) {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__ICollection__T___Clear() {
            throw new Error("not yet implemented");
        }
        public Clear() {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__ICollection__T___Contains(item: T): boolean {
            throw new Error("not yet implemented");
        }
        public Contains(item: T): boolean {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__ICollection__T___Remove(item: T): boolean {
            throw new Error("not yet implemented");
        }
        public Remove(item: T): boolean {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__IEnumerable__T___GetEnumerator(): IEnumerator<T> {
            throw new Error("not yet implemented");
        }
        private __explicit__IEnumerable_GetEnumerator(): IEnumerator {
            throw new Error("not yet implemented");
        }
        private ThrowInvalidOperationIfDefault() {
            throw new Error("not yet implemented");
        }

        public readonly ExplicitAsIList__T__: IList<T> = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Item') {
                    return target.__explicit__IList__T___Item;
                }
                if (prop === 'Item') {
                    return target.__explicit__IReadOnlyList__T___Item;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__ICollection__T___IsReadOnly;
                }
        
                if (prop === 'IndexOf') {
                    return target.__explicit__IList__T___IndexOf.bind(target);
                }
                if (prop === 'Insert') {
                    return target.__explicit__IList__T___Insert.bind(target);
                }
                if (prop === 'RemoveAt') {
                    return target.__explicit__IList__T___RemoveAt.bind(target);
                }
                if (prop === 'Add') {
                    return target.__explicit__ICollection__T___Add.bind(target);
                }
                if (prop === 'Clear') {
                    return target.__explicit__ICollection__T___Clear.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__ICollection__T___Contains.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__ICollection__T___Remove.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable__T___GetEnumerator.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsICollection__T__: ICollection<T> = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Item') {
                    return target.__explicit__IList__T___Item;
                }
                if (prop === 'Item') {
                    return target.__explicit__IReadOnlyList__T___Item;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__ICollection__T___IsReadOnly;
                }
        
                if (prop === 'IndexOf') {
                    return target.__explicit__IList__T___IndexOf.bind(target);
                }
                if (prop === 'Insert') {
                    return target.__explicit__IList__T___Insert.bind(target);
                }
                if (prop === 'RemoveAt') {
                    return target.__explicit__IList__T___RemoveAt.bind(target);
                }
                if (prop === 'Add') {
                    return target.__explicit__ICollection__T___Add.bind(target);
                }
                if (prop === 'Clear') {
                    return target.__explicit__ICollection__T___Clear.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__ICollection__T___Contains.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__ICollection__T___Remove.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable__T___GetEnumerator.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIEnumerable__T__: IEnumerable<T> = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Item') {
                    return target.__explicit__IList__T___Item;
                }
                if (prop === 'Item') {
                    return target.__explicit__IReadOnlyList__T___Item;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__ICollection__T___IsReadOnly;
                }
        
                if (prop === 'IndexOf') {
                    return target.__explicit__IList__T___IndexOf.bind(target);
                }
                if (prop === 'Insert') {
                    return target.__explicit__IList__T___Insert.bind(target);
                }
                if (prop === 'RemoveAt') {
                    return target.__explicit__IList__T___RemoveAt.bind(target);
                }
                if (prop === 'Add') {
                    return target.__explicit__ICollection__T___Add.bind(target);
                }
                if (prop === 'Clear') {
                    return target.__explicit__ICollection__T___Clear.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__ICollection__T___Contains.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__ICollection__T___Remove.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable__T___GetEnumerator.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIEnumerable: IEnumerable = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Item') {
                    return target.__explicit__IList__T___Item;
                }
                if (prop === 'Item') {
                    return target.__explicit__IReadOnlyList__T___Item;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__ICollection__T___IsReadOnly;
                }
        
                if (prop === 'IndexOf') {
                    return target.__explicit__IList__T___IndexOf.bind(target);
                }
                if (prop === 'Insert') {
                    return target.__explicit__IList__T___Insert.bind(target);
                }
                if (prop === 'RemoveAt') {
                    return target.__explicit__IList__T___RemoveAt.bind(target);
                }
                if (prop === 'Add') {
                    return target.__explicit__ICollection__T___Add.bind(target);
                }
                if (prop === 'Clear') {
                    return target.__explicit__ICollection__T___Clear.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__ICollection__T___Contains.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__ICollection__T___Remove.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable__T___GetEnumerator.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIReadOnlyList__T__: IReadOnlyList<T> = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Item') {
                    return target.__explicit__IList__T___Item;
                }
                if (prop === 'Item') {
                    return target.__explicit__IReadOnlyList__T___Item;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__ICollection__T___IsReadOnly;
                }
        
                if (prop === 'IndexOf') {
                    return target.__explicit__IList__T___IndexOf.bind(target);
                }
                if (prop === 'Insert') {
                    return target.__explicit__IList__T___Insert.bind(target);
                }
                if (prop === 'RemoveAt') {
                    return target.__explicit__IList__T___RemoveAt.bind(target);
                }
                if (prop === 'Add') {
                    return target.__explicit__ICollection__T___Add.bind(target);
                }
                if (prop === 'Clear') {
                    return target.__explicit__ICollection__T___Clear.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__ICollection__T___Contains.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__ICollection__T___Remove.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable__T___GetEnumerator.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIReadOnlyCollection__T__: IReadOnlyCollection<T> = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Item') {
                    return target.__explicit__IList__T___Item;
                }
                if (prop === 'Item') {
                    return target.__explicit__IReadOnlyList__T___Item;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__ICollection__T___IsReadOnly;
                }
        
                if (prop === 'IndexOf') {
                    return target.__explicit__IList__T___IndexOf.bind(target);
                }
                if (prop === 'Insert') {
                    return target.__explicit__IList__T___Insert.bind(target);
                }
                if (prop === 'RemoveAt') {
                    return target.__explicit__IList__T___RemoveAt.bind(target);
                }
                if (prop === 'Add') {
                    return target.__explicit__ICollection__T___Add.bind(target);
                }
                if (prop === 'Clear') {
                    return target.__explicit__ICollection__T___Clear.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__ICollection__T___Contains.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__ICollection__T___Remove.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable__T___GetEnumerator.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
    }
    export namespace ArraySegment {
        export class Enumerator extends ValueType implements IEnumerator<T>, IDisposable, IEnumerator {
            private _array: T[];
            private _start: number;
            private _end: number;
            private _current: number;

            public get Current(): T {
                throw new Error("not yet implemented");
            }
            private get __explicit__IEnumerator_Current(): any {
                throw new Error("not yet implemented");
            }

            protected constructor(arraySegment: ArraySegment<T>) {
                throw new Error("not yet implemented");
            }

            public MoveNext(): boolean {
                throw new Error("not yet implemented");
            }
            private __explicit__IEnumerator_Reset() {
                throw new Error("not yet implemented");
            }
            public Reset() {
                throw new Error("Invalid call (use ExplicitAs property)");
            }
            public Dispose() {
                throw new Error("not yet implemented");
            }

            public readonly ExplicitAsIEnumerator__T__: IEnumerator<T> = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'Current') {
                        return target.__explicit__IEnumerator_Current;
                    }
            
                    if (prop === 'Reset') {
                        return target.__explicit__IEnumerator_Reset.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
            public readonly ExplicitAsIDisposable: IDisposable = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'Current') {
                        return target.__explicit__IEnumerator_Current;
                    }
            
                    if (prop === 'Reset') {
                        return target.__explicit__IEnumerator_Reset.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
            public readonly ExplicitAsIEnumerator: IEnumerator = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'Current') {
                        return target.__explicit__IEnumerator_Current;
                    }
            
                    if (prop === 'Reset') {
                        return target.__explicit__IEnumerator_Reset.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
        }
    }
    export class Span<T> extends ValueType {
        public static get Empty(): Span<T> {
            throw new Error("not yet implemented");
        }

        private _reference: T;
        private _length: number;

        public get Item(): T {
            throw new Error("not yet implemented");
        }
        public get Length(): number {
            throw new Error("not yet implemented");
        }
        public get IsEmpty(): boolean {
            throw new Error("not yet implemented");
        }

        public constructor(array: T[]) {
            throw new Error("not yet implemented");
        }
        public constructor(array: T[], start: number, length: number) {
            throw new Error("not yet implemented");
        }
        public constructor(pointer: void*, length: number) {
            throw new Error("not yet implemented");
        }
        public constructor(reference: T) {
            throw new Error("not yet implemented");
        }
        protected constructor(reference: T, length: number) {
            throw new Error("not yet implemented");
        }

        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public GetEnumerator(): Enumerator {
            throw new Error("not yet implemented");
        }
        public GetPinnableReference(): T {
            throw new Error("not yet implemented");
        }
        public Clear() {
            throw new Error("not yet implemented");
        }
        public Fill(value: T) {
            throw new Error("not yet implemented");
        }
        public CopyTo(destination: Span<T>) {
            throw new Error("not yet implemented");
        }
        public TryCopyTo(destination: Span<T>): boolean {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
        public Slice(start: number): Span<T> {
            throw new Error("not yet implemented");
        }
        public Slice(start: number, length: number): Span<T> {
            throw new Error("not yet implemented");
        }
        public ToArray(): T[] {
            throw new Error("not yet implemented");
        }
    }
    export namespace Span {
        export class Enumerator extends ValueType {
            private _span: Span<T>;
            private _index: number;

            public get Current(): T {
                throw new Error("not yet implemented");
            }

            protected constructor(span: Span<T>) {
                throw new Error("not yet implemented");
            }

            public MoveNext(): boolean {
                throw new Error("not yet implemented");
            }
        }
    }
    export class ReadOnlySpan<T> extends ValueType {
        public static get Empty(): ReadOnlySpan<T> {
            throw new Error("not yet implemented");
        }

        private _reference: T;
        private _length: number;

        public get Item(): T {
            throw new Error("not yet implemented");
        }
        public get Length(): number {
            throw new Error("not yet implemented");
        }
        public get IsEmpty(): boolean {
            throw new Error("not yet implemented");
        }

        public constructor(array: T[]) {
            throw new Error("not yet implemented");
        }
        public constructor(array: T[], start: number, length: number) {
            throw new Error("not yet implemented");
        }
        public constructor(pointer: void*, length: number) {
            throw new Error("not yet implemented");
        }
        public constructor(reference: T) {
            throw new Error("not yet implemented");
        }
        protected constructor(reference: T, length: number) {
            throw new Error("not yet implemented");
        }

        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public GetEnumerator(): Enumerator {
            throw new Error("not yet implemented");
        }
        public GetPinnableReference(): T {
            throw new Error("not yet implemented");
        }
        public CopyTo(destination: Span<T>) {
            throw new Error("not yet implemented");
        }
        public TryCopyTo(destination: Span<T>): boolean {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
        public Slice(start: number): ReadOnlySpan<T> {
            throw new Error("not yet implemented");
        }
        public Slice(start: number, length: number): ReadOnlySpan<T> {
            throw new Error("not yet implemented");
        }
        public ToArray(): T[] {
            throw new Error("not yet implemented");
        }
    }
    export namespace ReadOnlySpan {
        export class Enumerator extends ValueType {
            private _span: ReadOnlySpan<T>;
            private _index: number;

            public get Current(): T {
                throw new Error("not yet implemented");
            }

            protected constructor(span: ReadOnlySpan<T>) {
                throw new Error("not yet implemented");
            }

            public MoveNext(): boolean {
                throw new Error("not yet implemented");
            }
        }
    }
    export enum CacheType {
        Method = 0,
        Constructor = 1,
        Field = 2,
        Property = 3,
        Event = 4,
        Interface = 5,
        NestedType = 6,
    }
    export class RuntimeFieldHandleInternal extends ValueType {
        private m_handle: number;

        private get Value(): number {
            throw new Error("not yet implemented");
        }

        protected constructor(value: number) {
            throw new Error("not yet implemented");
        }

    }
    export interface IRuntimeFieldInfo {
        get Value(): RuntimeFieldHandleInternal;

    }
    export abstract class MarshalByRefObject {
        protected constructor() {
            throw new Error("not yet implemented");
        }

        public GetLifetimeService(): any {
            throw new Error("not yet implemented");
        }
        public InitializeLifetimeService(): any {
            throw new Error("not yet implemented");
        }
        private MemberwiseClone(cloneIdentity: boolean): MarshalByRefObject {
            throw new Error("not yet implemented");
        }
    }
    export interface IParsable<TSelf> {
        static Parse(s: string, provider: IFormatProvider): TSelf;
        static TryParse(s: string, provider: IFormatProvider, out result: TSelf): boolean;
    }
    export interface ISpanParsable<TSelf> implements IParsable<TSelf> {
        static Parse(s: ReadOnlySpan<string>, provider: IFormatProvider): TSelf;
        static TryParse(s: ReadOnlySpan<string>, provider: IFormatProvider, out result: TSelf): boolean;
    }
    export interface IUtf8SpanFormattable {
        TryFormat(utf8Destination: Span<number>, out bytesWritten: number, format: ReadOnlySpan<string>, provider: IFormatProvider): boolean;
    }
    export class TimeSpan extends ValueType implements IComparable, IComparable<TimeSpan>, IEquatable<TimeSpan>, ISpanFormattable, IFormattable, ISpanParsable<TimeSpan>, IParsable<TimeSpan>, IUtf8SpanFormattable {
        public static readonly Zero: TimeSpan;
        public static readonly MaxValue: TimeSpan;
        public static readonly MinValue: TimeSpan;
        public static NanosecondsPerTick: number;
        public static TicksPerMicrosecond: number;
        public static TicksPerMillisecond: number;
        public static TicksPerSecond: number;
        public static TicksPerMinute: number;
        public static TicksPerHour: number;
        public static TicksPerDay: number;

        private _ticks: number;

        public get Ticks(): number {
            throw new Error("not yet implemented");
        }
        public get Days(): number {
            throw new Error("not yet implemented");
        }
        public get Hours(): number {
            throw new Error("not yet implemented");
        }
        public get Milliseconds(): number {
            throw new Error("not yet implemented");
        }
        public get Microseconds(): number {
            throw new Error("not yet implemented");
        }
        public get Nanoseconds(): number {
            throw new Error("not yet implemented");
        }
        public get Minutes(): number {
            throw new Error("not yet implemented");
        }
        public get Seconds(): number {
            throw new Error("not yet implemented");
        }
        public get TotalDays(): number {
            throw new Error("not yet implemented");
        }
        public get TotalHours(): number {
            throw new Error("not yet implemented");
        }
        public get TotalMilliseconds(): number {
            throw new Error("not yet implemented");
        }
        public get TotalMicroseconds(): number {
            throw new Error("not yet implemented");
        }
        public get TotalNanoseconds(): number {
            throw new Error("not yet implemented");
        }
        public get TotalMinutes(): number {
            throw new Error("not yet implemented");
        }
        public get TotalSeconds(): number {
            throw new Error("not yet implemented");
        }

        public constructor(ticks: number) {
            throw new Error("not yet implemented");
        }
        public constructor(hours: number, minutes: number, seconds: number) {
            throw new Error("not yet implemented");
        }
        public constructor(days: number, hours: number, minutes: number, seconds: number) {
            throw new Error("not yet implemented");
        }
        public constructor(days: number, hours: number, minutes: number, seconds: number, milliseconds: number) {
            throw new Error("not yet implemented");
        }
        public constructor(days: number, hours: number, minutes: number, seconds: number, milliseconds: number, microseconds: number) {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

        public Add(ts: TimeSpan): TimeSpan {
            throw new Error("not yet implemented");
        }
        public static Compare(t1: TimeSpan, t2: TimeSpan): number {
            throw new Error("not yet implemented");
        }
        public CompareTo(value: any): number {
            throw new Error("not yet implemented");
        }
        public CompareTo(value: TimeSpan): number {
            throw new Error("not yet implemented");
        }
        public static FromDays(value: number): TimeSpan {
            throw new Error("not yet implemented");
        }
        public Duration(): TimeSpan {
            throw new Error("not yet implemented");
        }
        public Equals(value: any): boolean {
            throw new Error("not yet implemented");
        }
        public Equals(obj: TimeSpan): boolean {
            throw new Error("not yet implemented");
        }
        public static Equals(t1: TimeSpan, t2: TimeSpan): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public static FromHours(value: number): TimeSpan {
            throw new Error("not yet implemented");
        }
        private static Interval(value: number, scale: number): TimeSpan {
            throw new Error("not yet implemented");
        }
        private static IntervalFromDoubleTicks(ticks: number): TimeSpan {
            throw new Error("not yet implemented");
        }
        public static FromMilliseconds(value: number): TimeSpan {
            throw new Error("not yet implemented");
        }
        public static FromMicroseconds(value: number): TimeSpan {
            throw new Error("not yet implemented");
        }
        public static FromMinutes(value: number): TimeSpan {
            throw new Error("not yet implemented");
        }
        public Negate(): TimeSpan {
            throw new Error("not yet implemented");
        }
        public static FromSeconds(value: number): TimeSpan {
            throw new Error("not yet implemented");
        }
        public Subtract(ts: TimeSpan): TimeSpan {
            throw new Error("not yet implemented");
        }
        public Multiply(factor: number): TimeSpan {
            throw new Error("not yet implemented");
        }
        public Divide(divisor: number): TimeSpan {
            throw new Error("not yet implemented");
        }
        public Divide(ts: TimeSpan): number {
            throw new Error("not yet implemented");
        }
        public static FromTicks(value: number): TimeSpan {
            throw new Error("not yet implemented");
        }
        private static TimeToTicks(hour: number, minute: number, second: number): number {
            throw new Error("not yet implemented");
        }
        private static ValidateStyles(style: TimeSpanStyles, parameterName: string) {
            throw new Error("not yet implemented");
        }
        public static Parse(s: string): TimeSpan {
            throw new Error("not yet implemented");
        }
        public static Parse(input: string, formatProvider: IFormatProvider): TimeSpan {
            throw new Error("not yet implemented");
        }
        public static Parse(input: ReadOnlySpan<string>, formatProvider: IFormatProvider): TimeSpan {
            throw new Error("not yet implemented");
        }
        public static ParseExact(input: string, format: string, formatProvider: IFormatProvider): TimeSpan {
            throw new Error("not yet implemented");
        }
        public static ParseExact(input: string, formats: string[], formatProvider: IFormatProvider): TimeSpan {
            throw new Error("not yet implemented");
        }
        public static ParseExact(input: string, format: string, formatProvider: IFormatProvider, styles: TimeSpanStyles): TimeSpan {
            throw new Error("not yet implemented");
        }
        public static ParseExact(input: ReadOnlySpan<string>, format: ReadOnlySpan<string>, formatProvider: IFormatProvider, styles: TimeSpanStyles): TimeSpan {
            throw new Error("not yet implemented");
        }
        public static ParseExact(input: string, formats: string[], formatProvider: IFormatProvider, styles: TimeSpanStyles): TimeSpan {
            throw new Error("not yet implemented");
        }
        public static ParseExact(input: ReadOnlySpan<string>, formats: string[], formatProvider: IFormatProvider, styles: TimeSpanStyles): TimeSpan {
            throw new Error("not yet implemented");
        }
        public static TryParse(s: string, out result: TimeSpan): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParse(s: ReadOnlySpan<string>, out result: TimeSpan): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParse(input: string, formatProvider: IFormatProvider, out result: TimeSpan): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParse(input: ReadOnlySpan<string>, formatProvider: IFormatProvider, out result: TimeSpan): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParseExact(input: string, format: string, formatProvider: IFormatProvider, out result: TimeSpan): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParseExact(input: ReadOnlySpan<string>, format: ReadOnlySpan<string>, formatProvider: IFormatProvider, out result: TimeSpan): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParseExact(input: string, formats: string[], formatProvider: IFormatProvider, out result: TimeSpan): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParseExact(input: ReadOnlySpan<string>, formats: string[], formatProvider: IFormatProvider, out result: TimeSpan): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParseExact(input: string, format: string, formatProvider: IFormatProvider, styles: TimeSpanStyles, out result: TimeSpan): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParseExact(input: ReadOnlySpan<string>, format: ReadOnlySpan<string>, formatProvider: IFormatProvider, styles: TimeSpanStyles, out result: TimeSpan): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParseExact(input: string, formats: string[], formatProvider: IFormatProvider, styles: TimeSpanStyles, out result: TimeSpan): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParseExact(input: ReadOnlySpan<string>, formats: string[], formatProvider: IFormatProvider, styles: TimeSpanStyles, out result: TimeSpan): boolean {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
        public ToString(format: string): string {
            throw new Error("not yet implemented");
        }
        public ToString(format: string, formatProvider: IFormatProvider): string {
            throw new Error("not yet implemented");
        }
        public TryFormat(destination: Span<string>, out charsWritten: number, format: ReadOnlySpan<string>, formatProvider: IFormatProvider): boolean {
            throw new Error("not yet implemented");
        }
        public TryFormat(utf8Destination: Span<number>, out bytesWritten: number, format: ReadOnlySpan<string>, formatProvider: IFormatProvider): boolean {
            throw new Error("not yet implemented");
        }
    }
    export interface IAsyncResult {
        get IsCompleted(): boolean;
        get AsyncWaitHandle(): WaitHandle;
        get AsyncState(): any;
        get CompletedSynchronously(): boolean;

    }
    export class AsyncCallback extends MulticastDelegate implements ICloneable, ISerializable {
        public constructor(object: any, method: number) {
            throw new Error("not yet implemented");
        }

        public Invoke(ar: IAsyncResult) {
            throw new Error("not yet implemented");
        }
        public BeginInvoke(ar: IAsyncResult, callback: AsyncCallback, object: any): IAsyncResult {
            throw new Error("not yet implemented");
        }
        public EndInvoke(result: IAsyncResult) {
            throw new Error("not yet implemented");
        }
    }
    export enum GuidParseThrowStyle {
        None = 0,
        All = 1,
        AllButOverflow = 2,
    }
    export enum ParseFailure {
        Format_ExtraJunkAtEnd = 0,
        Format_GuidBraceAfterLastNumber = 1,
        Format_GuidBrace = 2,
        Format_GuidComma = 3,
        Format_GuidDashes = 4,
        Format_GuidEndBrace = 5,
        Format_GuidHexPrefix = 6,
        Format_GuidInvalidChar = 7,
        Format_GuidInvLen = 8,
        Format_GuidUnrecognized = 9,
        Overflow_Byte = 10,
        Overflow_UInt32 = 11,
    }
    export class GuidResult extends ValueType {
        private _a: number;
        private _bc: number;
        private _b: number;
        private _c: number;
        private _defg: number;
        private _de: number;
        private _d: number;
        private _fg: number;
        private _hijk: number;
        private _throwStyle: GuidParseThrowStyle;

        protected constructor(canThrow: GuidParseThrowStyle) {
            throw new Error("not yet implemented");
        }

        private SetFailure(failureKind: ParseFailure) {
            throw new Error("not yet implemented");
        }
        public ToGuid(): Guid {
            throw new Error("not yet implemented");
        }
    }
    export interface IValueTupleInternal implements ITuple {
        GetHashCode(comparer: IEqualityComparer): number;
        ToStringEnd(): string;
    }
    export class ValueTuple<T1, T2, T3> extends ValueType implements IEquatable<ValueTuple<T1, T2, T3>>, IStructuralEquatable, IStructuralComparable, IComparable, IComparable<ValueTuple<T1, T2, T3>>, IValueTupleInternal, ITuple {
        public Item1: T1;
        public Item2: T2;
        public Item3: T3;

        private get __explicit__ITuple_Length(): number {
            throw new Error("not yet implemented");
        }
        public get Length(): number {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private get __explicit__ITuple_Item(): any {
            throw new Error("not yet implemented");
        }
        public get Item(): any {
            throw new Error("Invalid call (use ExplicitAs property)");
        }

        public constructor(item1: T1, item2: T2, item3: T3) {
            throw new Error("not yet implemented");
        }

        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public Equals(other: ValueTuple<T1, T2, T3>): boolean {
            throw new Error("not yet implemented");
        }
        private __explicit__IStructuralEquatable_Equals(other: any, comparer: IEqualityComparer): boolean {
            throw new Error("not yet implemented");
        }
        private __explicit__IComparable_CompareTo(other: any): number {
            throw new Error("not yet implemented");
        }
        public CompareTo(other: ValueTuple<T1, T2, T3>): number {
            throw new Error("not yet implemented");
        }
        private __explicit__IStructuralComparable_CompareTo(other: any, comparer: IComparer): number {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        private __explicit__IStructuralEquatable_GetHashCode(comparer: IEqualityComparer): number {
            throw new Error("not yet implemented");
        }
        private GetHashCodeCore(comparer: IEqualityComparer): number {
            throw new Error("not yet implemented");
        }
        private __explicit__IValueTupleInternal_GetHashCode(comparer: IEqualityComparer): number {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
        private __explicit__IValueTupleInternal_ToStringEnd(): string {
            throw new Error("not yet implemented");
        }
        public ToStringEnd(): string {
            throw new Error("Invalid call (use ExplicitAs property)");
        }

        public readonly ExplicitAsIEquatable__ValueTuple__T1__T2__T3____: IEquatable<ValueTuple<T1, T2, T3>> = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Length') {
                    return target.__explicit__ITuple_Length;
                }
                if (prop === 'Item') {
                    return target.__explicit__ITuple_Item;
                }
        
                if (prop === 'Equals') {
                    return target.__explicit__IStructuralEquatable_Equals.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IComparable_CompareTo.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IStructuralComparable_CompareTo.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IStructuralEquatable_GetHashCode.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IValueTupleInternal_GetHashCode.bind(target);
                }
                if (prop === 'ToStringEnd') {
                    return target.__explicit__IValueTupleInternal_ToStringEnd.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIStructuralEquatable: IStructuralEquatable = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Length') {
                    return target.__explicit__ITuple_Length;
                }
                if (prop === 'Item') {
                    return target.__explicit__ITuple_Item;
                }
        
                if (prop === 'Equals') {
                    return target.__explicit__IStructuralEquatable_Equals.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IComparable_CompareTo.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IStructuralComparable_CompareTo.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IStructuralEquatable_GetHashCode.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IValueTupleInternal_GetHashCode.bind(target);
                }
                if (prop === 'ToStringEnd') {
                    return target.__explicit__IValueTupleInternal_ToStringEnd.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIStructuralComparable: IStructuralComparable = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Length') {
                    return target.__explicit__ITuple_Length;
                }
                if (prop === 'Item') {
                    return target.__explicit__ITuple_Item;
                }
        
                if (prop === 'Equals') {
                    return target.__explicit__IStructuralEquatable_Equals.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IComparable_CompareTo.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IStructuralComparable_CompareTo.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IStructuralEquatable_GetHashCode.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IValueTupleInternal_GetHashCode.bind(target);
                }
                if (prop === 'ToStringEnd') {
                    return target.__explicit__IValueTupleInternal_ToStringEnd.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIComparable: IComparable = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Length') {
                    return target.__explicit__ITuple_Length;
                }
                if (prop === 'Item') {
                    return target.__explicit__ITuple_Item;
                }
        
                if (prop === 'Equals') {
                    return target.__explicit__IStructuralEquatable_Equals.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IComparable_CompareTo.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IStructuralComparable_CompareTo.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IStructuralEquatable_GetHashCode.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IValueTupleInternal_GetHashCode.bind(target);
                }
                if (prop === 'ToStringEnd') {
                    return target.__explicit__IValueTupleInternal_ToStringEnd.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIComparable__ValueTuple__T1__T2__T3____: IComparable<ValueTuple<T1, T2, T3>> = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Length') {
                    return target.__explicit__ITuple_Length;
                }
                if (prop === 'Item') {
                    return target.__explicit__ITuple_Item;
                }
        
                if (prop === 'Equals') {
                    return target.__explicit__IStructuralEquatable_Equals.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IComparable_CompareTo.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IStructuralComparable_CompareTo.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IStructuralEquatable_GetHashCode.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IValueTupleInternal_GetHashCode.bind(target);
                }
                if (prop === 'ToStringEnd') {
                    return target.__explicit__IValueTupleInternal_ToStringEnd.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIValueTupleInternal: IValueTupleInternal = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Length') {
                    return target.__explicit__ITuple_Length;
                }
                if (prop === 'Item') {
                    return target.__explicit__ITuple_Item;
                }
        
                if (prop === 'Equals') {
                    return target.__explicit__IStructuralEquatable_Equals.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IComparable_CompareTo.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IStructuralComparable_CompareTo.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IStructuralEquatable_GetHashCode.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IValueTupleInternal_GetHashCode.bind(target);
                }
                if (prop === 'ToStringEnd') {
                    return target.__explicit__IValueTupleInternal_ToStringEnd.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsITuple: ITuple = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Length') {
                    return target.__explicit__ITuple_Length;
                }
                if (prop === 'Item') {
                    return target.__explicit__ITuple_Item;
                }
        
                if (prop === 'Equals') {
                    return target.__explicit__IStructuralEquatable_Equals.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IComparable_CompareTo.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IStructuralComparable_CompareTo.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IStructuralEquatable_GetHashCode.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IValueTupleInternal_GetHashCode.bind(target);
                }
                if (prop === 'ToStringEnd') {
                    return target.__explicit__IValueTupleInternal_ToStringEnd.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
    }
    export class Guid extends ValueType implements ISpanFormattable, IFormattable, IComparable, IComparable<Guid>, IEquatable<Guid>, ISpanParsable<Guid>, IParsable<Guid>, IUtf8SpanFormattable {
        public static readonly Empty: Guid;

        private _a: number;
        private _b: number;
        private _c: number;
        private _d: number;
        private _e: number;
        private _f: number;
        private _g: number;
        private _h: number;
        private _i: number;
        private _j: number;
        private _k: number;

        public constructor(b: number[]) {
            throw new Error("not yet implemented");
        }
        public constructor(b: ReadOnlySpan<number>) {
            throw new Error("not yet implemented");
        }
        public constructor(b: ReadOnlySpan<number>, bigEndian: boolean) {
            throw new Error("not yet implemented");
        }
        public constructor(a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number, j: number, k: number) {
            throw new Error("not yet implemented");
        }
        public constructor(a: number, b: number, c: number, d: number[]) {
            throw new Error("not yet implemented");
        }
        public constructor(a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number, j: number, k: number) {
            throw new Error("not yet implemented");
        }
        public constructor(g: string) {
            throw new Error("not yet implemented");
        }

        private static ThrowGuidArrayCtorArgumentException() {
            throw new Error("not yet implemented");
        }
        public static Parse(input: string): Guid {
            throw new Error("not yet implemented");
        }
        public static Parse(input: ReadOnlySpan<string>): Guid {
            throw new Error("not yet implemented");
        }
        public static TryParse(input: string, out result: Guid): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParse(input: ReadOnlySpan<string>, out result: Guid): boolean {
            throw new Error("not yet implemented");
        }
        public static ParseExact(input: string, format: string): Guid {
            throw new Error("not yet implemented");
        }
        public static ParseExact(input: ReadOnlySpan<string>, format: ReadOnlySpan<string>): Guid {
            throw new Error("not yet implemented");
        }
        public static TryParseExact(input: string, format: string, out result: Guid): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParseExact(input: ReadOnlySpan<string>, format: ReadOnlySpan<string>, out result: Guid): boolean {
            throw new Error("not yet implemented");
        }
        private static TryParseGuid(guidString: ReadOnlySpan<string>, ref result: GuidResult): boolean {
            throw new Error("not yet implemented");
        }
        private static TryParseExactB(guidString: ReadOnlySpan<string>, ref result: GuidResult): boolean {
            throw new Error("not yet implemented");
        }
        private static TryParseExactD(guidString: ReadOnlySpan<string>, ref result: GuidResult): boolean {
            throw new Error("not yet implemented");
        }
        private static TryParseExactN(guidString: ReadOnlySpan<string>, ref result: GuidResult): boolean {
            throw new Error("not yet implemented");
        }
        private static TryParseExactP(guidString: ReadOnlySpan<string>, ref result: GuidResult): boolean {
            throw new Error("not yet implemented");
        }
        private static TryParseExactX(guidString: ReadOnlySpan<string>, ref result: GuidResult): boolean {
            throw new Error("not yet implemented");
        }
        private static DecodeByte(ch1: string, ch2: string, ref invalidIfNegative: number): number {
            throw new Error("not yet implemented");
        }
        private static TryParseHex(guidString: ReadOnlySpan<string>, out result: number, ref overflow: boolean): boolean {
            throw new Error("not yet implemented");
        }
        private static TryParseHex(guidString: ReadOnlySpan<string>, out result: number): boolean {
            throw new Error("not yet implemented");
        }
        private static TryParseHex(guidString: ReadOnlySpan<string>, out result: number, ref overflow: boolean): boolean {
            throw new Error("not yet implemented");
        }
        private static EatAllWhitespace(str: ReadOnlySpan<string>): ReadOnlySpan<string> {
            throw new Error("not yet implemented");
        }
        private static IsHexPrefix(str: ReadOnlySpan<string>, i: number): boolean {
            throw new Error("not yet implemented");
        }
        private static AsBytes(ref source: Guid): ReadOnlySpan<number> {
            throw new Error("not yet implemented");
        }
        public ToByteArray(): number[] {
            throw new Error("not yet implemented");
        }
        public ToByteArray(bigEndian: boolean): number[] {
            throw new Error("not yet implemented");
        }
        public TryWriteBytes(destination: Span<number>): boolean {
            throw new Error("not yet implemented");
        }
        public TryWriteBytes(destination: Span<number>, bigEndian: boolean, out bytesWritten: number): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public Equals(o: any): boolean {
            throw new Error("not yet implemented");
        }
        public Equals(g: Guid): boolean {
            throw new Error("not yet implemented");
        }
        private static EqualsCore(ref left: Guid, ref right: Guid): boolean {
            throw new Error("not yet implemented");
        }
        private static GetResult(me: number, them: number): number {
            throw new Error("not yet implemented");
        }
        public CompareTo(value: any): number {
            throw new Error("not yet implemented");
        }
        public CompareTo(value: Guid): number {
            throw new Error("not yet implemented");
        }
        private static HexsToChars(guidChars: TChar*, a: number, b: number): number {
            throw new Error("not yet implemented");
        }
        private static HexsToCharsHexOutput(guidChars: TChar*, a: number, b: number): number {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
        public ToString(format: string): string {
            throw new Error("not yet implemented");
        }
        public ToString(format: string, provider: IFormatProvider): string {
            throw new Error("not yet implemented");
        }
        public TryFormat(destination: Span<string>, out charsWritten: number, format: ReadOnlySpan<string>): boolean {
            throw new Error("not yet implemented");
        }
        private __explicit__ISpanFormattable_TryFormat(destination: Span<string>, out charsWritten: number, format: ReadOnlySpan<string>, provider: IFormatProvider): boolean {
            throw new Error("not yet implemented");
        }
        public TryFormat(utf8Destination: Span<number>, out bytesWritten: number, format: ReadOnlySpan<string>): boolean {
            throw new Error("not yet implemented");
        }
        private __explicit__IUtf8SpanFormattable_TryFormat(utf8Destination: Span<number>, out bytesWritten: number, format: ReadOnlySpan<string>, provider: IFormatProvider): boolean {
            throw new Error("not yet implemented");
        }
        private TryFormatCore(destination: Span<TChar>, out charsWritten: number, format: ReadOnlySpan<string>): boolean {
            throw new Error("not yet implemented");
        }
        private TryFormatCore(destination: Span<TChar>, out charsWritten: number, flags: number): boolean {
            throw new Error("not yet implemented");
        }
        private TryFormatX(destination: Span<TChar>, out charsWritten: number): boolean {
            throw new Error("not yet implemented");
        }
        private static FormatGuidVector128Utf8(value: Guid, useDashes: boolean): ValueTuple<Vector128<number>, Vector128<number>, Vector128<number>> {
            throw new Error("not yet implemented");
        }
        public static Parse(s: string, provider: IFormatProvider): Guid {
            throw new Error("not yet implemented");
        }
        public static TryParse(s: string, provider: IFormatProvider, out result: Guid): boolean {
            throw new Error("not yet implemented");
        }
        public static Parse(s: ReadOnlySpan<string>, provider: IFormatProvider): Guid {
            throw new Error("not yet implemented");
        }
        public static TryParse(s: ReadOnlySpan<string>, provider: IFormatProvider, out result: Guid): boolean {
            throw new Error("not yet implemented");
        }
        private static ThrowBadGuidFormatSpecification() {
            throw new Error("not yet implemented");
        }
        public static NewGuid(): Guid {
            throw new Error("not yet implemented");
        }
        private static __TryParseExactD__g__TryCompatParsing_33_0(guidString: ReadOnlySpan<string>, ref result: GuidResult): boolean {
            throw new Error("not yet implemented");
        }
    }
    export namespace Guid {
        export enum GuidParseThrowStyle {
            None = 0,
            All = 1,
            AllButOverflow = 2,
        }

        export enum ParseFailure {
            Format_ExtraJunkAtEnd = 0,
            Format_GuidBraceAfterLastNumber = 1,
            Format_GuidBrace = 2,
            Format_GuidComma = 3,
            Format_GuidDashes = 4,
            Format_GuidEndBrace = 5,
            Format_GuidHexPrefix = 6,
            Format_GuidInvalidChar = 7,
            Format_GuidInvLen = 8,
            Format_GuidUnrecognized = 9,
            Overflow_Byte = 10,
            Overflow_UInt32 = 11,
        }

        export class GuidResult extends ValueType {
            private _a: number;
            private _bc: number;
            private _b: number;
            private _c: number;
            private _defg: number;
            private _de: number;
            private _d: number;
            private _fg: number;
            private _hijk: number;
            private _throwStyle: GuidParseThrowStyle;

            protected constructor(canThrow: GuidParseThrowStyle) {
                throw new Error("not yet implemented");
            }

            private SetFailure(failureKind: ParseFailure) {
                throw new Error("not yet implemented");
            }
            public ToGuid(): Guid {
                throw new Error("not yet implemented");
            }
        }
    }
    export class MdUtf8String extends ValueType {
        private m_pStringHeap: number*;
        private m_StringHeapByteLength: number;

        protected constructor(pStringHeap: void*) {
            throw new Error("not yet implemented");
        }
        protected constructor(pUtf8String: number*, cUtf8String: number) {
            throw new Error("not yet implemented");
        }

        private static EqualsCaseInsensitive(szLhs: void*, szRhs: void*, cSz: number): boolean {
            throw new Error("not yet implemented");
        }
        private Equals(s: MdUtf8String): boolean {
            throw new Error("not yet implemented");
        }
        private EqualsCaseInsensitive(s: MdUtf8String): boolean {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
        private static __EqualsCaseInsensitive__g____PInvoke_0_0(__szLhs_native: void*, __szRhs_native: void*, __cSz_native: number): number {
            throw new Error("not yet implemented");
        }
    }
    export enum DayOfWeek {
        Sunday = 0,
        Monday = 1,
        Tuesday = 2,
        Wednesday = 3,
        Thursday = 4,
        Friday = 5,
        Saturday = 6,
    }
    export class Memory<T> extends ValueType implements IEquatable<Memory<T>> {
        public static get Empty(): Memory<T> {
            throw new Error("not yet implemented");
        }

        private _object: any;
        private _index: number;
        private _length: number;

        public get Length(): number {
            throw new Error("not yet implemented");
        }
        public get IsEmpty(): boolean {
            throw new Error("not yet implemented");
        }
        public get Span(): Span<T> {
            throw new Error("not yet implemented");
        }

        public constructor(array: T[]) {
            throw new Error("not yet implemented");
        }
        protected constructor(array: T[], start: number) {
            throw new Error("not yet implemented");
        }
        public constructor(array: T[], start: number, length: number) {
            throw new Error("not yet implemented");
        }
        protected constructor(manager: MemoryManager<T>, length: number) {
            throw new Error("not yet implemented");
        }
        protected constructor(manager: MemoryManager<T>, start: number, length: number) {
            throw new Error("not yet implemented");
        }
        protected constructor(obj: any, start: number, length: number) {
            throw new Error("not yet implemented");
        }

        public ToString(): string {
            throw new Error("not yet implemented");
        }
        public Slice(start: number): Memory<T> {
            throw new Error("not yet implemented");
        }
        public Slice(start: number, length: number): Memory<T> {
            throw new Error("not yet implemented");
        }
        public CopyTo(destination: Memory<T>) {
            throw new Error("not yet implemented");
        }
        public TryCopyTo(destination: Memory<T>): boolean {
            throw new Error("not yet implemented");
        }
        public Pin(): MemoryHandle {
            throw new Error("not yet implemented");
        }
        public ToArray(): T[] {
            throw new Error("not yet implemented");
        }
        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public Equals(other: Memory<T>): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
    }
    export class ReadOnlyMemory<T> extends ValueType implements IEquatable<ReadOnlyMemory<T>> {
        private static RemoveFlagsBitMask: number;

        public static get Empty(): ReadOnlyMemory<T> {
            throw new Error("not yet implemented");
        }

        private _object: any;
        private _index: number;
        private _length: number;

        public get Length(): number {
            throw new Error("not yet implemented");
        }
        public get IsEmpty(): boolean {
            throw new Error("not yet implemented");
        }
        public get Span(): ReadOnlySpan<T> {
            throw new Error("not yet implemented");
        }

        public constructor(array: T[]) {
            throw new Error("not yet implemented");
        }
        public constructor(array: T[], start: number, length: number) {
            throw new Error("not yet implemented");
        }
        protected constructor(obj: any, start: number, length: number) {
            throw new Error("not yet implemented");
        }

        public ToString(): string {
            throw new Error("not yet implemented");
        }
        public Slice(start: number): ReadOnlyMemory<T> {
            throw new Error("not yet implemented");
        }
        public Slice(start: number, length: number): ReadOnlyMemory<T> {
            throw new Error("not yet implemented");
        }
        public CopyTo(destination: Memory<T>) {
            throw new Error("not yet implemented");
        }
        public TryCopyTo(destination: Memory<T>): boolean {
            throw new Error("not yet implemented");
        }
        public Pin(): MemoryHandle {
            throw new Error("not yet implemented");
        }
        public ToArray(): T[] {
            throw new Error("not yet implemented");
        }
        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public Equals(other: ReadOnlyMemory<T>): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        private GetObjectStartLength(out start: number, out length: number): any {
            throw new Error("not yet implemented");
        }
    }
    export class ValueTuple<T1, T2, T3, T4> extends ValueType implements IEquatable<ValueTuple<T1, T2, T3, T4>>, IStructuralEquatable, IStructuralComparable, IComparable, IComparable<ValueTuple<T1, T2, T3, T4>>, IValueTupleInternal, ITuple {
        public Item1: T1;
        public Item2: T2;
        public Item3: T3;
        public Item4: T4;

        private get __explicit__ITuple_Length(): number {
            throw new Error("not yet implemented");
        }
        public get Length(): number {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private get __explicit__ITuple_Item(): any {
            throw new Error("not yet implemented");
        }
        public get Item(): any {
            throw new Error("Invalid call (use ExplicitAs property)");
        }

        public constructor(item1: T1, item2: T2, item3: T3, item4: T4) {
            throw new Error("not yet implemented");
        }

        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public Equals(other: ValueTuple<T1, T2, T3, T4>): boolean {
            throw new Error("not yet implemented");
        }
        private __explicit__IStructuralEquatable_Equals(other: any, comparer: IEqualityComparer): boolean {
            throw new Error("not yet implemented");
        }
        private __explicit__IComparable_CompareTo(other: any): number {
            throw new Error("not yet implemented");
        }
        public CompareTo(other: ValueTuple<T1, T2, T3, T4>): number {
            throw new Error("not yet implemented");
        }
        private __explicit__IStructuralComparable_CompareTo(other: any, comparer: IComparer): number {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        private __explicit__IStructuralEquatable_GetHashCode(comparer: IEqualityComparer): number {
            throw new Error("not yet implemented");
        }
        private GetHashCodeCore(comparer: IEqualityComparer): number {
            throw new Error("not yet implemented");
        }
        private __explicit__IValueTupleInternal_GetHashCode(comparer: IEqualityComparer): number {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
        private __explicit__IValueTupleInternal_ToStringEnd(): string {
            throw new Error("not yet implemented");
        }
        public ToStringEnd(): string {
            throw new Error("Invalid call (use ExplicitAs property)");
        }

        public readonly ExplicitAsIEquatable__ValueTuple__T1__T2__T3__T4____: IEquatable<ValueTuple<T1, T2, T3, T4>> = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Length') {
                    return target.__explicit__ITuple_Length;
                }
                if (prop === 'Item') {
                    return target.__explicit__ITuple_Item;
                }
        
                if (prop === 'Equals') {
                    return target.__explicit__IStructuralEquatable_Equals.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IComparable_CompareTo.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IStructuralComparable_CompareTo.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IStructuralEquatable_GetHashCode.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IValueTupleInternal_GetHashCode.bind(target);
                }
                if (prop === 'ToStringEnd') {
                    return target.__explicit__IValueTupleInternal_ToStringEnd.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIStructuralEquatable: IStructuralEquatable = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Length') {
                    return target.__explicit__ITuple_Length;
                }
                if (prop === 'Item') {
                    return target.__explicit__ITuple_Item;
                }
        
                if (prop === 'Equals') {
                    return target.__explicit__IStructuralEquatable_Equals.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IComparable_CompareTo.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IStructuralComparable_CompareTo.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IStructuralEquatable_GetHashCode.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IValueTupleInternal_GetHashCode.bind(target);
                }
                if (prop === 'ToStringEnd') {
                    return target.__explicit__IValueTupleInternal_ToStringEnd.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIStructuralComparable: IStructuralComparable = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Length') {
                    return target.__explicit__ITuple_Length;
                }
                if (prop === 'Item') {
                    return target.__explicit__ITuple_Item;
                }
        
                if (prop === 'Equals') {
                    return target.__explicit__IStructuralEquatable_Equals.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IComparable_CompareTo.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IStructuralComparable_CompareTo.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IStructuralEquatable_GetHashCode.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IValueTupleInternal_GetHashCode.bind(target);
                }
                if (prop === 'ToStringEnd') {
                    return target.__explicit__IValueTupleInternal_ToStringEnd.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIComparable: IComparable = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Length') {
                    return target.__explicit__ITuple_Length;
                }
                if (prop === 'Item') {
                    return target.__explicit__ITuple_Item;
                }
        
                if (prop === 'Equals') {
                    return target.__explicit__IStructuralEquatable_Equals.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IComparable_CompareTo.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IStructuralComparable_CompareTo.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IStructuralEquatable_GetHashCode.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IValueTupleInternal_GetHashCode.bind(target);
                }
                if (prop === 'ToStringEnd') {
                    return target.__explicit__IValueTupleInternal_ToStringEnd.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIComparable__ValueTuple__T1__T2__T3__T4____: IComparable<ValueTuple<T1, T2, T3, T4>> = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Length') {
                    return target.__explicit__ITuple_Length;
                }
                if (prop === 'Item') {
                    return target.__explicit__ITuple_Item;
                }
        
                if (prop === 'Equals') {
                    return target.__explicit__IStructuralEquatable_Equals.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IComparable_CompareTo.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IStructuralComparable_CompareTo.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IStructuralEquatable_GetHashCode.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IValueTupleInternal_GetHashCode.bind(target);
                }
                if (prop === 'ToStringEnd') {
                    return target.__explicit__IValueTupleInternal_ToStringEnd.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIValueTupleInternal: IValueTupleInternal = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Length') {
                    return target.__explicit__ITuple_Length;
                }
                if (prop === 'Item') {
                    return target.__explicit__ITuple_Item;
                }
        
                if (prop === 'Equals') {
                    return target.__explicit__IStructuralEquatable_Equals.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IComparable_CompareTo.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IStructuralComparable_CompareTo.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IStructuralEquatable_GetHashCode.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IValueTupleInternal_GetHashCode.bind(target);
                }
                if (prop === 'ToStringEnd') {
                    return target.__explicit__IValueTupleInternal_ToStringEnd.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsITuple: ITuple = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Length') {
                    return target.__explicit__ITuple_Length;
                }
                if (prop === 'Item') {
                    return target.__explicit__ITuple_Item;
                }
        
                if (prop === 'Equals') {
                    return target.__explicit__IStructuralEquatable_Equals.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IComparable_CompareTo.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IStructuralComparable_CompareTo.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IStructuralEquatable_GetHashCode.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IValueTupleInternal_GetHashCode.bind(target);
                }
                if (prop === 'ToStringEnd') {
                    return target.__explicit__IValueTupleInternal_ToStringEnd.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
    }
    export enum ExceptionResource {
        ArgumentOutOfRange_IndexMustBeLessOrEqual = 0,
        ArgumentOutOfRange_IndexMustBeLess = 1,
        ArgumentOutOfRange_IndexCount = 2,
        ArgumentOutOfRange_IndexCountBuffer = 3,
        ArgumentOutOfRange_Count = 4,
        ArgumentOutOfRange_Year = 5,
        Arg_ArrayPlusOffTooSmall = 6,
        Arg_ByteArrayTooSmallForValue = 7,
        NotSupported_ReadOnlyCollection = 8,
        Arg_RankMultiDimNotSupported = 9,
        Arg_NonZeroLowerBound = 10,
        ArgumentOutOfRange_GetCharCountOverflow = 11,
        ArgumentOutOfRange_ListInsert = 12,
        ArgumentOutOfRange_NeedNonNegNum = 13,
        ArgumentOutOfRange_NotGreaterThanBufferLength = 14,
        ArgumentOutOfRange_SmallCapacity = 15,
        Argument_InvalidOffLen = 16,
        Argument_CannotExtractScalar = 17,
        ArgumentOutOfRange_BiggerThanCollection = 18,
        Serialization_MissingKeys = 19,
        Serialization_NullKey = 20,
        NotSupported_KeyCollectionSet = 21,
        NotSupported_ValueCollectionSet = 22,
        InvalidOperation_NullArray = 23,
        TaskT_TransitionToFinal_AlreadyCompleted = 24,
        TaskCompletionSourceT_TrySetException_NullException = 25,
        TaskCompletionSourceT_TrySetException_NoExceptions = 26,
        NotSupported_StringComparison = 27,
        ConcurrentCollection_SyncRoot_NotSupported = 28,
        Task_MultiTaskContinuation_NullTask = 29,
        InvalidOperation_WrongAsyncResultOrEndCalledMultiple = 30,
        Task_MultiTaskContinuation_EmptyTaskList = 31,
        Task_Start_TaskCompleted = 32,
        Task_Start_Promise = 33,
        Task_Start_ContinuationTask = 34,
        Task_Start_AlreadyStarted = 35,
        Task_RunSynchronously_Continuation = 36,
        Task_RunSynchronously_Promise = 37,
        Task_RunSynchronously_TaskCompleted = 38,
        Task_RunSynchronously_AlreadyStarted = 39,
        AsyncMethodBuilder_InstanceNotInitialized = 40,
        Task_ContinueWith_ESandLR = 41,
        Task_ContinueWith_NotOnAnything = 42,
        Task_InvalidTimerTimeSpan = 43,
        Task_Delay_InvalidMillisecondsDelay = 44,
        Task_Dispose_NotCompleted = 45,
        Task_ThrowIfDisposed = 46,
        Task_WaitMulti_NullTask = 47,
        ArgumentException_OtherNotArrayOfCorrectLength = 48,
        ArgumentNull_Array = 49,
        ArgumentNull_SafeHandle = 50,
        ArgumentOutOfRange_EndIndexStartIndex = 51,
        ArgumentOutOfRange_Enum = 52,
        ArgumentOutOfRange_HugeArrayNotSupported = 53,
        Argument_AddingDuplicate = 54,
        Argument_InvalidArgumentForComparison = 55,
        Arg_LowerBoundsMustMatch = 56,
        Arg_MustBeType = 57,
        Arg_Need1DArray = 58,
        Arg_Need2DArray = 59,
        Arg_Need3DArray = 60,
        Arg_NeedAtLeast1Rank = 61,
        Arg_RankIndices = 62,
        Arg_RanksAndBounds = 63,
        InvalidOperation_IComparerFailed = 64,
        NotSupported_FixedSizeCollection = 65,
        Rank_MultiDimNotSupported = 66,
        Arg_TypeNotSupported = 67,
        Argument_SpansMustHaveSameLength = 68,
        Argument_InvalidFlag = 69,
        CancellationTokenSource_Disposed = 70,
        Argument_AlignmentMustBePow2 = 71,
        InvalidOperation_SpanOverlappedOperation = 72,
        InvalidOperation_TimeProviderNullLocalTimeZone = 73,
        InvalidOperation_TimeProviderInvalidTimestampFrequency = 74,
        Format_UnexpectedClosingBrace = 75,
        Format_UnclosedFormatItem = 76,
        Format_ExpectedAsciiDigit = 77,
    }
    export enum TokenType {
        NumberToken = 1,
        YearNumberToken = 2,
        Am = 3,
        Pm = 4,
        MonthToken = 5,
        EndOfString = 6,
        DayOfWeekToken = 7,
        TimeZoneToken = 8,
        EraToken = 9,
        DateWordToken = 10,
        UnknownToken = 11,
        HebrewNumber = 12,
        JapaneseEraToken = 13,
        TEraToken = 14,
        IgnorableSymbol = 15,
        RegularTokenMask = 255,
        SEP_Unk = 256,
        SEP_End = 512,
        SEP_Space = 768,
        SEP_Am = 1024,
        SEP_Pm = 1280,
        SEP_Date = 1536,
        SEP_Time = 1792,
        SEP_YearSuff = 2048,
        SEP_MonthSuff = 2304,
        SEP_DaySuff = 2560,
        SEP_HourSuff = 2816,
        SEP_MinuteSuff = 3072,
        SEP_SecondSuff = 3328,
        SEP_LocalTimeMark = 3584,
        SEP_DateOrOffset = 3840,
        SeparatorTokenMask = 65280,
    }
    export enum DTSubStringType {
        Unknown = 0,
        Invalid = 1,
        Number = 2,
        End = 3,
        Other = 4,
    }
    export class DTSubString extends ValueType {
        private s: ReadOnlySpan<string>;
        private index: number;
        private length: number;
        private type: DTSubStringType;
        private value: number;

        private get Item(): string {
            throw new Error("not yet implemented");
        }

    }
    export class __DTString extends ValueType {
        private Value: ReadOnlySpan<string>;
        private Index: number;
        private m_current: string;
        private m_info: CompareInfo;
        private m_checkDigitToken: boolean;

        private get Length(): number {
            throw new Error("not yet implemented");
        }
        private get CompareInfo(): CompareInfo {
            throw new Error("not yet implemented");
        }

        protected constructor(str: ReadOnlySpan<string>, dtfi: DateTimeFormatInfo, checkDigitToken: boolean) {
            throw new Error("not yet implemented");
        }
        protected constructor(str: ReadOnlySpan<string>, dtfi: DateTimeFormatInfo) {
            throw new Error("not yet implemented");
        }

        private GetNext(): boolean {
            throw new Error("not yet implemented");
        }
        private AtEnd(): boolean {
            throw new Error("not yet implemented");
        }
        private Advance(count: number): boolean {
            throw new Error("not yet implemented");
        }
        private GetRegularToken(out tokenType: TokenType, out tokenValue: number, dtfi: DateTimeFormatInfo) {
            throw new Error("not yet implemented");
        }
        private GetSeparatorToken(dtfi: DateTimeFormatInfo, out indexBeforeSeparator: number, out charBeforeSeparator: string): TokenType {
            throw new Error("not yet implemented");
        }
        private MatchSpecifiedWord(target: string): boolean {
            throw new Error("not yet implemented");
        }
        private MatchSpecifiedWords(target: string, checkWordBoundary: boolean, ref matchLength: number): boolean {
            throw new Error("not yet implemented");
        }
        private Match(str: string): boolean {
            throw new Error("not yet implemented");
        }
        private Match(ch: string): boolean {
            throw new Error("not yet implemented");
        }
        private static IsSpaceReplacingChar(c: string): boolean {
            throw new Error("not yet implemented");
        }
        private MatchLongestWords(words: string[], ref maxMatchStrLen: number): number {
            throw new Error("not yet implemented");
        }
        private GetRepeatCount(): number {
            throw new Error("not yet implemented");
        }
        private GetNextDigit(): boolean {
            throw new Error("not yet implemented");
        }
        private GetChar(): string {
            throw new Error("not yet implemented");
        }
        private GetDigit(): number {
            throw new Error("not yet implemented");
        }
        private SkipWhiteSpaces() {
            throw new Error("not yet implemented");
        }
        private SkipWhiteSpaceAndRtlMarkCurrent(): boolean {
            throw new Error("not yet implemented");
        }
        private TrimTail() {
            throw new Error("not yet implemented");
        }
        private RemoveTrailingInQuoteSpaces() {
            throw new Error("not yet implemented");
        }
        private RemoveLeadingInQuoteSpaces() {
            throw new Error("not yet implemented");
        }
        private GetSubString(): DTSubString {
            throw new Error("not yet implemented");
        }
        private ConsumeSubString(sub: DTSubString) {
            throw new Error("not yet implemented");
        }
    }
    export class Action<T> extends MulticastDelegate implements ICloneable, ISerializable {
        public constructor(object: any, method: number) {
            throw new Error("not yet implemented");
        }

        public Invoke(obj: T) {
            throw new Error("not yet implemented");
        }
        public BeginInvoke(obj: T, callback: AsyncCallback, object: any): IAsyncResult {
            throw new Error("not yet implemented");
        }
        public EndInvoke(result: IAsyncResult) {
            throw new Error("not yet implemented");
        }
    }
    export class ValueTuple<T1, T2> extends ValueType implements IEquatable<ValueTuple<T1, T2>>, IStructuralEquatable, IStructuralComparable, IComparable, IComparable<ValueTuple<T1, T2>>, IValueTupleInternal, ITuple {
        public Item1: T1;
        public Item2: T2;

        private get __explicit__ITuple_Length(): number {
            throw new Error("not yet implemented");
        }
        public get Length(): number {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private get __explicit__ITuple_Item(): any {
            throw new Error("not yet implemented");
        }
        public get Item(): any {
            throw new Error("Invalid call (use ExplicitAs property)");
        }

        public constructor(item1: T1, item2: T2) {
            throw new Error("not yet implemented");
        }

        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public Equals(other: ValueTuple<T1, T2>): boolean {
            throw new Error("not yet implemented");
        }
        private __explicit__IStructuralEquatable_Equals(other: any, comparer: IEqualityComparer): boolean {
            throw new Error("not yet implemented");
        }
        private __explicit__IComparable_CompareTo(other: any): number {
            throw new Error("not yet implemented");
        }
        public CompareTo(other: ValueTuple<T1, T2>): number {
            throw new Error("not yet implemented");
        }
        private __explicit__IStructuralComparable_CompareTo(other: any, comparer: IComparer): number {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        private __explicit__IStructuralEquatable_GetHashCode(comparer: IEqualityComparer): number {
            throw new Error("not yet implemented");
        }
        private GetHashCodeCore(comparer: IEqualityComparer): number {
            throw new Error("not yet implemented");
        }
        private __explicit__IValueTupleInternal_GetHashCode(comparer: IEqualityComparer): number {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
        private __explicit__IValueTupleInternal_ToStringEnd(): string {
            throw new Error("not yet implemented");
        }
        public ToStringEnd(): string {
            throw new Error("Invalid call (use ExplicitAs property)");
        }

        public readonly ExplicitAsIEquatable__ValueTuple__T1__T2____: IEquatable<ValueTuple<T1, T2>> = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Length') {
                    return target.__explicit__ITuple_Length;
                }
                if (prop === 'Item') {
                    return target.__explicit__ITuple_Item;
                }
        
                if (prop === 'Equals') {
                    return target.__explicit__IStructuralEquatable_Equals.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IComparable_CompareTo.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IStructuralComparable_CompareTo.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IStructuralEquatable_GetHashCode.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IValueTupleInternal_GetHashCode.bind(target);
                }
                if (prop === 'ToStringEnd') {
                    return target.__explicit__IValueTupleInternal_ToStringEnd.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIStructuralEquatable: IStructuralEquatable = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Length') {
                    return target.__explicit__ITuple_Length;
                }
                if (prop === 'Item') {
                    return target.__explicit__ITuple_Item;
                }
        
                if (prop === 'Equals') {
                    return target.__explicit__IStructuralEquatable_Equals.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IComparable_CompareTo.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IStructuralComparable_CompareTo.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IStructuralEquatable_GetHashCode.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IValueTupleInternal_GetHashCode.bind(target);
                }
                if (prop === 'ToStringEnd') {
                    return target.__explicit__IValueTupleInternal_ToStringEnd.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIStructuralComparable: IStructuralComparable = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Length') {
                    return target.__explicit__ITuple_Length;
                }
                if (prop === 'Item') {
                    return target.__explicit__ITuple_Item;
                }
        
                if (prop === 'Equals') {
                    return target.__explicit__IStructuralEquatable_Equals.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IComparable_CompareTo.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IStructuralComparable_CompareTo.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IStructuralEquatable_GetHashCode.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IValueTupleInternal_GetHashCode.bind(target);
                }
                if (prop === 'ToStringEnd') {
                    return target.__explicit__IValueTupleInternal_ToStringEnd.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIComparable: IComparable = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Length') {
                    return target.__explicit__ITuple_Length;
                }
                if (prop === 'Item') {
                    return target.__explicit__ITuple_Item;
                }
        
                if (prop === 'Equals') {
                    return target.__explicit__IStructuralEquatable_Equals.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IComparable_CompareTo.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IStructuralComparable_CompareTo.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IStructuralEquatable_GetHashCode.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IValueTupleInternal_GetHashCode.bind(target);
                }
                if (prop === 'ToStringEnd') {
                    return target.__explicit__IValueTupleInternal_ToStringEnd.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIComparable__ValueTuple__T1__T2____: IComparable<ValueTuple<T1, T2>> = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Length') {
                    return target.__explicit__ITuple_Length;
                }
                if (prop === 'Item') {
                    return target.__explicit__ITuple_Item;
                }
        
                if (prop === 'Equals') {
                    return target.__explicit__IStructuralEquatable_Equals.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IComparable_CompareTo.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IStructuralComparable_CompareTo.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IStructuralEquatable_GetHashCode.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IValueTupleInternal_GetHashCode.bind(target);
                }
                if (prop === 'ToStringEnd') {
                    return target.__explicit__IValueTupleInternal_ToStringEnd.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIValueTupleInternal: IValueTupleInternal = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Length') {
                    return target.__explicit__ITuple_Length;
                }
                if (prop === 'Item') {
                    return target.__explicit__ITuple_Item;
                }
        
                if (prop === 'Equals') {
                    return target.__explicit__IStructuralEquatable_Equals.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IComparable_CompareTo.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IStructuralComparable_CompareTo.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IStructuralEquatable_GetHashCode.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IValueTupleInternal_GetHashCode.bind(target);
                }
                if (prop === 'ToStringEnd') {
                    return target.__explicit__IValueTupleInternal_ToStringEnd.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsITuple: ITuple = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Length') {
                    return target.__explicit__ITuple_Length;
                }
                if (prop === 'Item') {
                    return target.__explicit__ITuple_Item;
                }
        
                if (prop === 'Equals') {
                    return target.__explicit__IStructuralEquatable_Equals.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IComparable_CompareTo.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IStructuralComparable_CompareTo.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IStructuralEquatable_GetHashCode.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IValueTupleInternal_GetHashCode.bind(target);
                }
                if (prop === 'ToStringEnd') {
                    return target.__explicit__IValueTupleInternal_ToStringEnd.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
    }
    export class EventHandler<TEventArgs> extends MulticastDelegate implements ICloneable, ISerializable {
        public constructor(object: any, method: number) {
            throw new Error("not yet implemented");
        }

        public Invoke(sender: any, e: TEventArgs) {
            throw new Error("not yet implemented");
        }
        public BeginInvoke(sender: any, e: TEventArgs, callback: AsyncCallback, object: any): IAsyncResult {
            throw new Error("not yet implemented");
        }
        public EndInvoke(result: IAsyncResult) {
            throw new Error("not yet implemented");
        }
    }
    export class EventArgs {
        public static readonly Empty: EventArgs;

        public constructor() {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

    }
    export class DispatchState extends ValueType {
        public StackTrace: number[];
        public DynamicMethods: any[];
        public RemoteStackTrace: string;
        public IpForWatsonBuckets: number;
        public WatsonBuckets: number[];

        public constructor(stackTrace: number[], dynamicMethods: any[], remoteStackTrace: string, ipForWatsonBuckets: number, watsonBuckets: number[]) {
            throw new Error("not yet implemented");
        }

    }
    export enum ExceptionMessageKind {
        ThreadAbort = 1,
        ThreadInterrupted = 2,
        OutOfMemory = 3,
    }
    export class Exception implements ISerializable {
        private static _COMPlusExceptionCode: number;
        private static InnerExceptionPrefix: string;

        private _exceptionMethod: MethodBase;
        private _message: string;
        private _data: IDictionary;
        private _innerException: Exception;
        private _helpURL: string;
        private _stackTrace: number[];
        private _watsonBuckets: number[];
        private _stackTraceString: string;
        private _remoteStackTraceString: string;
        private _dynamicMethods: any[];
        private _source: string;
        private _ipForWatsonBuckets: number;
        private _xptrs: number;
        private _xcode: number;
        private _HResult: number;

        public get TargetSite(): MethodBase {
            throw new Error("not yet implemented");
        }
        private get HasBeenThrown(): boolean {
            throw new Error("not yet implemented");
        }
        private get SerializationWatsonBuckets(): any {
            throw new Error("not yet implemented");
        }
        public get Message(): string {
            throw new Error("not yet implemented");
        }
        public get Data(): IDictionary {
            throw new Error("not yet implemented");
        }
        public get InnerException(): Exception {
            throw new Error("not yet implemented");
        }
        public get HelpLink(): string {
            throw new Error("not yet implemented");
        }
        public set HelpLink(value: string) {
            throw new Error("not yet implemented");
        }
        public get Source(): string {
            throw new Error("not yet implemented");
        }
        public set Source(value: string) {
            throw new Error("not yet implemented");
        }
        public get HResult(): number {
            throw new Error("not yet implemented");
        }
        public set HResult(value: number) {
            throw new Error("not yet implemented");
        }
        public get StackTrace(): string {
            throw new Error("not yet implemented");
        }
        private get SerializationStackTraceString(): string {
            throw new Error("not yet implemented");
        }

        public constructor() {
            throw new Error("not yet implemented");
        }
        public constructor(message: string) {
            throw new Error("not yet implemented");
        }
        public constructor(message: string, innerException: Exception) {
            throw new Error("not yet implemented");
        }
        protected constructor(info: SerializationInfo, context: StreamingContext) {
            throw new Error("not yet implemented");
        }

        private CreateDataContainer(): IDictionary {
            throw new Error("not yet implemented");
        }
        private static IsImmutableAgileException(e: Exception): boolean {
            throw new Error("not yet implemented");
        }
        private static GetMethodFromStackTrace(stackTrace: any): IRuntimeMethodInfo {
            throw new Error("not yet implemented");
        }
        private GetExceptionMethodFromStackTrace(): MethodBase {
            throw new Error("not yet implemented");
        }
        private OnDeserialized(context: StreamingContext) {
            throw new Error("not yet implemented");
        }
        private InternalPreserveStackTrace() {
            throw new Error("not yet implemented");
        }
        private static PrepareForForeignExceptionRaise() {
            throw new Error("not yet implemented");
        }
        private static GetStackTracesDeepCopy(exception: Exception, out currentStackTrace: number[], out dynamicMethodArray: any[]) {
            throw new Error("not yet implemented");
        }
        private static SaveStackTracesFromDeepCopy(exception: Exception, currentStackTrace: number[], dynamicMethodArray: any[]) {
            throw new Error("not yet implemented");
        }
        private static GetExceptionCount(): number {
            throw new Error("not yet implemented");
        }
        private RestoreDispatchState(ref dispatchState: DispatchState) {
            throw new Error("not yet implemented");
        }
        private static GetMessageFromNativeResources(kind: ExceptionMessageKind): string {
            throw new Error("not yet implemented");
        }
        private static GetMessageFromNativeResources(kind: ExceptionMessageKind, retMesg: StringHandleOnStack) {
            throw new Error("not yet implemented");
        }
        private CaptureDispatchState(): DispatchState {
            throw new Error("not yet implemented");
        }
        private CanSetRemoteStackTrace(): boolean {
            throw new Error("not yet implemented");
        }
        private GetHelpContext(out helpContext: number): string {
            throw new Error("not yet implemented");
        }
        private GetClassName(): string {
            throw new Error("not yet implemented");
        }
        public GetBaseException(): Exception {
            throw new Error("not yet implemented");
        }
        public GetObjectData(info: SerializationInfo, context: StreamingContext) {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
        public GetType(): Type {
            throw new Error("not yet implemented");
        }
        private RestoreRemoteStackTrace(info: SerializationInfo, context: StreamingContext) {
            throw new Error("not yet implemented");
        }
        private GetStackTrace(): string {
            throw new Error("not yet implemented");
        }
        private SetCurrentStackTrace() {
            throw new Error("not yet implemented");
        }
        private SetRemoteStackTrace(stackTrace: string) {
            throw new Error("not yet implemented");
        }
        private static __ToString__g__Write_60_0(source: string, ref dest: Span<string>) {
            throw new Error("not yet implemented");
        }
    }
    export namespace Exception {
        export enum ExceptionMessageKind {
            ThreadAbort = 1,
            ThreadInterrupted = 2,
            OutOfMemory = 3,
        }

        export class DispatchState extends ValueType {
            public StackTrace: number[];
            public DynamicMethods: any[];
            public RemoteStackTrace: string;
            public IpForWatsonBuckets: number;
            public WatsonBuckets: number[];

            public constructor(stackTrace: number[], dynamicMethods: any[], remoteStackTrace: string, ipForWatsonBuckets: number, watsonBuckets: number[]) {
                throw new Error("not yet implemented");
            }

        }
    }
    export class Func<T, TResult> extends MulticastDelegate implements ICloneable, ISerializable {
        public constructor(object: any, method: number) {
            throw new Error("not yet implemented");
        }

        public Invoke(arg: T): TResult {
            throw new Error("not yet implemented");
        }
        public BeginInvoke(arg: T, callback: AsyncCallback, object: any): IAsyncResult {
            throw new Error("not yet implemented");
        }
        public EndInvoke(result: IAsyncResult): TResult {
            throw new Error("not yet implemented");
        }
    }
    export class AggregateException extends Exception implements ISerializable {
        private _innerExceptions: Exception[];
        private _rocView: ReadOnlyCollection<Exception>;

        public get InnerExceptions(): ReadOnlyCollection<Exception> {
            throw new Error("not yet implemented");
        }
        public get Message(): string {
            throw new Error("not yet implemented");
        }
        private get InnerExceptionCount(): number {
            throw new Error("not yet implemented");
        }
        private get InternalInnerExceptions(): Exception[] {
            throw new Error("not yet implemented");
        }

        public constructor() {
            throw new Error("not yet implemented");
        }
        public constructor(message: string) {
            throw new Error("not yet implemented");
        }
        public constructor(message: string, innerException: Exception) {
            throw new Error("not yet implemented");
        }
        public constructor(innerExceptions: IEnumerable<Exception>) {
            throw new Error("not yet implemented");
        }
        public constructor(innerExceptions: Exception[]) {
            throw new Error("not yet implemented");
        }
        public constructor(message: string, innerExceptions: IEnumerable<Exception>) {
            throw new Error("not yet implemented");
        }
        public constructor(message: string, innerExceptions: Exception[]) {
            throw new Error("not yet implemented");
        }
        private constructor(message: string, innerExceptions: Exception[], cloneExceptions: boolean) {
            throw new Error("not yet implemented");
        }
        protected constructor(innerExceptionInfos: List<ExceptionDispatchInfo>) {
            throw new Error("not yet implemented");
        }
        protected constructor(message: string, innerExceptionInfos: List<ExceptionDispatchInfo>) {
            throw new Error("not yet implemented");
        }
        protected constructor(info: SerializationInfo, context: StreamingContext) {
            throw new Error("not yet implemented");
        }

        public GetObjectData(info: SerializationInfo, context: StreamingContext) {
            throw new Error("not yet implemented");
        }
        public GetBaseException(): Exception {
            throw new Error("not yet implemented");
        }
        public Handle(predicate: Func<Exception, boolean>) {
            throw new Error("not yet implemented");
        }
        public Flatten(): AggregateException {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
    }
    export class Func<TResult> extends MulticastDelegate implements ICloneable, ISerializable {
        public constructor(object: any, method: number) {
            throw new Error("not yet implemented");
        }

        public Invoke(): TResult {
            throw new Error("not yet implemented");
        }
        public BeginInvoke(callback: AsyncCallback, object: any): IAsyncResult {
            throw new Error("not yet implemented");
        }
        public EndInvoke(result: IAsyncResult): TResult {
            throw new Error("not yet implemented");
        }
    }
    export class LocalDataStoreSlot {
        private __Data__k__BackingField: ThreadLocal<any>;

        private get Data(): ThreadLocal<any> {
            throw new Error("not yet implemented");
        }
        private set Data(value: ThreadLocal<any>) {
            throw new Error("not yet implemented");
        }

        protected constructor(data: ThreadLocal<any>) {
            throw new Error("not yet implemented");
        }

        private Finalize() {
            throw new Error("not yet implemented");
        }
    }
    export class EventHandler extends MulticastDelegate implements ICloneable, ISerializable {
        public constructor(object: any, method: number) {
            throw new Error("not yet implemented");
        }

        public Invoke(sender: any, e: EventArgs) {
            throw new Error("not yet implemented");
        }
        public BeginInvoke(sender: any, e: EventArgs, callback: AsyncCallback, object: any): IAsyncResult {
            throw new Error("not yet implemented");
        }
        public EndInvoke(result: IAsyncResult) {
            throw new Error("not yet implemented");
        }
    }
    export class ResolveEventArgs extends EventArgs {
        private __Name__k__BackingField: string;
        private __RequestingAssembly__k__BackingField: Assembly;

        public get Name(): string {
            throw new Error("not yet implemented");
        }
        public get RequestingAssembly(): Assembly {
            throw new Error("not yet implemented");
        }

        public constructor(name: string) {
            throw new Error("not yet implemented");
        }
        public constructor(name: string, requestingAssembly: Assembly) {
            throw new Error("not yet implemented");
        }

    }
    export class ResolveEventHandler extends MulticastDelegate implements ICloneable, ISerializable {
        public constructor(object: any, method: number) {
            throw new Error("not yet implemented");
        }

        public Invoke(sender: any, args: ResolveEventArgs): Assembly {
            throw new Error("not yet implemented");
        }
        public BeginInvoke(sender: any, args: ResolveEventArgs, callback: AsyncCallback, object: any): IAsyncResult {
            throw new Error("not yet implemented");
        }
        public EndInvoke(result: IAsyncResult): Assembly {
            throw new Error("not yet implemented");
        }
    }
    export class AppDomainSetup {
        public get ApplicationBase(): string {
            throw new Error("not yet implemented");
        }
        public get TargetFrameworkName(): string {
            throw new Error("not yet implemented");
        }

        protected constructor() {
            throw new Error("not yet implemented");
        }

    }
    export class Action<T1, T2> extends MulticastDelegate implements ICloneable, ISerializable {
        public constructor(object: any, method: number) {
            throw new Error("not yet implemented");
        }

        public Invoke(arg1: T1, arg2: T2) {
            throw new Error("not yet implemented");
        }
        public BeginInvoke(arg1: T1, arg2: T2, callback: AsyncCallback, object: any): IAsyncResult {
            throw new Error("not yet implemented");
        }
        public EndInvoke(result: IAsyncResult) {
            throw new Error("not yet implemented");
        }
    }
    export class UnhandledExceptionEventArgs extends EventArgs {
        private _exception: any;
        private _isTerminating: boolean;

        public get ExceptionObject(): any {
            throw new Error("not yet implemented");
        }
        public get IsTerminating(): boolean {
            throw new Error("not yet implemented");
        }

        public constructor(exception: any, isTerminating: boolean) {
            throw new Error("not yet implemented");
        }

    }
    export class UnhandledExceptionEventHandler extends MulticastDelegate implements ICloneable, ISerializable {
        public constructor(object: any, method: number) {
            throw new Error("not yet implemented");
        }

        public Invoke(sender: any, e: UnhandledExceptionEventArgs) {
            throw new Error("not yet implemented");
        }
        public BeginInvoke(sender: any, e: UnhandledExceptionEventArgs, callback: AsyncCallback, object: any): IAsyncResult {
            throw new Error("not yet implemented");
        }
        public EndInvoke(result: IAsyncResult) {
            throw new Error("not yet implemented");
        }
    }
    export class Version implements ICloneable, IComparable, IComparable<Version>, IEquatable<Version>, ISpanFormattable, IFormattable, IUtf8SpanFormattable {
        private _Major: number;
        private _Minor: number;
        private _Build: number;
        private _Revision: number;

        public get Major(): number {
            throw new Error("not yet implemented");
        }
        public get Minor(): number {
            throw new Error("not yet implemented");
        }
        public get Build(): number {
            throw new Error("not yet implemented");
        }
        public get Revision(): number {
            throw new Error("not yet implemented");
        }
        public get MajorRevision(): number {
            throw new Error("not yet implemented");
        }
        public get MinorRevision(): number {
            throw new Error("not yet implemented");
        }
        private get DefaultFormatFieldCount(): number {
            throw new Error("not yet implemented");
        }

        public constructor(major: number, minor: number, build: number, revision: number) {
            throw new Error("not yet implemented");
        }
        public constructor(major: number, minor: number, build: number) {
            throw new Error("not yet implemented");
        }
        public constructor(major: number, minor: number) {
            throw new Error("not yet implemented");
        }
        public constructor(version: string) {
            throw new Error("not yet implemented");
        }
        public constructor() {
            throw new Error("not yet implemented");
        }
        private constructor(version: Version) {
            throw new Error("not yet implemented");
        }

        public Clone(): any {
            throw new Error("not yet implemented");
        }
        public CompareTo(version: any): number {
            throw new Error("not yet implemented");
        }
        public CompareTo(value: Version): number {
            throw new Error("not yet implemented");
        }
        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public Equals(obj: Version): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
        public ToString(fieldCount: number): string {
            throw new Error("not yet implemented");
        }
        private __explicit__IFormattable_ToString(format: string, formatProvider: IFormatProvider): string {
            throw new Error("not yet implemented");
        }
        public TryFormat(destination: Span<string>, out charsWritten: number): boolean {
            throw new Error("not yet implemented");
        }
        public TryFormat(destination: Span<string>, fieldCount: number, out charsWritten: number): boolean {
            throw new Error("not yet implemented");
        }
        public TryFormat(utf8Destination: Span<number>, out bytesWritten: number): boolean {
            throw new Error("not yet implemented");
        }
        public TryFormat(utf8Destination: Span<number>, fieldCount: number, out bytesWritten: number): boolean {
            throw new Error("not yet implemented");
        }
        private TryFormatCore(destination: Span<TChar>, fieldCount: number, out charsWritten: number): boolean {
            throw new Error("not yet implemented");
        }
        private __explicit__ISpanFormattable_TryFormat(destination: Span<string>, out charsWritten: number, format: ReadOnlySpan<string>, provider: IFormatProvider): boolean {
            throw new Error("not yet implemented");
        }
        private __explicit__IUtf8SpanFormattable_TryFormat(utf8Destination: Span<number>, out bytesWritten: number, format: ReadOnlySpan<string>, provider: IFormatProvider): boolean {
            throw new Error("not yet implemented");
        }
        public static Parse(input: string): Version {
            throw new Error("not yet implemented");
        }
        public static Parse(input: ReadOnlySpan<string>): Version {
            throw new Error("not yet implemented");
        }
        public static TryParse(input: string, out result: Version): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParse(input: ReadOnlySpan<string>, out result: Version): boolean {
            throw new Error("not yet implemented");
        }
        private static ParseVersion(input: ReadOnlySpan<string>, throwOnFailure: boolean): Version {
            throw new Error("not yet implemented");
        }
        private static TryParseComponent(component: ReadOnlySpan<string>, componentName: string, throwOnFailure: boolean, out parsedComponent: number): boolean {
            throw new Error("not yet implemented");
        }
        private static __TryFormatCore__g__ThrowArgumentException_35_0(failureUpperBound: string) {
            throw new Error("not yet implemented");
        }
    }
    export class TransitionTime extends ValueType implements IEquatable<TransitionTime>, ISerializable, IDeserializationCallback {
        private _timeOfDay: DateTime;
        private _month: number;
        private _week: number;
        private _day: number;
        private _dayOfWeek: DayOfWeek;
        private _isFixedDateRule: boolean;

        public get TimeOfDay(): DateTime {
            throw new Error("not yet implemented");
        }
        public get Month(): number {
            throw new Error("not yet implemented");
        }
        public get Week(): number {
            throw new Error("not yet implemented");
        }
        public get Day(): number {
            throw new Error("not yet implemented");
        }
        public get DayOfWeek(): DayOfWeek {
            throw new Error("not yet implemented");
        }
        public get IsFixedDateRule(): boolean {
            throw new Error("not yet implemented");
        }

        private constructor(timeOfDay: DateTime, month: number, week: number, day: number, dayOfWeek: DayOfWeek, isFixedDateRule: boolean) {
            throw new Error("not yet implemented");
        }
        private constructor(info: SerializationInfo, context: StreamingContext) {
            throw new Error("not yet implemented");
        }

        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public Equals(other: TransitionTime): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public static CreateFixedDateRule(timeOfDay: DateTime, month: number, day: number): TransitionTime {
            throw new Error("not yet implemented");
        }
        public static CreateFloatingDateRule(timeOfDay: DateTime, month: number, week: number, dayOfWeek: DayOfWeek): TransitionTime {
            throw new Error("not yet implemented");
        }
        private static ValidateTransitionTime(timeOfDay: DateTime, month: number, week: number, day: number, dayOfWeek: DayOfWeek) {
            throw new Error("not yet implemented");
        }
        private __explicit__IDeserializationCallback_OnDeserialization(sender: any) {
            throw new Error("not yet implemented");
        }
        public OnDeserialization(sender: any) {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__ISerializable_GetObjectData(info: SerializationInfo, context: StreamingContext) {
            throw new Error("not yet implemented");
        }
        public GetObjectData(info: SerializationInfo, context: StreamingContext) {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
    }
    export class AdjustmentRule implements IEquatable<AdjustmentRule>, ISerializable, IDeserializationCallback {
        private static readonly DaylightDeltaAdjustment: TimeSpan;
        private static readonly MaxDaylightDelta: TimeSpan;

        private _dateStart: DateTime;
        private _dateEnd: DateTime;
        private _daylightDelta: TimeSpan;
        private _daylightTransitionStart: TransitionTime;
        private _daylightTransitionEnd: TransitionTime;
        private _baseUtcOffsetDelta: TimeSpan;
        private _noDaylightTransitions: boolean;

        public get DateStart(): DateTime {
            throw new Error("not yet implemented");
        }
        public get DateEnd(): DateTime {
            throw new Error("not yet implemented");
        }
        public get DaylightDelta(): TimeSpan {
            throw new Error("not yet implemented");
        }
        public get DaylightTransitionStart(): TransitionTime {
            throw new Error("not yet implemented");
        }
        public get DaylightTransitionEnd(): TransitionTime {
            throw new Error("not yet implemented");
        }
        public get BaseUtcOffsetDelta(): TimeSpan {
            throw new Error("not yet implemented");
        }
        private get NoDaylightTransitions(): boolean {
            throw new Error("not yet implemented");
        }
        private get HasDaylightSaving(): boolean {
            throw new Error("not yet implemented");
        }

        private constructor(dateStart: DateTime, dateEnd: DateTime, daylightDelta: TimeSpan, daylightTransitionStart: TransitionTime, daylightTransitionEnd: TransitionTime, baseUtcOffsetDelta: TimeSpan, noDaylightTransitions: boolean) {
            throw new Error("not yet implemented");
        }
        private constructor(info: SerializationInfo, context: StreamingContext) {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

        public Equals(other: AdjustmentRule): boolean {
            throw new Error("not yet implemented");
        }
        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public static CreateAdjustmentRule(dateStart: DateTime, dateEnd: DateTime, daylightDelta: TimeSpan, daylightTransitionStart: TransitionTime, daylightTransitionEnd: TransitionTime, baseUtcOffsetDelta: TimeSpan): AdjustmentRule {
            throw new Error("not yet implemented");
        }
        public static CreateAdjustmentRule(dateStart: DateTime, dateEnd: DateTime, daylightDelta: TimeSpan, daylightTransitionStart: TransitionTime, daylightTransitionEnd: TransitionTime): AdjustmentRule {
            throw new Error("not yet implemented");
        }
        private static CreateAdjustmentRule(dateStart: DateTime, dateEnd: DateTime, daylightDelta: TimeSpan, daylightTransitionStart: TransitionTime, daylightTransitionEnd: TransitionTime, baseUtcOffsetDelta: TimeSpan, noDaylightTransitions: boolean): AdjustmentRule {
            throw new Error("not yet implemented");
        }
        private IsStartDateMarkerForBeginningOfYear(): boolean {
            throw new Error("not yet implemented");
        }
        private IsEndDateMarkerForEndOfYear(): boolean {
            throw new Error("not yet implemented");
        }
        private static ValidateAdjustmentRule(dateStart: DateTime, dateEnd: DateTime, daylightDelta: TimeSpan, daylightTransitionStart: TransitionTime, daylightTransitionEnd: TransitionTime, noDaylightTransitions: boolean) {
            throw new Error("not yet implemented");
        }
        private static AdjustDaylightDeltaToExpectedRange(ref daylightDelta: TimeSpan, ref baseUtcOffsetDelta: TimeSpan) {
            throw new Error("not yet implemented");
        }
        private __explicit__IDeserializationCallback_OnDeserialization(sender: any) {
            throw new Error("not yet implemented");
        }
        public OnDeserialization(sender: any) {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__ISerializable_GetObjectData(info: SerializationInfo, context: StreamingContext) {
            throw new Error("not yet implemented");
        }
        public GetObjectData(info: SerializationInfo, context: StreamingContext) {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
    }
    export class OffsetAndRule {
        public Year: number;
        public Offset: TimeSpan;
        public Rule: AdjustmentRule;

        public constructor(year: number, offset: TimeSpan, rule: AdjustmentRule) {
            throw new Error("not yet implemented");
        }

    }
    export enum DateTimeKind {
        Unspecified = 0,
        Utc = 1,
        Local = 2,
    }
    export class CachedData {
        private _localTimeZone: TimeZoneInfo;
        public _systemTimeZones: Dictionary<string, TimeZoneInfo>;
        public _readOnlySystemTimeZones: ReadOnlyCollection<TimeZoneInfo>;
        public _readOnlyUnsortedSystemTimeZones: ReadOnlyCollection<TimeZoneInfo>;
        public _timeZonesUsingAlternativeIds: Dictionary<string, TimeZoneInfo>;
        public _allSystemTimeZonesRead: boolean;
        private _oneYearLocalFromUtc: OffsetAndRule;

        public get Local(): TimeZoneInfo {
            throw new Error("not yet implemented");
        }

        public constructor() {
            throw new Error("not yet implemented");
        }

        private CreateLocal(): TimeZoneInfo {
            throw new Error("not yet implemented");
        }
        public GetCorrespondingKind(timeZone: TimeZoneInfo): DateTimeKind {
            throw new Error("not yet implemented");
        }
        private static GetCurrentOneYearLocal(): TimeZoneInfo {
            throw new Error("not yet implemented");
        }
        public GetOneYearLocalFromUtc(year: number): OffsetAndRule {
            throw new Error("not yet implemented");
        }
    }
    export enum ParseFailureKind {
        None = 0,
        ArgumentNull_String = 1,
        Format_BadDatePattern = 2,
        Format_BadDateTime = 3,
        Format_BadDateTimeCalendar = 4,
        Format_BadDayOfWeek = 5,
        Format_BadFormatSpecifier = 6,
        Format_BadQuote = 7,
        Format_DateOutOfRange = 8,
        Format_MissingIncompleteDate = 9,
        Format_NoFormatSpecifier = 10,
        Format_OffsetOutOfRange = 11,
        Format_RepeatDateTimePattern = 12,
        Format_UnknownDateTimeWord = 13,
        Format_UTCOutOfRange = 14,
        Argument_InvalidDateStyles = 15,
        Argument_BadFormatSpecifier = 16,
        Format_BadDateOnly = 17,
        Format_BadTimeOnly = 18,
        Format_DateTimeOnlyContainsNoneDateParts = 19,
    }
    export class TimeOnly extends ValueType implements IComparable, IComparable<TimeOnly>, IEquatable<TimeOnly>, ISpanFormattable, IFormattable, ISpanParsable<TimeOnly>, IParsable<TimeOnly>, IUtf8SpanFormattable {
        public static get MinValue(): TimeOnly {
            throw new Error("not yet implemented");
        }
        public static get MaxValue(): TimeOnly {
            throw new Error("not yet implemented");
        }

        private _ticks: number;

        public get Hour(): number {
            throw new Error("not yet implemented");
        }
        public get Minute(): number {
            throw new Error("not yet implemented");
        }
        public get Second(): number {
            throw new Error("not yet implemented");
        }
        public get Millisecond(): number {
            throw new Error("not yet implemented");
        }
        public get Microsecond(): number {
            throw new Error("not yet implemented");
        }
        public get Nanosecond(): number {
            throw new Error("not yet implemented");
        }
        public get Ticks(): number {
            throw new Error("not yet implemented");
        }

        public constructor(hour: number, minute: number) {
            throw new Error("not yet implemented");
        }
        public constructor(hour: number, minute: number, second: number) {
            throw new Error("not yet implemented");
        }
        public constructor(hour: number, minute: number, second: number, millisecond: number) {
            throw new Error("not yet implemented");
        }
        public constructor(hour: number, minute: number, second: number, millisecond: number, microsecond: number) {
            throw new Error("not yet implemented");
        }
        public constructor(ticks: number) {
            throw new Error("not yet implemented");
        }
        protected constructor(ticks: number) {
            throw new Error("not yet implemented");
        }

        private AddTicks(ticks: number): TimeOnly {
            throw new Error("not yet implemented");
        }
        private AddTicks(ticks: number, out wrappedDays: number): TimeOnly {
            throw new Error("not yet implemented");
        }
        public Add(value: TimeSpan): TimeOnly {
            throw new Error("not yet implemented");
        }
        public Add(value: TimeSpan, out wrappedDays: number): TimeOnly {
            throw new Error("not yet implemented");
        }
        public AddHours(value: number): TimeOnly {
            throw new Error("not yet implemented");
        }
        public AddHours(value: number, out wrappedDays: number): TimeOnly {
            throw new Error("not yet implemented");
        }
        public AddMinutes(value: number): TimeOnly {
            throw new Error("not yet implemented");
        }
        public AddMinutes(value: number, out wrappedDays: number): TimeOnly {
            throw new Error("not yet implemented");
        }
        public IsBetween(start: TimeOnly, end: TimeOnly): boolean {
            throw new Error("not yet implemented");
        }
        public Deconstruct(out hour: number, out minute: number) {
            throw new Error("not yet implemented");
        }
        public Deconstruct(out hour: number, out minute: number, out second: number) {
            throw new Error("not yet implemented");
        }
        public Deconstruct(out hour: number, out minute: number, out second: number, out millisecond: number) {
            throw new Error("not yet implemented");
        }
        public Deconstruct(out hour: number, out minute: number, out second: number, out millisecond: number, out microsecond: number) {
            throw new Error("not yet implemented");
        }
        public static FromTimeSpan(timeSpan: TimeSpan): TimeOnly {
            throw new Error("not yet implemented");
        }
        public static FromDateTime(dateTime: DateTime): TimeOnly {
            throw new Error("not yet implemented");
        }
        public ToTimeSpan(): TimeSpan {
            throw new Error("not yet implemented");
        }
        private ToDateTime(): DateTime {
            throw new Error("not yet implemented");
        }
        public CompareTo(value: TimeOnly): number {
            throw new Error("not yet implemented");
        }
        public CompareTo(value: any): number {
            throw new Error("not yet implemented");
        }
        public Equals(value: TimeOnly): boolean {
            throw new Error("not yet implemented");
        }
        public Equals(value: any): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public static Parse(s: ReadOnlySpan<string>, provider: IFormatProvider, style: DateTimeStyles): TimeOnly {
            throw new Error("not yet implemented");
        }
        public static ParseExact(s: ReadOnlySpan<string>, format: ReadOnlySpan<string>, provider: IFormatProvider, style: DateTimeStyles): TimeOnly {
            throw new Error("not yet implemented");
        }
        public static ParseExact(s: ReadOnlySpan<string>, formats: string[]): TimeOnly {
            throw new Error("not yet implemented");
        }
        public static ParseExact(s: ReadOnlySpan<string>, formats: string[], provider: IFormatProvider, style: DateTimeStyles): TimeOnly {
            throw new Error("not yet implemented");
        }
        public static Parse(s: string): TimeOnly {
            throw new Error("not yet implemented");
        }
        public static Parse(s: string, provider: IFormatProvider, style: DateTimeStyles): TimeOnly {
            throw new Error("not yet implemented");
        }
        public static ParseExact(s: string, format: string): TimeOnly {
            throw new Error("not yet implemented");
        }
        public static ParseExact(s: string, format: string, provider: IFormatProvider, style: DateTimeStyles): TimeOnly {
            throw new Error("not yet implemented");
        }
        public static ParseExact(s: string, formats: string[]): TimeOnly {
            throw new Error("not yet implemented");
        }
        public static ParseExact(s: string, formats: string[], provider: IFormatProvider, style: DateTimeStyles): TimeOnly {
            throw new Error("not yet implemented");
        }
        public static TryParse(s: ReadOnlySpan<string>, out result: TimeOnly): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParse(s: ReadOnlySpan<string>, provider: IFormatProvider, style: DateTimeStyles, out result: TimeOnly): boolean {
            throw new Error("not yet implemented");
        }
        private static TryParseInternal(s: ReadOnlySpan<string>, provider: IFormatProvider, style: DateTimeStyles, out result: TimeOnly): ParseFailureKind {
            throw new Error("not yet implemented");
        }
        public static TryParseExact(s: ReadOnlySpan<string>, format: ReadOnlySpan<string>, out result: TimeOnly): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParseExact(s: ReadOnlySpan<string>, format: ReadOnlySpan<string>, provider: IFormatProvider, style: DateTimeStyles, out result: TimeOnly): boolean {
            throw new Error("not yet implemented");
        }
        private static TryParseExactInternal(s: ReadOnlySpan<string>, format: ReadOnlySpan<string>, provider: IFormatProvider, style: DateTimeStyles, out result: TimeOnly): ParseFailureKind {
            throw new Error("not yet implemented");
        }
        public static TryParseExact(s: ReadOnlySpan<string>, formats: string[], out result: TimeOnly): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParseExact(s: ReadOnlySpan<string>, formats: string[], provider: IFormatProvider, style: DateTimeStyles, out result: TimeOnly): boolean {
            throw new Error("not yet implemented");
        }
        private static TryParseExactInternal(s: ReadOnlySpan<string>, formats: string[], provider: IFormatProvider, style: DateTimeStyles, out result: TimeOnly): ParseFailureKind {
            throw new Error("not yet implemented");
        }
        public static TryParse(s: string, out result: TimeOnly): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParse(s: string, provider: IFormatProvider, style: DateTimeStyles, out result: TimeOnly): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParseExact(s: string, format: string, out result: TimeOnly): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParseExact(s: string, format: string, provider: IFormatProvider, style: DateTimeStyles, out result: TimeOnly): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParseExact(s: string, formats: string[], out result: TimeOnly): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParseExact(s: string, formats: string[], provider: IFormatProvider, style: DateTimeStyles, out result: TimeOnly): boolean {
            throw new Error("not yet implemented");
        }
        private static ThrowOnError(result: ParseFailureKind, s: ReadOnlySpan<string>) {
            throw new Error("not yet implemented");
        }
        public ToLongTimeString(): string {
            throw new Error("not yet implemented");
        }
        public ToShortTimeString(): string {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
        public ToString(format: string): string {
            throw new Error("not yet implemented");
        }
        public ToString(provider: IFormatProvider): string {
            throw new Error("not yet implemented");
        }
        public ToString(format: string, provider: IFormatProvider): string {
            throw new Error("not yet implemented");
        }
        public TryFormat(destination: Span<string>, out charsWritten: number, format: ReadOnlySpan<string>, provider: IFormatProvider): boolean {
            throw new Error("not yet implemented");
        }
        public TryFormat(utf8Destination: Span<number>, out bytesWritten: number, format: ReadOnlySpan<string>, provider: IFormatProvider): boolean {
            throw new Error("not yet implemented");
        }
        private TryFormatCore(destination: Span<TChar>, out written: number, format: ReadOnlySpan<string>, provider: IFormatProvider): boolean {
            throw new Error("not yet implemented");
        }
        public static Parse(s: string, provider: IFormatProvider): TimeOnly {
            throw new Error("not yet implemented");
        }
        public static TryParse(s: string, provider: IFormatProvider, out result: TimeOnly): boolean {
            throw new Error("not yet implemented");
        }
        public static Parse(s: ReadOnlySpan<string>, provider: IFormatProvider): TimeOnly {
            throw new Error("not yet implemented");
        }
        public static TryParse(s: ReadOnlySpan<string>, provider: IFormatProvider, out result: TimeOnly): boolean {
            throw new Error("not yet implemented");
        }
    }
    export namespace TimeOnly {
        export class ____c {
            public static readonly ____9: ____c;
            public static ____9__90_0: SpanAction<string, TimeOnly>;
            public static ____9__90_1: SpanAction<string, TimeOnly>;

            private static staticctor_initialize = (() => {
                throw new Error("not yet implemented");
            })();
            private constructor() { }
            public constructor() {
                throw new Error("not yet implemented");
            }

            private __ToString__b__90_0(destination: Span<string>, value: TimeOnly) {
                throw new Error("not yet implemented");
            }
            private __ToString__b__90_1(destination: Span<string>, value: TimeOnly) {
                throw new Error("not yet implemented");
            }
        }
    }
    export class DateOnly extends ValueType implements IComparable, IComparable<DateOnly>, IEquatable<DateOnly>, ISpanFormattable, IFormattable, ISpanParsable<DateOnly>, IParsable<DateOnly>, IUtf8SpanFormattable {
        public static get MinValue(): DateOnly {
            throw new Error("not yet implemented");
        }
        public static get MaxValue(): DateOnly {
            throw new Error("not yet implemented");
        }

        private _dayNumber: number;

        public get Year(): number {
            throw new Error("not yet implemented");
        }
        public get Month(): number {
            throw new Error("not yet implemented");
        }
        public get Day(): number {
            throw new Error("not yet implemented");
        }
        public get DayOfWeek(): DayOfWeek {
            throw new Error("not yet implemented");
        }
        public get DayOfYear(): number {
            throw new Error("not yet implemented");
        }
        public get DayNumber(): number {
            throw new Error("not yet implemented");
        }

        private constructor(dayNumber: number) {
            throw new Error("not yet implemented");
        }
        public constructor(year: number, month: number, day: number) {
            throw new Error("not yet implemented");
        }
        public constructor(year: number, month: number, day: number, calendar: Calendar) {
            throw new Error("not yet implemented");
        }

        private static DayNumberFromDateTime(dt: DateTime): number {
            throw new Error("not yet implemented");
        }
        private GetEquivalentDateTime(): DateTime {
            throw new Error("not yet implemented");
        }
        public static FromDayNumber(dayNumber: number): DateOnly {
            throw new Error("not yet implemented");
        }
        public AddDays(value: number): DateOnly {
            throw new Error("not yet implemented");
        }
        public AddMonths(value: number): DateOnly {
            throw new Error("not yet implemented");
        }
        public AddYears(value: number): DateOnly {
            throw new Error("not yet implemented");
        }
        public Deconstruct(out year: number, out month: number, out day: number) {
            throw new Error("not yet implemented");
        }
        public ToDateTime(time: TimeOnly): DateTime {
            throw new Error("not yet implemented");
        }
        public ToDateTime(time: TimeOnly, kind: DateTimeKind): DateTime {
            throw new Error("not yet implemented");
        }
        public static FromDateTime(dateTime: DateTime): DateOnly {
            throw new Error("not yet implemented");
        }
        public CompareTo(value: DateOnly): number {
            throw new Error("not yet implemented");
        }
        public CompareTo(value: any): number {
            throw new Error("not yet implemented");
        }
        public Equals(value: DateOnly): boolean {
            throw new Error("not yet implemented");
        }
        public Equals(value: any): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public static Parse(s: ReadOnlySpan<string>, provider: IFormatProvider, style: DateTimeStyles): DateOnly {
            throw new Error("not yet implemented");
        }
        public static ParseExact(s: ReadOnlySpan<string>, format: ReadOnlySpan<string>, provider: IFormatProvider, style: DateTimeStyles): DateOnly {
            throw new Error("not yet implemented");
        }
        public static ParseExact(s: ReadOnlySpan<string>, formats: string[]): DateOnly {
            throw new Error("not yet implemented");
        }
        public static ParseExact(s: ReadOnlySpan<string>, formats: string[], provider: IFormatProvider, style: DateTimeStyles): DateOnly {
            throw new Error("not yet implemented");
        }
        public static Parse(s: string): DateOnly {
            throw new Error("not yet implemented");
        }
        public static Parse(s: string, provider: IFormatProvider, style: DateTimeStyles): DateOnly {
            throw new Error("not yet implemented");
        }
        public static ParseExact(s: string, format: string): DateOnly {
            throw new Error("not yet implemented");
        }
        public static ParseExact(s: string, format: string, provider: IFormatProvider, style: DateTimeStyles): DateOnly {
            throw new Error("not yet implemented");
        }
        public static ParseExact(s: string, formats: string[]): DateOnly {
            throw new Error("not yet implemented");
        }
        public static ParseExact(s: string, formats: string[], provider: IFormatProvider, style: DateTimeStyles): DateOnly {
            throw new Error("not yet implemented");
        }
        public static TryParse(s: ReadOnlySpan<string>, out result: DateOnly): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParse(s: ReadOnlySpan<string>, provider: IFormatProvider, style: DateTimeStyles, out result: DateOnly): boolean {
            throw new Error("not yet implemented");
        }
        private static TryParseInternal(s: ReadOnlySpan<string>, provider: IFormatProvider, style: DateTimeStyles, out result: DateOnly): ParseFailureKind {
            throw new Error("not yet implemented");
        }
        public static TryParseExact(s: ReadOnlySpan<string>, format: ReadOnlySpan<string>, out result: DateOnly): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParseExact(s: ReadOnlySpan<string>, format: ReadOnlySpan<string>, provider: IFormatProvider, style: DateTimeStyles, out result: DateOnly): boolean {
            throw new Error("not yet implemented");
        }
        private static TryParseExactInternal(s: ReadOnlySpan<string>, format: ReadOnlySpan<string>, provider: IFormatProvider, style: DateTimeStyles, out result: DateOnly): ParseFailureKind {
            throw new Error("not yet implemented");
        }
        public static TryParseExact(s: ReadOnlySpan<string>, formats: string[], out result: DateOnly): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParseExact(s: ReadOnlySpan<string>, formats: string[], provider: IFormatProvider, style: DateTimeStyles, out result: DateOnly): boolean {
            throw new Error("not yet implemented");
        }
        private static TryParseExactInternal(s: ReadOnlySpan<string>, formats: string[], provider: IFormatProvider, style: DateTimeStyles, out result: DateOnly): ParseFailureKind {
            throw new Error("not yet implemented");
        }
        public static TryParse(s: string, out result: DateOnly): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParse(s: string, provider: IFormatProvider, style: DateTimeStyles, out result: DateOnly): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParseExact(s: string, format: string, out result: DateOnly): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParseExact(s: string, format: string, provider: IFormatProvider, style: DateTimeStyles, out result: DateOnly): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParseExact(s: string, formats: string[], out result: DateOnly): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParseExact(s: string, formats: string[], provider: IFormatProvider, style: DateTimeStyles, out result: DateOnly): boolean {
            throw new Error("not yet implemented");
        }
        private static ThrowOnError(result: ParseFailureKind, s: ReadOnlySpan<string>) {
            throw new Error("not yet implemented");
        }
        public ToLongDateString(): string {
            throw new Error("not yet implemented");
        }
        public ToShortDateString(): string {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
        public ToString(format: string): string {
            throw new Error("not yet implemented");
        }
        public ToString(provider: IFormatProvider): string {
            throw new Error("not yet implemented");
        }
        public ToString(format: string, provider: IFormatProvider): string {
            throw new Error("not yet implemented");
        }
        public TryFormat(destination: Span<string>, out charsWritten: number, format: ReadOnlySpan<string>, provider: IFormatProvider): boolean {
            throw new Error("not yet implemented");
        }
        public TryFormat(utf8Destination: Span<number>, out bytesWritten: number, format: ReadOnlySpan<string>, provider: IFormatProvider): boolean {
            throw new Error("not yet implemented");
        }
        private TryFormatCore(destination: Span<TChar>, out charsWritten: number, format: ReadOnlySpan<string>, provider: IFormatProvider): boolean {
            throw new Error("not yet implemented");
        }
        public static Parse(s: string, provider: IFormatProvider): DateOnly {
            throw new Error("not yet implemented");
        }
        public static TryParse(s: string, provider: IFormatProvider, out result: DateOnly): boolean {
            throw new Error("not yet implemented");
        }
        public static Parse(s: ReadOnlySpan<string>, provider: IFormatProvider): DateOnly {
            throw new Error("not yet implemented");
        }
        public static TryParse(s: ReadOnlySpan<string>, provider: IFormatProvider, out result: DateOnly): boolean {
            throw new Error("not yet implemented");
        }
        private static __AddDays__g__ThrowOutOfRange_25_0() {
            throw new Error("not yet implemented");
        }
    }
    export namespace DateOnly {
        export class ____c {
            public static readonly ____9: ____c;
            public static ____9__77_0: SpanAction<string, DateOnly>;
            public static ____9__77_1: SpanAction<string, DateOnly>;

            private static staticctor_initialize = (() => {
                throw new Error("not yet implemented");
            })();
            private constructor() { }
            public constructor() {
                throw new Error("not yet implemented");
            }

            private __ToString__b__77_0(destination: Span<string>, value: DateOnly) {
                throw new Error("not yet implemented");
            }
            private __ToString__b__77_1(destination: Span<string>, value: DateOnly) {
                throw new Error("not yet implemented");
            }
        }
    }
    export class DateTimeOffset extends ValueType implements IComparable, ISpanFormattable, IFormattable, IComparable<DateTimeOffset>, IEquatable<DateTimeOffset>, ISerializable, IDeserializationCallback, ISpanParsable<DateTimeOffset>, IParsable<DateTimeOffset>, IUtf8SpanFormattable {
        public static readonly MinValue: DateTimeOffset;
        public static readonly MaxValue: DateTimeOffset;
        public static readonly UnixEpoch: DateTimeOffset;

        public static get UtcNow(): DateTimeOffset {
            throw new Error("not yet implemented");
        }
        public static get Now(): DateTimeOffset {
            throw new Error("not yet implemented");
        }

        private _dateTime: DateTime;
        private _offsetMinutes: number;

        public get DateTime(): DateTime {
            throw new Error("not yet implemented");
        }
        public get UtcDateTime(): DateTime {
            throw new Error("not yet implemented");
        }
        public get LocalDateTime(): DateTime {
            throw new Error("not yet implemented");
        }
        private get ClockDateTime(): DateTime {
            throw new Error("not yet implemented");
        }
        public get Date(): DateTime {
            throw new Error("not yet implemented");
        }
        public get Day(): number {
            throw new Error("not yet implemented");
        }
        public get DayOfWeek(): DayOfWeek {
            throw new Error("not yet implemented");
        }
        public get DayOfYear(): number {
            throw new Error("not yet implemented");
        }
        public get Hour(): number {
            throw new Error("not yet implemented");
        }
        public get Millisecond(): number {
            throw new Error("not yet implemented");
        }
        public get Microsecond(): number {
            throw new Error("not yet implemented");
        }
        public get Nanosecond(): number {
            throw new Error("not yet implemented");
        }
        public get Minute(): number {
            throw new Error("not yet implemented");
        }
        public get Month(): number {
            throw new Error("not yet implemented");
        }
        public get Offset(): TimeSpan {
            throw new Error("not yet implemented");
        }
        public get TotalOffsetMinutes(): number {
            throw new Error("not yet implemented");
        }
        public get Second(): number {
            throw new Error("not yet implemented");
        }
        public get Ticks(): number {
            throw new Error("not yet implemented");
        }
        public get UtcTicks(): number {
            throw new Error("not yet implemented");
        }
        public get TimeOfDay(): TimeSpan {
            throw new Error("not yet implemented");
        }
        public get Year(): number {
            throw new Error("not yet implemented");
        }

        private constructor(validOffsetMinutes: number, validDateTime: DateTime) {
            throw new Error("not yet implemented");
        }
        public constructor(ticks: number, offset: TimeSpan) {
            throw new Error("not yet implemented");
        }
        public constructor(dateTime: DateTime) {
            throw new Error("not yet implemented");
        }
        public constructor(dateTime: DateTime, offset: TimeSpan) {
            throw new Error("not yet implemented");
        }
        public constructor(date: DateOnly, time: TimeOnly, offset: TimeSpan) {
            throw new Error("not yet implemented");
        }
        public constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, offset: TimeSpan) {
            throw new Error("not yet implemented");
        }
        public constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, offset: TimeSpan) {
            throw new Error("not yet implemented");
        }
        public constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, calendar: Calendar, offset: TimeSpan) {
            throw new Error("not yet implemented");
        }
        public constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, microsecond: number, offset: TimeSpan) {
            throw new Error("not yet implemented");
        }
        public constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, microsecond: number, calendar: Calendar, offset: TimeSpan) {
            throw new Error("not yet implemented");
        }
        private constructor(info: SerializationInfo, context: StreamingContext) {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

        public ToOffset(offset: TimeSpan): DateTimeOffset {
            throw new Error("not yet implemented");
        }
        public Add(timeSpan: TimeSpan): DateTimeOffset {
            throw new Error("not yet implemented");
        }
        public AddDays(days: number): DateTimeOffset {
            throw new Error("not yet implemented");
        }
        public AddHours(hours: number): DateTimeOffset {
            throw new Error("not yet implemented");
        }
        public AddMilliseconds(milliseconds: number): DateTimeOffset {
            throw new Error("not yet implemented");
        }
        public AddMicroseconds(microseconds: number): DateTimeOffset {
            throw new Error("not yet implemented");
        }
        public AddMinutes(minutes: number): DateTimeOffset {
            throw new Error("not yet implemented");
        }
        public AddMonths(months: number): DateTimeOffset {
            throw new Error("not yet implemented");
        }
        public AddSeconds(seconds: number): DateTimeOffset {
            throw new Error("not yet implemented");
        }
        public AddTicks(ticks: number): DateTimeOffset {
            throw new Error("not yet implemented");
        }
        public AddYears(years: number): DateTimeOffset {
            throw new Error("not yet implemented");
        }
        public static Compare(first: DateTimeOffset, second: DateTimeOffset): number {
            throw new Error("not yet implemented");
        }
        private __explicit__IComparable_CompareTo(obj: any): number {
            throw new Error("not yet implemented");
        }
        public CompareTo(other: DateTimeOffset): number {
            throw new Error("not yet implemented");
        }
        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public Equals(other: DateTimeOffset): boolean {
            throw new Error("not yet implemented");
        }
        public EqualsExact(other: DateTimeOffset): boolean {
            throw new Error("not yet implemented");
        }
        public static Equals(first: DateTimeOffset, second: DateTimeOffset): boolean {
            throw new Error("not yet implemented");
        }
        public static FromFileTime(fileTime: number): DateTimeOffset {
            throw new Error("not yet implemented");
        }
        public static FromUnixTimeSeconds(seconds: number): DateTimeOffset {
            throw new Error("not yet implemented");
        }
        public static FromUnixTimeMilliseconds(milliseconds: number): DateTimeOffset {
            throw new Error("not yet implemented");
        }
        private __explicit__IDeserializationCallback_OnDeserialization(sender: any) {
            throw new Error("not yet implemented");
        }
        public OnDeserialization(sender: any) {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__ISerializable_GetObjectData(info: SerializationInfo, context: StreamingContext) {
            throw new Error("not yet implemented");
        }
        public GetObjectData(info: SerializationInfo, context: StreamingContext) {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public static Parse(input: string): DateTimeOffset {
            throw new Error("not yet implemented");
        }
        public static Parse(input: string, formatProvider: IFormatProvider): DateTimeOffset {
            throw new Error("not yet implemented");
        }
        public static Parse(input: string, formatProvider: IFormatProvider, styles: DateTimeStyles): DateTimeOffset {
            throw new Error("not yet implemented");
        }
        public static Parse(input: ReadOnlySpan<string>, formatProvider: IFormatProvider, styles: DateTimeStyles): DateTimeOffset {
            throw new Error("not yet implemented");
        }
        public static ParseExact(input: string, format: string, formatProvider: IFormatProvider): DateTimeOffset {
            throw new Error("not yet implemented");
        }
        public static ParseExact(input: string, format: string, formatProvider: IFormatProvider, styles: DateTimeStyles): DateTimeOffset {
            throw new Error("not yet implemented");
        }
        public static ParseExact(input: ReadOnlySpan<string>, format: ReadOnlySpan<string>, formatProvider: IFormatProvider, styles: DateTimeStyles): DateTimeOffset {
            throw new Error("not yet implemented");
        }
        public static ParseExact(input: string, formats: string[], formatProvider: IFormatProvider, styles: DateTimeStyles): DateTimeOffset {
            throw new Error("not yet implemented");
        }
        public static ParseExact(input: ReadOnlySpan<string>, formats: string[], formatProvider: IFormatProvider, styles: DateTimeStyles): DateTimeOffset {
            throw new Error("not yet implemented");
        }
        public Subtract(value: DateTimeOffset): TimeSpan {
            throw new Error("not yet implemented");
        }
        public Subtract(value: TimeSpan): DateTimeOffset {
            throw new Error("not yet implemented");
        }
        public ToFileTime(): number {
            throw new Error("not yet implemented");
        }
        public ToUnixTimeSeconds(): number {
            throw new Error("not yet implemented");
        }
        public ToUnixTimeMilliseconds(): number {
            throw new Error("not yet implemented");
        }
        public ToLocalTime(): DateTimeOffset {
            throw new Error("not yet implemented");
        }
        private ToLocalTime(throwOnOverflow: boolean): DateTimeOffset {
            throw new Error("not yet implemented");
        }
        private static ToLocalTime(utcDateTime: DateTime, throwOnOverflow: boolean): DateTimeOffset {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
        public ToString(format: string): string {
            throw new Error("not yet implemented");
        }
        public ToString(formatProvider: IFormatProvider): string {
            throw new Error("not yet implemented");
        }
        public ToString(format: string, formatProvider: IFormatProvider): string {
            throw new Error("not yet implemented");
        }
        public TryFormat(destination: Span<string>, out charsWritten: number, format: ReadOnlySpan<string>, formatProvider: IFormatProvider): boolean {
            throw new Error("not yet implemented");
        }
        public TryFormat(utf8Destination: Span<number>, out bytesWritten: number, format: ReadOnlySpan<string>, formatProvider: IFormatProvider): boolean {
            throw new Error("not yet implemented");
        }
        public ToUniversalTime(): DateTimeOffset {
            throw new Error("not yet implemented");
        }
        public static TryParse(input: string, out result: DateTimeOffset): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParse(input: ReadOnlySpan<string>, out result: DateTimeOffset): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParse(input: string, formatProvider: IFormatProvider, styles: DateTimeStyles, out result: DateTimeOffset): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParse(input: ReadOnlySpan<string>, formatProvider: IFormatProvider, styles: DateTimeStyles, out result: DateTimeOffset): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParseExact(input: string, format: string, formatProvider: IFormatProvider, styles: DateTimeStyles, out result: DateTimeOffset): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParseExact(input: ReadOnlySpan<string>, format: ReadOnlySpan<string>, formatProvider: IFormatProvider, styles: DateTimeStyles, out result: DateTimeOffset): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParseExact(input: string, formats: string[], formatProvider: IFormatProvider, styles: DateTimeStyles, out result: DateTimeOffset): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParseExact(input: ReadOnlySpan<string>, formats: string[], formatProvider: IFormatProvider, styles: DateTimeStyles, out result: DateTimeOffset): boolean {
            throw new Error("not yet implemented");
        }
        private static ValidateOffset(offset: TimeSpan): number {
            throw new Error("not yet implemented");
        }
        private static ValidateDate(dateTime: DateTime, offset: TimeSpan): DateTime {
            throw new Error("not yet implemented");
        }
        private static ValidateStyles(style: DateTimeStyles, parameterName: string): DateTimeStyles {
            throw new Error("not yet implemented");
        }
        public Deconstruct(out date: DateOnly, out time: TimeOnly, out offset: TimeSpan) {
            throw new Error("not yet implemented");
        }
        public static TryParse(s: string, provider: IFormatProvider, out result: DateTimeOffset): boolean {
            throw new Error("not yet implemented");
        }
        public static Parse(s: ReadOnlySpan<string>, provider: IFormatProvider): DateTimeOffset {
            throw new Error("not yet implemented");
        }
        public static TryParse(s: ReadOnlySpan<string>, provider: IFormatProvider, out result: DateTimeOffset): boolean {
            throw new Error("not yet implemented");
        }
    }
    export class Nullable<T> extends ValueType {
        private hasValue: boolean;
        private value: T;

        public get HasValue(): boolean {
            throw new Error("not yet implemented");
        }
        public get Value(): T {
            throw new Error("not yet implemented");
        }

        public constructor(value: T) {
            throw new Error("not yet implemented");
        }

        public GetValueOrDefault(): T {
            throw new Error("not yet implemented");
        }
        public GetValueOrDefault(defaultValue: T): T {
            throw new Error("not yet implemented");
        }
        public Equals(other: any): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
    }
    export enum TimeZoneInfoOptions {
        None = 0x1,
        NoThrowOnInvalidTime = 0x2,
    }
    export enum TimeZoneInfoResult {
        Success = 0,
        TimeZoneNotFoundException = 1,
        InvalidTimeZoneException = 2,
        SecurityException = 3,
    }
    export class TimeZoneInfo implements IEquatable<TimeZoneInfo>, ISerializable, IDeserializationCallback {
        private static readonly s_utcTimeZone: TimeZoneInfo;
        private static s_cachedData: CachedData;
        private static readonly s_maxDateOnly: DateTime;
        private static readonly s_minDateOnly: DateTime;
        private static readonly MaxOffset: TimeSpan;
        private static readonly MinOffset: TimeSpan;

        public static get Local(): TimeZoneInfo {
            throw new Error("not yet implemented");
        }
        public static get Utc(): TimeZoneInfo {
            throw new Error("not yet implemented");
        }

        private _id: string;
        private _displayName: string;
        private _standardDisplayName: string;
        private _daylightDisplayName: string;
        private _baseUtcOffset: TimeSpan;
        private _supportsDaylightSavingTime: boolean;
        private _adjustmentRules: AdjustmentRule[];
        private _equivalentZones: List<TimeZoneInfo>;
        private __HasIanaId__k__BackingField: boolean;

        public get Id(): string {
            throw new Error("not yet implemented");
        }
        public get HasIanaId(): boolean {
            throw new Error("not yet implemented");
        }
        public get DisplayName(): string {
            throw new Error("not yet implemented");
        }
        public get StandardName(): string {
            throw new Error("not yet implemented");
        }
        public get DaylightName(): string {
            throw new Error("not yet implemented");
        }
        public get BaseUtcOffset(): TimeSpan {
            throw new Error("not yet implemented");
        }
        public get SupportsDaylightSavingTime(): boolean {
            throw new Error("not yet implemented");
        }

        private constructor(id: string, baseUtcOffset: TimeSpan, displayName: string, standardDisplayName: string, daylightDisplayName: string, adjustmentRules: AdjustmentRule[], disableDaylightSavingTime: boolean, hasIanaId: boolean) {
            throw new Error("not yet implemented");
        }
        private constructor(info: SerializationInfo, context: StreamingContext) {
            throw new Error("not yet implemented");
        }
        private constructor(zone: TIME_ZONE_INFORMATION, dstDisabled: boolean) {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

        public GetAmbiguousTimeOffsets(dateTimeOffset: DateTimeOffset): TimeSpan[] {
            throw new Error("not yet implemented");
        }
        public GetAmbiguousTimeOffsets(dateTime: DateTime): TimeSpan[] {
            throw new Error("not yet implemented");
        }
        private GetAdjustmentRuleForAmbiguousOffsets(adjustedTime: DateTime, out ruleIndex: Nullable<number>): AdjustmentRule {
            throw new Error("not yet implemented");
        }
        private GetPreviousAdjustmentRule(rule: AdjustmentRule, ruleIndex: Nullable<number>): AdjustmentRule {
            throw new Error("not yet implemented");
        }
        public GetUtcOffset(dateTimeOffset: DateTimeOffset): TimeSpan {
            throw new Error("not yet implemented");
        }
        public GetUtcOffset(dateTime: DateTime): TimeSpan {
            throw new Error("not yet implemented");
        }
        private static GetLocalUtcOffset(dateTime: DateTime, flags: TimeZoneInfoOptions): TimeSpan {
            throw new Error("not yet implemented");
        }
        private GetUtcOffset(dateTime: DateTime, flags: TimeZoneInfoOptions): TimeSpan {
            throw new Error("not yet implemented");
        }
        private GetUtcOffset(dateTime: DateTime, flags: TimeZoneInfoOptions, cachedData: CachedData): TimeSpan {
            throw new Error("not yet implemented");
        }
        public IsAmbiguousTime(dateTimeOffset: DateTimeOffset): boolean {
            throw new Error("not yet implemented");
        }
        public IsAmbiguousTime(dateTime: DateTime): boolean {
            throw new Error("not yet implemented");
        }
        private IsAmbiguousTime(dateTime: DateTime, flags: TimeZoneInfoOptions): boolean {
            throw new Error("not yet implemented");
        }
        public IsDaylightSavingTime(dateTimeOffset: DateTimeOffset): boolean {
            throw new Error("not yet implemented");
        }
        public IsDaylightSavingTime(dateTime: DateTime): boolean {
            throw new Error("not yet implemented");
        }
        private IsDaylightSavingTime(dateTime: DateTime, flags: TimeZoneInfoOptions): boolean {
            throw new Error("not yet implemented");
        }
        private IsDaylightSavingTime(dateTime: DateTime, flags: TimeZoneInfoOptions, cachedData: CachedData): boolean {
            throw new Error("not yet implemented");
        }
        public IsInvalidTime(dateTime: DateTime): boolean {
            throw new Error("not yet implemented");
        }
        public static ClearCachedData() {
            throw new Error("not yet implemented");
        }
        public static ConvertTimeBySystemTimeZoneId(dateTimeOffset: DateTimeOffset, destinationTimeZoneId: string): DateTimeOffset {
            throw new Error("not yet implemented");
        }
        public static ConvertTimeBySystemTimeZoneId(dateTime: DateTime, destinationTimeZoneId: string): DateTime {
            throw new Error("not yet implemented");
        }
        public static FindSystemTimeZoneById(id: string): TimeZoneInfo {
            throw new Error("not yet implemented");
        }
        public static TryFindSystemTimeZoneById(id: string, out timeZoneInfo: TimeZoneInfo): boolean {
            throw new Error("not yet implemented");
        }
        private static TryFindSystemTimeZoneById(id: string, out timeZone: TimeZoneInfo, out e: Exception): TimeZoneInfoResult {
            throw new Error("not yet implemented");
        }
        public static ConvertTimeBySystemTimeZoneId(dateTime: DateTime, sourceTimeZoneId: string, destinationTimeZoneId: string): DateTime {
            throw new Error("not yet implemented");
        }
        public static ConvertTime(dateTimeOffset: DateTimeOffset, destinationTimeZone: TimeZoneInfo): DateTimeOffset {
            throw new Error("not yet implemented");
        }
        public static ConvertTime(dateTime: DateTime, destinationTimeZone: TimeZoneInfo): DateTime {
            throw new Error("not yet implemented");
        }
        public static ConvertTime(dateTime: DateTime, sourceTimeZone: TimeZoneInfo, destinationTimeZone: TimeZoneInfo): DateTime {
            throw new Error("not yet implemented");
        }
        private static ConvertTime(dateTime: DateTime, sourceTimeZone: TimeZoneInfo, destinationTimeZone: TimeZoneInfo, flags: TimeZoneInfoOptions): DateTime {
            throw new Error("not yet implemented");
        }
        private static ConvertTime(dateTime: DateTime, sourceTimeZone: TimeZoneInfo, destinationTimeZone: TimeZoneInfo, flags: TimeZoneInfoOptions, cachedData: CachedData): DateTime {
            throw new Error("not yet implemented");
        }
        public static ConvertTimeFromUtc(dateTime: DateTime, destinationTimeZone: TimeZoneInfo): DateTime {
            throw new Error("not yet implemented");
        }
        public static ConvertTimeToUtc(dateTime: DateTime): DateTime {
            throw new Error("not yet implemented");
        }
        private static ConvertTimeToUtc(dateTime: DateTime, flags: TimeZoneInfoOptions): DateTime {
            throw new Error("not yet implemented");
        }
        public static ConvertTimeToUtc(dateTime: DateTime, sourceTimeZone: TimeZoneInfo): DateTime {
            throw new Error("not yet implemented");
        }
        public Equals(other: TimeZoneInfo): boolean {
            throw new Error("not yet implemented");
        }
        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public static FromSerializedString(source: string): TimeZoneInfo {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public static GetSystemTimeZones(): ReadOnlyCollection<TimeZoneInfo> {
            throw new Error("not yet implemented");
        }
        public static GetSystemTimeZones(skipSorting: boolean): ReadOnlyCollection<TimeZoneInfo> {
            throw new Error("not yet implemented");
        }
        public HasSameRules(other: TimeZoneInfo): boolean {
            throw new Error("not yet implemented");
        }
        public ToSerializedString(): string {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
        public static CreateCustomTimeZone(id: string, baseUtcOffset: TimeSpan, displayName: string, standardDisplayName: string): TimeZoneInfo {
            throw new Error("not yet implemented");
        }
        public static CreateCustomTimeZone(id: string, baseUtcOffset: TimeSpan, displayName: string, standardDisplayName: string, daylightDisplayName: string, adjustmentRules: AdjustmentRule[]): TimeZoneInfo {
            throw new Error("not yet implemented");
        }
        public static CreateCustomTimeZone(id: string, baseUtcOffset: TimeSpan, displayName: string, standardDisplayName: string, daylightDisplayName: string, adjustmentRules: AdjustmentRule[], disableDaylightSavingTime: boolean): TimeZoneInfo {
            throw new Error("not yet implemented");
        }
        public static TryConvertIanaIdToWindowsId(ianaId: string, out windowsId: string): boolean {
            throw new Error("not yet implemented");
        }
        public static TryConvertWindowsIdToIanaId(windowsId: string, out ianaId: string): boolean {
            throw new Error("not yet implemented");
        }
        public static TryConvertWindowsIdToIanaId(windowsId: string, region: string, out ianaId: string): boolean {
            throw new Error("not yet implemented");
        }
        private __explicit__IDeserializationCallback_OnDeserialization(sender: any) {
            throw new Error("not yet implemented");
        }
        public OnDeserialization(sender: any) {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__ISerializable_GetObjectData(info: SerializationInfo, context: StreamingContext) {
            throw new Error("not yet implemented");
        }
        public GetObjectData(info: SerializationInfo, context: StreamingContext) {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private GetAdjustmentRuleForTime(dateTime: DateTime, out ruleIndex: Nullable<number>): AdjustmentRule {
            throw new Error("not yet implemented");
        }
        private GetAdjustmentRuleForTime(dateTime: DateTime, dateTimeisUtc: boolean, out ruleIndex: Nullable<number>): AdjustmentRule {
            throw new Error("not yet implemented");
        }
        private CompareAdjustmentRuleToDateTime(rule: AdjustmentRule, previousRule: AdjustmentRule, dateTime: DateTime, dateOnly: DateTime, dateTimeisUtc: boolean): number {
            throw new Error("not yet implemented");
        }
        private ConvertToUtc(dateTime: DateTime, daylightDelta: TimeSpan, baseUtcOffsetDelta: TimeSpan): DateTime {
            throw new Error("not yet implemented");
        }
        private ConvertFromUtc(dateTime: DateTime, daylightDelta: TimeSpan, baseUtcOffsetDelta: TimeSpan): DateTime {
            throw new Error("not yet implemented");
        }
        private ConvertToFromUtc(dateTime: DateTime, daylightDelta: TimeSpan, baseUtcOffsetDelta: TimeSpan, convertToUtc: boolean): DateTime {
            throw new Error("not yet implemented");
        }
        private static ConvertUtcToTimeZone(ticks: number, destinationTimeZone: TimeZoneInfo, out isAmbiguousLocalDst: boolean): DateTime {
            throw new Error("not yet implemented");
        }
        private GetDaylightTime(year: number, rule: AdjustmentRule, ruleIndex: Nullable<number>): DaylightTimeStruct {
            throw new Error("not yet implemented");
        }
        private static GetIsDaylightSavings(time: DateTime, rule: AdjustmentRule, daylightTime: DaylightTimeStruct): boolean {
            throw new Error("not yet implemented");
        }
        private GetDaylightSavingsStartOffsetFromUtc(baseUtcOffset: TimeSpan, rule: AdjustmentRule, ruleIndex: Nullable<number>): TimeSpan {
            throw new Error("not yet implemented");
        }
        private static GetDaylightSavingsEndOffsetFromUtc(baseUtcOffset: TimeSpan, rule: AdjustmentRule): TimeSpan {
            throw new Error("not yet implemented");
        }
        private static GetIsDaylightSavingsFromUtc(time: DateTime, year: number, utc: TimeSpan, rule: AdjustmentRule, ruleIndex: Nullable<number>, out isAmbiguousLocalDst: boolean, zone: TimeZoneInfo): boolean {
            throw new Error("not yet implemented");
        }
        private static TryGetEndOfDstIfYearStartWithDst(nextYear: number, utc: TimeSpan, zone: TimeZoneInfo, out dstEnd: DateTime): boolean {
            throw new Error("not yet implemented");
        }
        private static TryGetStartOfDstIfYearEndWithDst(previousYear: number, utc: TimeSpan, zone: TimeZoneInfo, out dstStart: DateTime): boolean {
            throw new Error("not yet implemented");
        }
        private static CheckIsDst(startTime: DateTime, time: DateTime, endTime: DateTime, ignoreYearAdjustment: boolean, rule: AdjustmentRule): boolean {
            throw new Error("not yet implemented");
        }
        private static GetIsAmbiguousTime(time: DateTime, rule: AdjustmentRule, daylightTime: DaylightTimeStruct): boolean {
            throw new Error("not yet implemented");
        }
        private static GetIsInvalidTime(time: DateTime, rule: AdjustmentRule, daylightTime: DaylightTimeStruct): boolean {
            throw new Error("not yet implemented");
        }
        private static GetUtcOffset(time: DateTime, zone: TimeZoneInfo): TimeSpan {
            throw new Error("not yet implemented");
        }
        private static GetUtcOffsetFromUtc(time: DateTime, zone: TimeZoneInfo): TimeSpan {
            throw new Error("not yet implemented");
        }
        private static GetUtcOffsetFromUtc(time: DateTime, zone: TimeZoneInfo, out isDaylightSavings: boolean): TimeSpan {
            throw new Error("not yet implemented");
        }
        private static GetUtcOffsetFromUtc(time: DateTime, zone: TimeZoneInfo, out isDaylightSavings: boolean, out isAmbiguousLocalDst: boolean): TimeSpan {
            throw new Error("not yet implemented");
        }
        private static TransitionTimeToDateTime(year: number, transitionTime: TransitionTime): DateTime {
            throw new Error("not yet implemented");
        }
        private static TryGetTimeZone(id: string, dstDisabled: boolean, out value: TimeZoneInfo, out e: Exception, cachedData: CachedData, alwaysFallbackToLocalMachine: boolean): TimeZoneInfoResult {
            throw new Error("not yet implemented");
        }
        private static TryGetTimeZoneUsingId(id: string, dstDisabled: boolean, out value: TimeZoneInfo, out e: Exception, cachedData: CachedData, alwaysFallbackToLocalMachine: boolean): TimeZoneInfoResult {
            throw new Error("not yet implemented");
        }
        private static TryGetTimeZoneFromLocalMachine(id: string, dstDisabled: boolean, out value: TimeZoneInfo, out e: Exception, cachedData: CachedData): TimeZoneInfoResult {
            throw new Error("not yet implemented");
        }
        private static ValidateTimeZoneInfo(id: string, baseUtcOffset: TimeSpan, adjustmentRules: AdjustmentRule[], out adjustmentRulesSupportDst: boolean) {
            throw new Error("not yet implemented");
        }
        private static UtcOffsetOutOfRange(offset: TimeSpan): boolean {
            throw new Error("not yet implemented");
        }
        private static GetUtcOffset(baseUtcOffset: TimeSpan, adjustmentRule: AdjustmentRule): TimeSpan {
            throw new Error("not yet implemented");
        }
        private static IsValidAdjustmentRuleOffset(baseUtcOffset: TimeSpan, adjustmentRule: AdjustmentRule): boolean {
            throw new Error("not yet implemented");
        }
        private static CreateUtcTimeZone(): TimeZoneInfo {
            throw new Error("not yet implemented");
        }
        private static TryConvertIanaIdToWindowsId(ianaId: string, allocate: boolean, out windowsId: string): boolean {
            throw new Error("not yet implemented");
        }
        private static TryConvertWindowsIdToIanaId(windowsId: string, region: string, allocate: boolean, out ianaId: string): boolean {
            throw new Error("not yet implemented");
        }
        public GetAdjustmentRules(): AdjustmentRule[] {
            throw new Error("not yet implemented");
        }
        private static PopulateAllSystemTimeZones(cachedData: CachedData) {
            throw new Error("not yet implemented");
        }
        private static GetAlternativeId(id: string, out idIsIana: boolean): string {
            throw new Error("not yet implemented");
        }
        private static CheckDaylightSavingTimeNotSupported(ref timeZone: TIME_ZONE_INFORMATION): boolean {
            throw new Error("not yet implemented");
        }
        private static CreateAdjustmentRuleFromTimeZoneInformation(ref timeZoneInformation: REG_TZI_FORMAT, startDate: DateTime, endDate: DateTime, defaultBaseUtcOffset: number): AdjustmentRule {
            throw new Error("not yet implemented");
        }
        private static FindIdFromTimeZoneInformation(ref timeZone: TIME_ZONE_INFORMATION, out dstDisabled: boolean): string {
            throw new Error("not yet implemented");
        }
        private static GetLocalTimeZone(cachedData: CachedData): TimeZoneInfo {
            throw new Error("not yet implemented");
        }
        private static GetLocalTimeZoneFromWin32Data(ref timeZoneInformation: TIME_ZONE_INFORMATION, dstDisabled: boolean): TimeZoneInfo {
            throw new Error("not yet implemented");
        }
        private static TryGetTimeZone(id: string, out timeZone: TimeZoneInfo, out e: Exception, cachedData: CachedData): TimeZoneInfoResult {
            throw new Error("not yet implemented");
        }
        private static GetDateTimeNowUtcOffsetFromUtc(time: DateTime, out isAmbiguousLocalDst: boolean): TimeSpan {
            throw new Error("not yet implemented");
        }
        private static TransitionTimeFromTimeZoneInformation(ref timeZoneInformation: REG_TZI_FORMAT, out transitionTime: TransitionTime, readStartDate: boolean): boolean {
            throw new Error("not yet implemented");
        }
        private static TryCreateAdjustmentRules(id: string, ref defaultTimeZoneInformation: REG_TZI_FORMAT, out rules: AdjustmentRule[], out e: Exception, defaultBaseUtcOffset: number): boolean {
            throw new Error("not yet implemented");
        }
        private static TryGetTimeZoneEntryFromRegistry(key: RegistryKey, name: string, out dtzi: REG_TZI_FORMAT): boolean {
            throw new Error("not yet implemented");
        }
        private static TryCompareStandardDate(ref timeZone: TIME_ZONE_INFORMATION, ref registryTimeZoneInfo: REG_TZI_FORMAT): boolean {
            throw new Error("not yet implemented");
        }
        private static TryCompareTimeZoneInformationToRegistry(ref timeZone: TIME_ZONE_INFORMATION, id: string, out dstDisabled: boolean): boolean {
            throw new Error("not yet implemented");
        }
        private static GetLocalizedNameByMuiNativeResource(resource: string): string {
            throw new Error("not yet implemented");
        }
        private static GetLocalizedNameByNativeResource(filePath: string, resource: number): string {
            throw new Error("not yet implemented");
        }
        private static GetLocalizedNamesByRegistryKey(key: RegistryKey, out displayName: string, out standardName: string, out daylightName: string) {
            throw new Error("not yet implemented");
        }
        private static TryGetTimeZoneFromLocalMachine(id: string, out value: TimeZoneInfo, out e: Exception): TimeZoneInfoResult {
            throw new Error("not yet implemented");
        }
        private static GetUtcStandardDisplayName(): string {
            throw new Error("not yet implemented");
        }
        private static GetUtcFullDisplayName(_: string, standardDisplayName: string): string {
            throw new Error("not yet implemented");
        }
    }
    export namespace TimeZoneInfo {
        export class AdjustmentRule implements IEquatable<AdjustmentRule>, ISerializable, IDeserializationCallback {
            private static readonly DaylightDeltaAdjustment: TimeSpan;
            private static readonly MaxDaylightDelta: TimeSpan;

            private _dateStart: DateTime;
            private _dateEnd: DateTime;
            private _daylightDelta: TimeSpan;
            private _daylightTransitionStart: TransitionTime;
            private _daylightTransitionEnd: TransitionTime;
            private _baseUtcOffsetDelta: TimeSpan;
            private _noDaylightTransitions: boolean;

            public get DateStart(): DateTime {
                throw new Error("not yet implemented");
            }
            public get DateEnd(): DateTime {
                throw new Error("not yet implemented");
            }
            public get DaylightDelta(): TimeSpan {
                throw new Error("not yet implemented");
            }
            public get DaylightTransitionStart(): TransitionTime {
                throw new Error("not yet implemented");
            }
            public get DaylightTransitionEnd(): TransitionTime {
                throw new Error("not yet implemented");
            }
            public get BaseUtcOffsetDelta(): TimeSpan {
                throw new Error("not yet implemented");
            }
            private get NoDaylightTransitions(): boolean {
                throw new Error("not yet implemented");
            }
            private get HasDaylightSaving(): boolean {
                throw new Error("not yet implemented");
            }

            private constructor(dateStart: DateTime, dateEnd: DateTime, daylightDelta: TimeSpan, daylightTransitionStart: TransitionTime, daylightTransitionEnd: TransitionTime, baseUtcOffsetDelta: TimeSpan, noDaylightTransitions: boolean) {
                throw new Error("not yet implemented");
            }
            private constructor(info: SerializationInfo, context: StreamingContext) {
                throw new Error("not yet implemented");
            }
            private static staticctor_initialize = (() => {
                throw new Error("not yet implemented");
            })();
            private constructor() { }

            public Equals(other: AdjustmentRule): boolean {
                throw new Error("not yet implemented");
            }
            public Equals(obj: any): boolean {
                throw new Error("not yet implemented");
            }
            public GetHashCode(): number {
                throw new Error("not yet implemented");
            }
            public static CreateAdjustmentRule(dateStart: DateTime, dateEnd: DateTime, daylightDelta: TimeSpan, daylightTransitionStart: TransitionTime, daylightTransitionEnd: TransitionTime, baseUtcOffsetDelta: TimeSpan): AdjustmentRule {
                throw new Error("not yet implemented");
            }
            public static CreateAdjustmentRule(dateStart: DateTime, dateEnd: DateTime, daylightDelta: TimeSpan, daylightTransitionStart: TransitionTime, daylightTransitionEnd: TransitionTime): AdjustmentRule {
                throw new Error("not yet implemented");
            }
            private static CreateAdjustmentRule(dateStart: DateTime, dateEnd: DateTime, daylightDelta: TimeSpan, daylightTransitionStart: TransitionTime, daylightTransitionEnd: TransitionTime, baseUtcOffsetDelta: TimeSpan, noDaylightTransitions: boolean): AdjustmentRule {
                throw new Error("not yet implemented");
            }
            private IsStartDateMarkerForBeginningOfYear(): boolean {
                throw new Error("not yet implemented");
            }
            private IsEndDateMarkerForEndOfYear(): boolean {
                throw new Error("not yet implemented");
            }
            private static ValidateAdjustmentRule(dateStart: DateTime, dateEnd: DateTime, daylightDelta: TimeSpan, daylightTransitionStart: TransitionTime, daylightTransitionEnd: TransitionTime, noDaylightTransitions: boolean) {
                throw new Error("not yet implemented");
            }
            private static AdjustDaylightDeltaToExpectedRange(ref daylightDelta: TimeSpan, ref baseUtcOffsetDelta: TimeSpan) {
                throw new Error("not yet implemented");
            }
            private __explicit__IDeserializationCallback_OnDeserialization(sender: any) {
                throw new Error("not yet implemented");
            }
            public OnDeserialization(sender: any) {
                throw new Error("Invalid call (use ExplicitAs property)");
            }
            private __explicit__ISerializable_GetObjectData(info: SerializationInfo, context: StreamingContext) {
                throw new Error("not yet implemented");
            }
            public GetObjectData(info: SerializationInfo, context: StreamingContext) {
                throw new Error("Invalid call (use ExplicitAs property)");
            }
        }

        export enum TimeZoneInfoResult {
            Success = 0,
            TimeZoneNotFoundException = 1,
            InvalidTimeZoneException = 2,
            SecurityException = 3,
        }

        export class CachedData {
            private _localTimeZone: TimeZoneInfo;
            public _systemTimeZones: Dictionary<string, TimeZoneInfo>;
            public _readOnlySystemTimeZones: ReadOnlyCollection<TimeZoneInfo>;
            public _readOnlyUnsortedSystemTimeZones: ReadOnlyCollection<TimeZoneInfo>;
            public _timeZonesUsingAlternativeIds: Dictionary<string, TimeZoneInfo>;
            public _allSystemTimeZonesRead: boolean;
            private _oneYearLocalFromUtc: OffsetAndRule;

            public get Local(): TimeZoneInfo {
                throw new Error("not yet implemented");
            }

            public constructor() {
                throw new Error("not yet implemented");
            }

            private CreateLocal(): TimeZoneInfo {
                throw new Error("not yet implemented");
            }
            public GetCorrespondingKind(timeZone: TimeZoneInfo): DateTimeKind {
                throw new Error("not yet implemented");
            }
            private static GetCurrentOneYearLocal(): TimeZoneInfo {
                throw new Error("not yet implemented");
            }
            public GetOneYearLocalFromUtc(year: number): OffsetAndRule {
                throw new Error("not yet implemented");
            }
        }

        export class StringSerializer extends ValueType {
            private _serializedText: string;
            private _currentTokenStartIndex: number;
            private _state: State;

            private constructor(str: string) {
                throw new Error("not yet implemented");
            }

            public static GetSerializedString(zone: TimeZoneInfo): string {
                throw new Error("not yet implemented");
            }
            public static GetDeserializedTimeZoneInfo(source: string): TimeZoneInfo {
                throw new Error("not yet implemented");
            }
            private static SerializeSubstitute(text: string, ref serializedText: ValueStringBuilder) {
                throw new Error("not yet implemented");
            }
            private static SerializeTransitionTime(time: TransitionTime, ref serializedText: ValueStringBuilder) {
                throw new Error("not yet implemented");
            }
            private static VerifyIsEscapableCharacter(c: string) {
                throw new Error("not yet implemented");
            }
            private SkipVersionNextDataFields(depth: number) {
                throw new Error("not yet implemented");
            }
            private GetNextStringValue(): string {
                throw new Error("not yet implemented");
            }
            private GetNextDateTimeValue(format: string): DateTime {
                throw new Error("not yet implemented");
            }
            private GetNextTimeSpanValue(): TimeSpan {
                throw new Error("not yet implemented");
            }
            private GetNextInt32Value(): number {
                throw new Error("not yet implemented");
            }
            private GetNextAdjustmentRuleArrayValue(): AdjustmentRule[] {
                throw new Error("not yet implemented");
            }
            private GetNextAdjustmentRuleValue(): AdjustmentRule {
                throw new Error("not yet implemented");
            }
            private GetNextTransitionTimeValue(): TransitionTime {
                throw new Error("not yet implemented");
            }
        }
        export namespace StringSerializer {
            export enum State {
                Escaped = 0,
                NotEscaped = 1,
                StartOfToken = 2,
                EndOfLine = 3,
            }
        }

        export class TransitionTime extends ValueType implements IEquatable<TransitionTime>, ISerializable, IDeserializationCallback {
            private _timeOfDay: DateTime;
            private _month: number;
            private _week: number;
            private _day: number;
            private _dayOfWeek: DayOfWeek;
            private _isFixedDateRule: boolean;

            public get TimeOfDay(): DateTime {
                throw new Error("not yet implemented");
            }
            public get Month(): number {
                throw new Error("not yet implemented");
            }
            public get Week(): number {
                throw new Error("not yet implemented");
            }
            public get Day(): number {
                throw new Error("not yet implemented");
            }
            public get DayOfWeek(): DayOfWeek {
                throw new Error("not yet implemented");
            }
            public get IsFixedDateRule(): boolean {
                throw new Error("not yet implemented");
            }

            private constructor(timeOfDay: DateTime, month: number, week: number, day: number, dayOfWeek: DayOfWeek, isFixedDateRule: boolean) {
                throw new Error("not yet implemented");
            }
            private constructor(info: SerializationInfo, context: StreamingContext) {
                throw new Error("not yet implemented");
            }

            public Equals(obj: any): boolean {
                throw new Error("not yet implemented");
            }
            public Equals(other: TransitionTime): boolean {
                throw new Error("not yet implemented");
            }
            public GetHashCode(): number {
                throw new Error("not yet implemented");
            }
            public static CreateFixedDateRule(timeOfDay: DateTime, month: number, day: number): TransitionTime {
                throw new Error("not yet implemented");
            }
            public static CreateFloatingDateRule(timeOfDay: DateTime, month: number, week: number, dayOfWeek: DayOfWeek): TransitionTime {
                throw new Error("not yet implemented");
            }
            private static ValidateTransitionTime(timeOfDay: DateTime, month: number, week: number, day: number, dayOfWeek: DayOfWeek) {
                throw new Error("not yet implemented");
            }
            private __explicit__IDeserializationCallback_OnDeserialization(sender: any) {
                throw new Error("not yet implemented");
            }
            public OnDeserialization(sender: any) {
                throw new Error("Invalid call (use ExplicitAs property)");
            }
            private __explicit__ISerializable_GetObjectData(info: SerializationInfo, context: StreamingContext) {
                throw new Error("not yet implemented");
            }
            public GetObjectData(info: SerializationInfo, context: StreamingContext) {
                throw new Error("Invalid call (use ExplicitAs property)");
            }
        }

        export class OffsetAndRule {
            public Year: number;
            public Offset: TimeSpan;
            public Rule: AdjustmentRule;

            public constructor(year: number, offset: TimeSpan, rule: AdjustmentRule) {
                throw new Error("not yet implemented");
            }

        }

        export class ____c {
            public static readonly ____9: ____c;
            public static ____9__71_0: Comparison<TimeZoneInfo>;

            private static staticctor_initialize = (() => {
                throw new Error("not yet implemented");
            })();
            private constructor() { }
            public constructor() {
                throw new Error("not yet implemented");
            }

            private __GetSystemTimeZones__b__71_0(x: TimeZoneInfo, y: TimeZoneInfo): number {
                throw new Error("not yet implemented");
            }
        }
    }
    export abstract class TimeProvider {
        private static readonly __System__k__BackingField: TimeProvider;
        private static readonly s_minDateTicks: number;
        private static readonly s_maxDateTicks: number;

        public static get System(): TimeProvider {
            throw new Error("not yet implemented");
        }

        public get LocalTimeZone(): TimeZoneInfo {
            throw new Error("not yet implemented");
        }
        public get TimestampFrequency(): number {
            throw new Error("not yet implemented");
        }

        protected constructor() {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

        public GetUtcNow(): DateTimeOffset {
            throw new Error("not yet implemented");
        }
        public GetLocalNow(): DateTimeOffset {
            throw new Error("not yet implemented");
        }
        public GetTimestamp(): number {
            throw new Error("not yet implemented");
        }
        public GetElapsedTime(startingTimestamp: number, endingTimestamp: number): TimeSpan {
            throw new Error("not yet implemented");
        }
        public GetElapsedTime(startingTimestamp: number): TimeSpan {
            throw new Error("not yet implemented");
        }
        public CreateTimer(callback: TimerCallback, state: any, dueTime: TimeSpan, period: TimeSpan): ITimer {
            throw new Error("not yet implemented");
        }
    }
    export namespace TimeProvider {
        export class SystemTimeProviderTimer implements ITimer, IDisposable, IAsyncDisposable {
            private _timer: TimerQueueTimer;

            public constructor(dueTime: TimeSpan, period: TimeSpan, callback: TimerCallback, state: any) {
                throw new Error("not yet implemented");
            }

            public Change(dueTime: TimeSpan, period: TimeSpan): boolean {
                throw new Error("not yet implemented");
            }
            public Dispose() {
                throw new Error("not yet implemented");
            }
            public DisposeAsync(): ValueTask {
                throw new Error("not yet implemented");
            }
        }

        export class SystemTimeProvider extends TimeProvider {
            protected constructor() {
                throw new Error("not yet implemented");
            }

        }
    }
    export class Action extends MulticastDelegate implements ICloneable, ISerializable {
        public constructor(object: any, method: number) {
            throw new Error("not yet implemented");
        }

        public Invoke() {
            throw new Error("not yet implemented");
        }
        public BeginInvoke(callback: AsyncCallback, object: any): IAsyncResult {
            throw new Error("not yet implemented");
        }
        public EndInvoke(result: IAsyncResult) {
            throw new Error("not yet implemented");
        }
    }
    export class Func<T1, T2, TResult> extends MulticastDelegate implements ICloneable, ISerializable {
        public constructor(object: any, method: number) {
            throw new Error("not yet implemented");
        }

        public Invoke(arg1: T1, arg2: T2): TResult {
            throw new Error("not yet implemented");
        }
        public BeginInvoke(arg1: T1, arg2: T2, callback: AsyncCallback, object: any): IAsyncResult {
            throw new Error("not yet implemented");
        }
        public EndInvoke(result: IAsyncResult): TResult {
            throw new Error("not yet implemented");
        }
    }
    export class Func<T1, T2, T3, TResult> extends MulticastDelegate implements ICloneable, ISerializable {
        public constructor(object: any, method: number) {
            throw new Error("not yet implemented");
        }

        public Invoke(arg1: T1, arg2: T2, arg3: T3): TResult {
            throw new Error("not yet implemented");
        }
        public BeginInvoke(arg1: T1, arg2: T2, arg3: T3, callback: AsyncCallback, object: any): IAsyncResult {
            throw new Error("not yet implemented");
        }
        public EndInvoke(result: IAsyncResult): TResult {
            throw new Error("not yet implemented");
        }
    }
    export class Func<T1, T2, T3, T4, TResult> extends MulticastDelegate implements ICloneable, ISerializable {
        public constructor(object: any, method: number) {
            throw new Error("not yet implemented");
        }

        public Invoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4): TResult {
            throw new Error("not yet implemented");
        }
        public BeginInvoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, callback: AsyncCallback, object: any): IAsyncResult {
            throw new Error("not yet implemented");
        }
        public EndInvoke(result: IAsyncResult): TResult {
            throw new Error("not yet implemented");
        }
    }
    export class Func<T1, T2, T3, T4, T5, TResult> extends MulticastDelegate implements ICloneable, ISerializable {
        public constructor(object: any, method: number) {
            throw new Error("not yet implemented");
        }

        public Invoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): TResult {
            throw new Error("not yet implemented");
        }
        public BeginInvoke(arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, callback: AsyncCallback, object: any): IAsyncResult {
            throw new Error("not yet implemented");
        }
        public EndInvoke(result: IAsyncResult): TResult {
            throw new Error("not yet implemented");
        }
    }
    export class AssemblyLoadEventArgs extends EventArgs {
        private __LoadedAssembly__k__BackingField: Assembly;

        public get LoadedAssembly(): Assembly {
            throw new Error("not yet implemented");
        }

        public constructor(loadedAssembly: Assembly) {
            throw new Error("not yet implemented");
        }

    }
    export class AssemblyLoadEventHandler extends MulticastDelegate implements ICloneable, ISerializable {
        public constructor(object: any, method: number) {
            throw new Error("not yet implemented");
        }

        public Invoke(sender: any, args: AssemblyLoadEventArgs) {
            throw new Error("not yet implemented");
        }
        public BeginInvoke(sender: any, args: AssemblyLoadEventArgs, callback: AsyncCallback, object: any): IAsyncResult {
            throw new Error("not yet implemented");
        }
        public EndInvoke(result: IAsyncResult) {
            throw new Error("not yet implemented");
        }
    }
    export class AppDomain extends MarshalByRefObject {
        private static readonly s_domain: AppDomain;

        public static get CurrentDomain(): AppDomain {
            throw new Error("not yet implemented");
        }
        public static get MonitoringIsEnabled(): boolean {
            throw new Error("not yet implemented");
        }
        public static set MonitoringIsEnabled(value: boolean) {
            throw new Error("not yet implemented");
        }
        public static get MonitoringSurvivedProcessMemorySize(): number {
            throw new Error("not yet implemented");
        }

        private _defaultPrincipal: IPrincipal;
        private _principalPolicy: PrincipalPolicy;
        private s_getWindowsPrincipal: Func<IPrincipal>;
        private s_getUnauthenticatedPrincipal: Func<IPrincipal>;
        private DomainUnload: EventHandler;
        private ReflectionOnlyAssemblyResolve: ResolveEventHandler;

        public get BaseDirectory(): string {
            throw new Error("not yet implemented");
        }
        public get RelativeSearchPath(): string {
            throw new Error("not yet implemented");
        }
        public get SetupInformation(): AppDomainSetup {
            throw new Error("not yet implemented");
        }
        public get PermissionSet(): PermissionSet {
            throw new Error("not yet implemented");
        }
        public get DynamicDirectory(): string {
            throw new Error("not yet implemented");
        }
        public get FriendlyName(): string {
            throw new Error("not yet implemented");
        }
        public get Id(): number {
            throw new Error("not yet implemented");
        }
        public get IsFullyTrusted(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsHomogenous(): boolean {
            throw new Error("not yet implemented");
        }
        public get MonitoringSurvivedMemorySize(): number {
            throw new Error("not yet implemented");
        }
        public get MonitoringTotalAllocatedMemorySize(): number {
            throw new Error("not yet implemented");
        }
        public get ShadowCopyFiles(): boolean {
            throw new Error("not yet implemented");
        }
        public get MonitoringTotalProcessorTime(): TimeSpan {
            throw new Error("not yet implemented");
        }

        private constructor() {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

        public SetDynamicBase(path: string) {
            throw new Error("not yet implemented");
        }
        public ApplyPolicy(assemblyName: string): string {
            throw new Error("not yet implemented");
        }
        public static CreateDomain(friendlyName: string): AppDomain {
            throw new Error("not yet implemented");
        }
        public ExecuteAssembly(assemblyFile: string): number {
            throw new Error("not yet implemented");
        }
        public ExecuteAssembly(assemblyFile: string, args: string[]): number {
            throw new Error("not yet implemented");
        }
        public ExecuteAssembly(assemblyFile: string, args: string[], hashValue: number[], hashAlgorithm: AssemblyHashAlgorithm): number {
            throw new Error("not yet implemented");
        }
        private static ExecuteAssembly(assembly: Assembly, args: string[]): number {
            throw new Error("not yet implemented");
        }
        public ExecuteAssemblyByName(assemblyName: AssemblyName, args: string[]): number {
            throw new Error("not yet implemented");
        }
        public ExecuteAssemblyByName(assemblyName: string): number {
            throw new Error("not yet implemented");
        }
        public ExecuteAssemblyByName(assemblyName: string, args: string[]): number {
            throw new Error("not yet implemented");
        }
        public GetData(name: string): any {
            throw new Error("not yet implemented");
        }
        public SetData(name: string, data: any) {
            throw new Error("not yet implemented");
        }
        public IsCompatibilitySwitchSet(value: string): Nullable<boolean> {
            throw new Error("not yet implemented");
        }
        public IsDefaultAppDomain(): boolean {
            throw new Error("not yet implemented");
        }
        public IsFinalizingForUnload(): boolean {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
        public static Unload(domain: AppDomain) {
            throw new Error("not yet implemented");
        }
        public Load(rawAssembly: number[]): Assembly {
            throw new Error("not yet implemented");
        }
        public Load(rawAssembly: number[], rawSymbolStore: number[]): Assembly {
            throw new Error("not yet implemented");
        }
        public Load(assemblyRef: AssemblyName): Assembly {
            throw new Error("not yet implemented");
        }
        public Load(assemblyString: string): Assembly {
            throw new Error("not yet implemented");
        }
        public ReflectionOnlyGetAssemblies(): Assembly[] {
            throw new Error("not yet implemented");
        }
        public static GetCurrentThreadId(): number {
            throw new Error("not yet implemented");
        }
        public AppendPrivatePath(path: string) {
            throw new Error("not yet implemented");
        }
        public ClearPrivatePath() {
            throw new Error("not yet implemented");
        }
        public ClearShadowCopyPath() {
            throw new Error("not yet implemented");
        }
        public SetCachePath(path: string) {
            throw new Error("not yet implemented");
        }
        public SetShadowCopyFiles() {
            throw new Error("not yet implemented");
        }
        public SetShadowCopyPath(path: string) {
            throw new Error("not yet implemented");
        }
        public GetAssemblies(): Assembly[] {
            throw new Error("not yet implemented");
        }
        public SetPrincipalPolicy(policy: PrincipalPolicy) {
            throw new Error("not yet implemented");
        }
        public SetThreadPrincipal(principal: IPrincipal) {
            throw new Error("not yet implemented");
        }
        public CreateInstance(assemblyName: string, typeName: string): ObjectHandle {
            throw new Error("not yet implemented");
        }
        public CreateInstance(assemblyName: string, typeName: string, ignoreCase: boolean, bindingAttr: BindingFlags, binder: Binder, args: any[], culture: CultureInfo, activationAttributes: any[]): ObjectHandle {
            throw new Error("not yet implemented");
        }
        public CreateInstance(assemblyName: string, typeName: string, activationAttributes: any[]): ObjectHandle {
            throw new Error("not yet implemented");
        }
        public CreateInstanceAndUnwrap(assemblyName: string, typeName: string): any {
            throw new Error("not yet implemented");
        }
        public CreateInstanceAndUnwrap(assemblyName: string, typeName: string, ignoreCase: boolean, bindingAttr: BindingFlags, binder: Binder, args: any[], culture: CultureInfo, activationAttributes: any[]): any {
            throw new Error("not yet implemented");
        }
        public CreateInstanceAndUnwrap(assemblyName: string, typeName: string, activationAttributes: any[]): any {
            throw new Error("not yet implemented");
        }
        public CreateInstanceFrom(assemblyFile: string, typeName: string): ObjectHandle {
            throw new Error("not yet implemented");
        }
        public CreateInstanceFrom(assemblyFile: string, typeName: string, ignoreCase: boolean, bindingAttr: BindingFlags, binder: Binder, args: any[], culture: CultureInfo, activationAttributes: any[]): ObjectHandle {
            throw new Error("not yet implemented");
        }
        public CreateInstanceFrom(assemblyFile: string, typeName: string, activationAttributes: any[]): ObjectHandle {
            throw new Error("not yet implemented");
        }
        public CreateInstanceFromAndUnwrap(assemblyFile: string, typeName: string): any {
            throw new Error("not yet implemented");
        }
        public CreateInstanceFromAndUnwrap(assemblyFile: string, typeName: string, ignoreCase: boolean, bindingAttr: BindingFlags, binder: Binder, args: any[], culture: CultureInfo, activationAttributes: any[]): any {
            throw new Error("not yet implemented");
        }
        public CreateInstanceFromAndUnwrap(assemblyFile: string, typeName: string, activationAttributes: any[]): any {
            throw new Error("not yet implemented");
        }
        private GetThreadPrincipal(): IPrincipal {
            throw new Error("not yet implemented");
        }
    }
    export class SystemException extends Exception implements ISerializable {
        public constructor() {
            throw new Error("not yet implemented");
        }
        public constructor(message: string) {
            throw new Error("not yet implemented");
        }
        public constructor(message: string, innerException: Exception) {
            throw new Error("not yet implemented");
        }
        protected constructor(info: SerializationInfo, context: StreamingContext) {
            throw new Error("not yet implemented");
        }

    }
    export class OperationCanceledException extends SystemException implements ISerializable {
        private _cancellationToken: CancellationToken;

        public get CancellationToken(): CancellationToken {
            throw new Error("not yet implemented");
        }
        private set CancellationToken(value: CancellationToken) {
            throw new Error("not yet implemented");
        }

        public constructor() {
            throw new Error("not yet implemented");
        }
        public constructor(message: string) {
            throw new Error("not yet implemented");
        }
        public constructor(message: string, innerException: Exception) {
            throw new Error("not yet implemented");
        }
        public constructor(token: CancellationToken) {
            throw new Error("not yet implemented");
        }
        public constructor(message: string, token: CancellationToken) {
            throw new Error("not yet implemented");
        }
        public constructor(message: string, innerException: Exception, token: CancellationToken) {
            throw new Error("not yet implemented");
        }
        protected constructor(info: SerializationInfo, context: StreamingContext) {
            throw new Error("not yet implemented");
        }

    }
    export enum ExceptionArgument {
        obj = 0,
        dictionary = 1,
        array = 2,
        info = 3,
        key = 4,
        text = 5,
        values = 6,
        value = 7,
        startIndex = 8,
        task = 9,
        bytes = 10,
        byteIndex = 11,
        byteCount = 12,
        ch = 13,
        chars = 14,
        charIndex = 15,
        charCount = 16,
        s = 17,
        input = 18,
        ownedMemory = 19,
        list = 20,
        index = 21,
        capacity = 22,
        collection = 23,
        item = 24,
        converter = 25,
        match = 26,
        count = 27,
        action = 28,
        comparison = 29,
        exceptions = 30,
        exception = 31,
        pointer = 32,
        start = 33,
        format = 34,
        formats = 35,
        culture = 36,
        comparer = 37,
        comparable = 38,
        source = 39,
        length = 40,
        comparisonType = 41,
        manager = 42,
        sourceBytesToCopy = 43,
        callBack = 44,
        creationOptions = 45,
        function = 46,
        scheduler = 47,
        continuation = 48,
        continuationAction = 49,
        continuationFunction = 50,
        tasks = 51,
        asyncResult = 52,
        beginMethod = 53,
        endMethod = 54,
        endFunction = 55,
        cancellationToken = 56,
        continuationOptions = 57,
        delay = 58,
        millisecondsDelay = 59,
        millisecondsTimeout = 60,
        stateMachine = 61,
        timeout = 62,
        type = 63,
        sourceIndex = 64,
        sourceArray = 65,
        destinationIndex = 66,
        destinationArray = 67,
        pHandle = 68,
        handle = 69,
        other = 70,
        newSize = 71,
        lowerBounds = 72,
        lengths = 73,
        len = 74,
        keys = 75,
        indices = 76,
        index1 = 77,
        index2 = 78,
        index3 = 79,
        length1 = 80,
        length2 = 81,
        length3 = 82,
        endIndex = 83,
        elementType = 84,
        arrayIndex = 85,
        year = 86,
        codePoint = 87,
        str = 88,
        options = 89,
        prefix = 90,
        suffix = 91,
        buffer = 92,
        buffers = 93,
        offset = 94,
        stream = 95,
        anyOf = 96,
        overlapped = 97,
        minimumBytes = 98,
    }
    export interface IAsyncDisposable {
        DisposeAsync(): ValueTask;
    }
    export interface IUtf8SpanParsable<TSelf> {
        static Parse(utf8Text: ReadOnlySpan<number>, provider: IFormatProvider): TSelf;
        static TryParse(utf8Text: ReadOnlySpan<number>, provider: IFormatProvider, out result: TSelf): boolean;
    }
    export enum MidpointRounding {
        ToEven = 0,
        AwayFromZero = 1,
        ToZero = 2,
        ToNegativeInfinity = 3,
        ToPositiveInfinity = 4,
    }
    export interface IBinaryFloatParseAndFormatInfo<TSelf> implements IBinaryFloatingPointIeee754<TSelf>, IBinaryNumber<TSelf>, IBitwiseOperators<TSelf, TSelf, TSelf>, INumber<TSelf>, IComparable, IComparable<TSelf>, IComparisonOperators<TSelf, TSelf, boolean>, IEqualityOperators<TSelf, TSelf, boolean>, IModulusOperators<TSelf, TSelf, TSelf>, INumberBase<TSelf>, IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEquatable<TSelf>, IIncrementOperators<TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable<TSelf>, IParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable<TSelf>, IFloatingPointIeee754<TSelf>, IExponentialFunctions<TSelf>, IFloatingPointConstants<TSelf>, IFloatingPoint<TSelf>, ISignedNumber<TSelf>, IHyperbolicFunctions<TSelf>, ILogarithmicFunctions<TSelf>, IPowerFunctions<TSelf>, IRootFunctions<TSelf>, ITrigonometricFunctions<TSelf>, IMinMaxValue<TSelf> {
        static BitsToFloat(bits: number): TSelf;
        static FloatToBits(value: TSelf): number;
    }
    export interface IBinaryIntegerParseAndFormatInfo<TSelf> implements IBinaryInteger<TSelf>, IBinaryNumber<TSelf>, IBitwiseOperators<TSelf, TSelf, TSelf>, INumber<TSelf>, IComparable, IComparable<TSelf>, IComparisonOperators<TSelf, TSelf, boolean>, IEqualityOperators<TSelf, TSelf, boolean>, IModulusOperators<TSelf, TSelf, TSelf>, INumberBase<TSelf>, IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEquatable<TSelf>, IIncrementOperators<TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable<TSelf>, IParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable<TSelf>, IShiftOperators<TSelf, number, TSelf>, IMinMaxValue<TSelf> {
        static IsGreaterThanAsUnsigned(left: TSelf, right: TSelf): boolean;
        static MultiplyBy10(value: TSelf): TSelf;
        static MultiplyBy16(value: TSelf): TSelf;
    }
    export class UInt128 extends ValueType implements IBinaryInteger<UInt128>, IBinaryNumber<UInt128>, IBitwiseOperators<UInt128, UInt128, UInt128>, INumber<UInt128>, IComparable, IComparable<UInt128>, IComparisonOperators<UInt128, UInt128, boolean>, IEqualityOperators<UInt128, UInt128, boolean>, IModulusOperators<UInt128, UInt128, UInt128>, INumberBase<UInt128>, IAdditionOperators<UInt128, UInt128, UInt128>, IAdditiveIdentity<UInt128, UInt128>, IDecrementOperators<UInt128>, IDivisionOperators<UInt128, UInt128, UInt128>, IEquatable<UInt128>, IIncrementOperators<UInt128>, IMultiplicativeIdentity<UInt128, UInt128>, IMultiplyOperators<UInt128, UInt128, UInt128>, ISpanFormattable, IFormattable, ISpanParsable<UInt128>, IParsable<UInt128>, ISubtractionOperators<UInt128, UInt128, UInt128>, IUnaryPlusOperators<UInt128, UInt128>, IUnaryNegationOperators<UInt128, UInt128>, IUtf8SpanFormattable, IUtf8SpanParsable<UInt128>, IShiftOperators<UInt128, number, UInt128>, IMinMaxValue<UInt128>, IUnsignedNumber<UInt128>, IBinaryIntegerParseAndFormatInfo<UInt128> {
        private static get System_Numerics_IAdditiveIdentity__System_UInt128_System_UInt128___AdditiveIdentity(): UInt128 {
            throw new Error("not yet implemented");
        }
        private static get System_Numerics_IBinaryNumber__System_UInt128___AllBitsSet(): UInt128 {
            throw new Error("not yet implemented");
        }
        public static get MinValue(): UInt128 {
            throw new Error("not yet implemented");
        }
        public static get MaxValue(): UInt128 {
            throw new Error("not yet implemented");
        }
        private static get System_Numerics_IMultiplicativeIdentity__System_UInt128_System_UInt128___MultiplicativeIdentity(): UInt128 {
            throw new Error("not yet implemented");
        }
        public static get One(): UInt128 {
            throw new Error("not yet implemented");
        }
        private static get System_Numerics_INumberBase__System_UInt128___Radix(): number {
            throw new Error("not yet implemented");
        }
        public static get Zero(): UInt128 {
            throw new Error("not yet implemented");
        }
        private static get System_IBinaryIntegerParseAndFormatInfo__System_UInt128___IsSigned(): boolean {
            throw new Error("not yet implemented");
        }
        private static get System_IBinaryIntegerParseAndFormatInfo__System_UInt128___MaxDigitCount(): number {
            throw new Error("not yet implemented");
        }
        private static get System_IBinaryIntegerParseAndFormatInfo__System_UInt128___MaxHexDigitCount(): number {
            throw new Error("not yet implemented");
        }
        private static get System_IBinaryIntegerParseAndFormatInfo__System_UInt128___MaxValueDiv10(): UInt128 {
            throw new Error("not yet implemented");
        }
        private static get System_IBinaryIntegerParseAndFormatInfo__System_UInt128___OverflowMessage(): string {
            throw new Error("not yet implemented");
        }

        private _lower: number;
        private _upper: number;

        private get Lower(): number {
            throw new Error("not yet implemented");
        }
        private get Upper(): number {
            throw new Error("not yet implemented");
        }

        public constructor(upper: number, lower: number) {
            throw new Error("not yet implemented");
        }

        public CompareTo(value: any): number {
            throw new Error("not yet implemented");
        }
        public CompareTo(value: UInt128): number {
            throw new Error("not yet implemented");
        }
        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public Equals(other: UInt128): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
        public ToString(provider: IFormatProvider): string {
            throw new Error("not yet implemented");
        }
        public ToString(format: string): string {
            throw new Error("not yet implemented");
        }
        public ToString(format: string, provider: IFormatProvider): string {
            throw new Error("not yet implemented");
        }
        public TryFormat(destination: Span<string>, out charsWritten: number, format: ReadOnlySpan<string>, provider: IFormatProvider): boolean {
            throw new Error("not yet implemented");
        }
        public TryFormat(utf8Destination: Span<number>, out bytesWritten: number, format: ReadOnlySpan<string>, provider: IFormatProvider): boolean {
            throw new Error("not yet implemented");
        }
        public static Parse(s: string): UInt128 {
            throw new Error("not yet implemented");
        }
        public static Parse(s: string, style: NumberStyles): UInt128 {
            throw new Error("not yet implemented");
        }
        public static Parse(s: string, provider: IFormatProvider): UInt128 {
            throw new Error("not yet implemented");
        }
        public static Parse(s: string, style: NumberStyles, provider: IFormatProvider): UInt128 {
            throw new Error("not yet implemented");
        }
        public static Parse(s: ReadOnlySpan<string>, style: NumberStyles, provider: IFormatProvider): UInt128 {
            throw new Error("not yet implemented");
        }
        public static TryParse(s: string, out result: UInt128): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParse(s: ReadOnlySpan<string>, out result: UInt128): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParse(utf8Text: ReadOnlySpan<number>, out result: UInt128): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParse(s: string, style: NumberStyles, provider: IFormatProvider, out result: UInt128): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParse(s: ReadOnlySpan<string>, style: NumberStyles, provider: IFormatProvider, out result: UInt128): boolean {
            throw new Error("not yet implemented");
        }
        private static ToUInt128(value: number): UInt128 {
            throw new Error("not yet implemented");
        }
        private WriteLittleEndianUnsafe(destination: Span<number>) {
            throw new Error("not yet implemented");
        }
        public static DivRem(left: UInt128, right: UInt128): ValueTuple<UInt128, UInt128> {
            throw new Error("not yet implemented");
        }
        public static LeadingZeroCount(value: UInt128): UInt128 {
            throw new Error("not yet implemented");
        }
        public static PopCount(value: UInt128): UInt128 {
            throw new Error("not yet implemented");
        }
        public static RotateLeft(value: UInt128, rotateAmount: number): UInt128 {
            throw new Error("not yet implemented");
        }
        public static RotateRight(value: UInt128, rotateAmount: number): UInt128 {
            throw new Error("not yet implemented");
        }
        public static TrailingZeroCount(value: UInt128): UInt128 {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_IBinaryInteger__System_UInt128___TryReadBigEndian(source: ReadOnlySpan<number>, isUnsigned: boolean, out value: UInt128): boolean {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_IBinaryInteger__System_UInt128___TryReadLittleEndian(source: ReadOnlySpan<number>, isUnsigned: boolean, out value: UInt128): boolean {
            throw new Error("not yet implemented");
        }
        private __explicit__UInt128___GetShortestBitLength(): number {
            throw new Error("not yet implemented");
        }
        public GetShortestBitLength(): number {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__UInt128___GetByteCount(): number {
            throw new Error("not yet implemented");
        }
        public GetByteCount(): number {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__UInt128___TryWriteBigEndian(destination: Span<number>, out bytesWritten: number): boolean {
            throw new Error("not yet implemented");
        }
        public TryWriteBigEndian(destination: Span<number>, out bytesWritten: number): boolean {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__UInt128___TryWriteLittleEndian(destination: Span<number>, out bytesWritten: number): boolean {
            throw new Error("not yet implemented");
        }
        public TryWriteLittleEndian(destination: Span<number>, out bytesWritten: number): boolean {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        public static IsPow2(value: UInt128): boolean {
            throw new Error("not yet implemented");
        }
        public static Log2(value: UInt128): UInt128 {
            throw new Error("not yet implemented");
        }
        private static BigMul(left: UInt128, right: UInt128, out lower: UInt128): UInt128 {
            throw new Error("not yet implemented");
        }
        public static Clamp(value: UInt128, min: UInt128, max: UInt128): UInt128 {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumber__System_UInt128___CopySign(value: UInt128, sign: UInt128): UInt128 {
            throw new Error("not yet implemented");
        }
        public static Max(x: UInt128, y: UInt128): UInt128 {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumber__System_UInt128___MaxNumber(x: UInt128, y: UInt128): UInt128 {
            throw new Error("not yet implemented");
        }
        public static Min(x: UInt128, y: UInt128): UInt128 {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumber__System_UInt128___MinNumber(x: UInt128, y: UInt128): UInt128 {
            throw new Error("not yet implemented");
        }
        public static Sign(value: UInt128): number {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_UInt128___Abs(value: UInt128): UInt128 {
            throw new Error("not yet implemented");
        }
        public static CreateChecked(value: TOther): UInt128 {
            throw new Error("not yet implemented");
        }
        public static CreateSaturating(value: TOther): UInt128 {
            throw new Error("not yet implemented");
        }
        public static CreateTruncating(value: TOther): UInt128 {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_UInt128___IsCanonical(value: UInt128): boolean {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_UInt128___IsComplexNumber(value: UInt128): boolean {
            throw new Error("not yet implemented");
        }
        public static IsEvenInteger(value: UInt128): boolean {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_UInt128___IsFinite(value: UInt128): boolean {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_UInt128___IsImaginaryNumber(value: UInt128): boolean {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_UInt128___IsInfinity(value: UInt128): boolean {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_UInt128___IsInteger(value: UInt128): boolean {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_UInt128___IsNaN(value: UInt128): boolean {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_UInt128___IsNegative(value: UInt128): boolean {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_UInt128___IsNegativeInfinity(value: UInt128): boolean {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_UInt128___IsNormal(value: UInt128): boolean {
            throw new Error("not yet implemented");
        }
        public static IsOddInteger(value: UInt128): boolean {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_UInt128___IsPositive(value: UInt128): boolean {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_UInt128___IsPositiveInfinity(value: UInt128): boolean {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_UInt128___IsRealNumber(value: UInt128): boolean {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_UInt128___IsSubnormal(value: UInt128): boolean {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_UInt128___IsZero(value: UInt128): boolean {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_UInt128___MaxMagnitude(x: UInt128, y: UInt128): UInt128 {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_UInt128___MaxMagnitudeNumber(x: UInt128, y: UInt128): UInt128 {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_UInt128___MinMagnitude(x: UInt128, y: UInt128): UInt128 {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_UInt128___MinMagnitudeNumber(x: UInt128, y: UInt128): UInt128 {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_UInt128___TryConvertFromChecked(value: TOther, out result: UInt128): boolean {
            throw new Error("not yet implemented");
        }
        private static TryConvertFromChecked(value: TOther, out result: UInt128): boolean {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_UInt128___TryConvertFromSaturating(value: TOther, out result: UInt128): boolean {
            throw new Error("not yet implemented");
        }
        private static TryConvertFromSaturating(value: TOther, out result: UInt128): boolean {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_UInt128___TryConvertFromTruncating(value: TOther, out result: UInt128): boolean {
            throw new Error("not yet implemented");
        }
        private static TryConvertFromTruncating(value: TOther, out result: UInt128): boolean {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_UInt128___TryConvertToChecked(value: UInt128, out result: TOther): boolean {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_UInt128___TryConvertToSaturating(value: UInt128, out result: TOther): boolean {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_UInt128___TryConvertToTruncating(value: UInt128, out result: TOther): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParse(s: string, provider: IFormatProvider, out result: UInt128): boolean {
            throw new Error("not yet implemented");
        }
        public static Parse(s: ReadOnlySpan<string>, provider: IFormatProvider): UInt128 {
            throw new Error("not yet implemented");
        }
        public static TryParse(s: ReadOnlySpan<string>, provider: IFormatProvider, out result: UInt128): boolean {
            throw new Error("not yet implemented");
        }
        public static Parse(utf8Text: ReadOnlySpan<number>, style: NumberStyles, provider: IFormatProvider): UInt128 {
            throw new Error("not yet implemented");
        }
        public static TryParse(utf8Text: ReadOnlySpan<number>, style: NumberStyles, provider: IFormatProvider, out result: UInt128): boolean {
            throw new Error("not yet implemented");
        }
        public static Parse(utf8Text: ReadOnlySpan<number>, provider: IFormatProvider): UInt128 {
            throw new Error("not yet implemented");
        }
        public static TryParse(utf8Text: ReadOnlySpan<number>, provider: IFormatProvider, out result: UInt128): boolean {
            throw new Error("not yet implemented");
        }
        private static System_IBinaryIntegerParseAndFormatInfo__System_UInt128___IsGreaterThanAsUnsigned(left: UInt128, right: UInt128): boolean {
            throw new Error("not yet implemented");
        }
        private static System_IBinaryIntegerParseAndFormatInfo__System_UInt128___MultiplyBy10(value: UInt128): UInt128 {
            throw new Error("not yet implemented");
        }
        private static System_IBinaryIntegerParseAndFormatInfo__System_UInt128___MultiplyBy16(value: UInt128): UInt128 {
            throw new Error("not yet implemented");
        }
        private static __op_Division__g__AddDivisor_110_0(left: Span<number>, right: ReadOnlySpan<number>): number {
            throw new Error("not yet implemented");
        }
        private static __op_Division__g__DivideGuessTooBig_110_1(q: number, valHi: number, valLo: number, divHi: number, divLo: number): boolean {
            throw new Error("not yet implemented");
        }
        private static __op_Division__g__DivideSlow_110_2(quotient: UInt128, divisor: UInt128): UInt128 {
            throw new Error("not yet implemented");
        }
        private static __op_Division__g__SubtractDivisor_110_3(left: Span<number>, right: ReadOnlySpan<number>, q: number): number {
            throw new Error("not yet implemented");
        }
    }
    export class Int128 extends ValueType implements IBinaryInteger<Int128>, IBinaryNumber<Int128>, IBitwiseOperators<Int128, Int128, Int128>, INumber<Int128>, IComparable, IComparable<Int128>, IComparisonOperators<Int128, Int128, boolean>, IEqualityOperators<Int128, Int128, boolean>, IModulusOperators<Int128, Int128, Int128>, INumberBase<Int128>, IAdditionOperators<Int128, Int128, Int128>, IAdditiveIdentity<Int128, Int128>, IDecrementOperators<Int128>, IDivisionOperators<Int128, Int128, Int128>, IEquatable<Int128>, IIncrementOperators<Int128>, IMultiplicativeIdentity<Int128, Int128>, IMultiplyOperators<Int128, Int128, Int128>, ISpanFormattable, IFormattable, ISpanParsable<Int128>, IParsable<Int128>, ISubtractionOperators<Int128, Int128, Int128>, IUnaryPlusOperators<Int128, Int128>, IUnaryNegationOperators<Int128, Int128>, IUtf8SpanFormattable, IUtf8SpanParsable<Int128>, IShiftOperators<Int128, number, Int128>, IMinMaxValue<Int128>, ISignedNumber<Int128>, IBinaryIntegerParseAndFormatInfo<Int128> {
        private static get System_Numerics_IAdditiveIdentity__System_Int128_System_Int128___AdditiveIdentity(): Int128 {
            throw new Error("not yet implemented");
        }
        private static get System_Numerics_IBinaryNumber__System_Int128___AllBitsSet(): Int128 {
            throw new Error("not yet implemented");
        }
        public static get MinValue(): Int128 {
            throw new Error("not yet implemented");
        }
        public static get MaxValue(): Int128 {
            throw new Error("not yet implemented");
        }
        private static get System_Numerics_IMultiplicativeIdentity__System_Int128_System_Int128___MultiplicativeIdentity(): Int128 {
            throw new Error("not yet implemented");
        }
        public static get One(): Int128 {
            throw new Error("not yet implemented");
        }
        private static get System_Numerics_INumberBase__System_Int128___Radix(): number {
            throw new Error("not yet implemented");
        }
        public static get Zero(): Int128 {
            throw new Error("not yet implemented");
        }
        public static get NegativeOne(): Int128 {
            throw new Error("not yet implemented");
        }
        private static get System_IBinaryIntegerParseAndFormatInfo__System_Int128___IsSigned(): boolean {
            throw new Error("not yet implemented");
        }
        private static get System_IBinaryIntegerParseAndFormatInfo__System_Int128___MaxDigitCount(): number {
            throw new Error("not yet implemented");
        }
        private static get System_IBinaryIntegerParseAndFormatInfo__System_Int128___MaxHexDigitCount(): number {
            throw new Error("not yet implemented");
        }
        private static get System_IBinaryIntegerParseAndFormatInfo__System_Int128___MaxValueDiv10(): Int128 {
            throw new Error("not yet implemented");
        }
        private static get System_IBinaryIntegerParseAndFormatInfo__System_Int128___OverflowMessage(): string {
            throw new Error("not yet implemented");
        }

        private _lower: number;
        private _upper: number;

        private get Lower(): number {
            throw new Error("not yet implemented");
        }
        private get Upper(): number {
            throw new Error("not yet implemented");
        }

        public constructor(upper: number, lower: number) {
            throw new Error("not yet implemented");
        }

        public CompareTo(value: any): number {
            throw new Error("not yet implemented");
        }
        public CompareTo(value: Int128): number {
            throw new Error("not yet implemented");
        }
        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public Equals(other: Int128): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
        public ToString(provider: IFormatProvider): string {
            throw new Error("not yet implemented");
        }
        public ToString(format: string): string {
            throw new Error("not yet implemented");
        }
        public ToString(format: string, provider: IFormatProvider): string {
            throw new Error("not yet implemented");
        }
        public TryFormat(destination: Span<string>, out charsWritten: number, format: ReadOnlySpan<string>, provider: IFormatProvider): boolean {
            throw new Error("not yet implemented");
        }
        public TryFormat(utf8Destination: Span<number>, out bytesWritten: number, format: ReadOnlySpan<string>, provider: IFormatProvider): boolean {
            throw new Error("not yet implemented");
        }
        public static Parse(s: string): Int128 {
            throw new Error("not yet implemented");
        }
        public static Parse(s: string, style: NumberStyles): Int128 {
            throw new Error("not yet implemented");
        }
        public static Parse(s: string, provider: IFormatProvider): Int128 {
            throw new Error("not yet implemented");
        }
        public static Parse(s: string, style: NumberStyles, provider: IFormatProvider): Int128 {
            throw new Error("not yet implemented");
        }
        public static Parse(s: ReadOnlySpan<string>, style: NumberStyles, provider: IFormatProvider): Int128 {
            throw new Error("not yet implemented");
        }
        public static TryParse(s: string, out result: Int128): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParse(s: ReadOnlySpan<string>, out result: Int128): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParse(utf8Text: ReadOnlySpan<number>, out result: Int128): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParse(s: string, style: NumberStyles, provider: IFormatProvider, out result: Int128): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParse(s: ReadOnlySpan<string>, style: NumberStyles, provider: IFormatProvider, out result: Int128): boolean {
            throw new Error("not yet implemented");
        }
        private static ToInt128(value: number): Int128 {
            throw new Error("not yet implemented");
        }
        public static DivRem(left: Int128, right: Int128): ValueTuple<Int128, Int128> {
            throw new Error("not yet implemented");
        }
        public static LeadingZeroCount(value: Int128): Int128 {
            throw new Error("not yet implemented");
        }
        public static PopCount(value: Int128): Int128 {
            throw new Error("not yet implemented");
        }
        public static RotateLeft(value: Int128, rotateAmount: number): Int128 {
            throw new Error("not yet implemented");
        }
        public static RotateRight(value: Int128, rotateAmount: number): Int128 {
            throw new Error("not yet implemented");
        }
        public static TrailingZeroCount(value: Int128): Int128 {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_IBinaryInteger__System_Int128___TryReadBigEndian(source: ReadOnlySpan<number>, isUnsigned: boolean, out value: Int128): boolean {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_IBinaryInteger__System_Int128___TryReadLittleEndian(source: ReadOnlySpan<number>, isUnsigned: boolean, out value: Int128): boolean {
            throw new Error("not yet implemented");
        }
        private __explicit__Int128___GetShortestBitLength(): number {
            throw new Error("not yet implemented");
        }
        public GetShortestBitLength(): number {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__Int128___GetByteCount(): number {
            throw new Error("not yet implemented");
        }
        public GetByteCount(): number {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__Int128___TryWriteBigEndian(destination: Span<number>, out bytesWritten: number): boolean {
            throw new Error("not yet implemented");
        }
        public TryWriteBigEndian(destination: Span<number>, out bytesWritten: number): boolean {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__Int128___TryWriteLittleEndian(destination: Span<number>, out bytesWritten: number): boolean {
            throw new Error("not yet implemented");
        }
        public TryWriteLittleEndian(destination: Span<number>, out bytesWritten: number): boolean {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        public static IsPow2(value: Int128): boolean {
            throw new Error("not yet implemented");
        }
        public static Log2(value: Int128): Int128 {
            throw new Error("not yet implemented");
        }
        private static BigMul(left: Int128, right: Int128, out lower: Int128): Int128 {
            throw new Error("not yet implemented");
        }
        public static Clamp(value: Int128, min: Int128, max: Int128): Int128 {
            throw new Error("not yet implemented");
        }
        public static CopySign(value: Int128, sign: Int128): Int128 {
            throw new Error("not yet implemented");
        }
        public static Max(x: Int128, y: Int128): Int128 {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumber__System_Int128___MaxNumber(x: Int128, y: Int128): Int128 {
            throw new Error("not yet implemented");
        }
        public static Min(x: Int128, y: Int128): Int128 {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumber__System_Int128___MinNumber(x: Int128, y: Int128): Int128 {
            throw new Error("not yet implemented");
        }
        public static Sign(value: Int128): number {
            throw new Error("not yet implemented");
        }
        public static Abs(value: Int128): Int128 {
            throw new Error("not yet implemented");
        }
        public static CreateChecked(value: TOther): Int128 {
            throw new Error("not yet implemented");
        }
        public static CreateSaturating(value: TOther): Int128 {
            throw new Error("not yet implemented");
        }
        public static CreateTruncating(value: TOther): Int128 {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_Int128___IsCanonical(value: Int128): boolean {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_Int128___IsComplexNumber(value: Int128): boolean {
            throw new Error("not yet implemented");
        }
        public static IsEvenInteger(value: Int128): boolean {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_Int128___IsFinite(value: Int128): boolean {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_Int128___IsImaginaryNumber(value: Int128): boolean {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_Int128___IsInfinity(value: Int128): boolean {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_Int128___IsInteger(value: Int128): boolean {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_Int128___IsNaN(value: Int128): boolean {
            throw new Error("not yet implemented");
        }
        public static IsNegative(value: Int128): boolean {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_Int128___IsNegativeInfinity(value: Int128): boolean {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_Int128___IsNormal(value: Int128): boolean {
            throw new Error("not yet implemented");
        }
        public static IsOddInteger(value: Int128): boolean {
            throw new Error("not yet implemented");
        }
        public static IsPositive(value: Int128): boolean {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_Int128___IsPositiveInfinity(value: Int128): boolean {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_Int128___IsRealNumber(value: Int128): boolean {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_Int128___IsSubnormal(value: Int128): boolean {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_Int128___IsZero(value: Int128): boolean {
            throw new Error("not yet implemented");
        }
        public static MaxMagnitude(x: Int128, y: Int128): Int128 {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_Int128___MaxMagnitudeNumber(x: Int128, y: Int128): Int128 {
            throw new Error("not yet implemented");
        }
        public static MinMagnitude(x: Int128, y: Int128): Int128 {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_Int128___MinMagnitudeNumber(x: Int128, y: Int128): Int128 {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_Int128___TryConvertFromChecked(value: TOther, out result: Int128): boolean {
            throw new Error("not yet implemented");
        }
        private static TryConvertFromChecked(value: TOther, out result: Int128): boolean {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_Int128___TryConvertFromSaturating(value: TOther, out result: Int128): boolean {
            throw new Error("not yet implemented");
        }
        private static TryConvertFromSaturating(value: TOther, out result: Int128): boolean {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_Int128___TryConvertFromTruncating(value: TOther, out result: Int128): boolean {
            throw new Error("not yet implemented");
        }
        private static TryConvertFromTruncating(value: TOther, out result: Int128): boolean {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_Int128___TryConvertToChecked(value: Int128, out result: TOther): boolean {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_Int128___TryConvertToSaturating(value: Int128, out result: TOther): boolean {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_Int128___TryConvertToTruncating(value: Int128, out result: TOther): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParse(s: string, provider: IFormatProvider, out result: Int128): boolean {
            throw new Error("not yet implemented");
        }
        public static Parse(s: ReadOnlySpan<string>, provider: IFormatProvider): Int128 {
            throw new Error("not yet implemented");
        }
        public static TryParse(s: ReadOnlySpan<string>, provider: IFormatProvider, out result: Int128): boolean {
            throw new Error("not yet implemented");
        }
        public static Parse(utf8Text: ReadOnlySpan<number>, style: NumberStyles, provider: IFormatProvider): Int128 {
            throw new Error("not yet implemented");
        }
        public static TryParse(utf8Text: ReadOnlySpan<number>, style: NumberStyles, provider: IFormatProvider, out result: Int128): boolean {
            throw new Error("not yet implemented");
        }
        public static Parse(utf8Text: ReadOnlySpan<number>, provider: IFormatProvider): Int128 {
            throw new Error("not yet implemented");
        }
        public static TryParse(utf8Text: ReadOnlySpan<number>, provider: IFormatProvider, out result: Int128): boolean {
            throw new Error("not yet implemented");
        }
        private static System_IBinaryIntegerParseAndFormatInfo__System_Int128___IsGreaterThanAsUnsigned(left: Int128, right: Int128): boolean {
            throw new Error("not yet implemented");
        }
        private static System_IBinaryIntegerParseAndFormatInfo__System_Int128___MultiplyBy10(value: Int128): Int128 {
            throw new Error("not yet implemented");
        }
        private static System_IBinaryIntegerParseAndFormatInfo__System_Int128___MultiplyBy16(value: Int128): Int128 {
            throw new Error("not yet implemented");
        }
    }
    export class Half extends ValueType implements IComparable, ISpanFormattable, IFormattable, IComparable<Half>, IEquatable<Half>, IBinaryFloatingPointIeee754<Half>, IBinaryNumber<Half>, IBitwiseOperators<Half, Half, Half>, INumber<Half>, IComparisonOperators<Half, Half, boolean>, IEqualityOperators<Half, Half, boolean>, IModulusOperators<Half, Half, Half>, INumberBase<Half>, IAdditionOperators<Half, Half, Half>, IAdditiveIdentity<Half, Half>, IDecrementOperators<Half>, IDivisionOperators<Half, Half, Half>, IIncrementOperators<Half>, IMultiplicativeIdentity<Half, Half>, IMultiplyOperators<Half, Half, Half>, ISpanParsable<Half>, IParsable<Half>, ISubtractionOperators<Half, Half, Half>, IUnaryPlusOperators<Half, Half>, IUnaryNegationOperators<Half, Half>, IUtf8SpanFormattable, IUtf8SpanParsable<Half>, IFloatingPointIeee754<Half>, IExponentialFunctions<Half>, IFloatingPointConstants<Half>, IFloatingPoint<Half>, ISignedNumber<Half>, IHyperbolicFunctions<Half>, ILogarithmicFunctions<Half>, IPowerFunctions<Half>, IRootFunctions<Half>, ITrigonometricFunctions<Half>, IMinMaxValue<Half>, IBinaryFloatParseAndFormatInfo<Half> {
        public static get Epsilon(): Half {
            throw new Error("not yet implemented");
        }
        public static get PositiveInfinity(): Half {
            throw new Error("not yet implemented");
        }
        public static get NegativeInfinity(): Half {
            throw new Error("not yet implemented");
        }
        public static get NaN(): Half {
            throw new Error("not yet implemented");
        }
        public static get MinValue(): Half {
            throw new Error("not yet implemented");
        }
        public static get MaxValue(): Half {
            throw new Error("not yet implemented");
        }
        private static get System_Numerics_IAdditiveIdentity__System_Half_System_Half___AdditiveIdentity(): Half {
            throw new Error("not yet implemented");
        }
        private static get System_Numerics_IBinaryNumber__System_Half___AllBitsSet(): Half {
            throw new Error("not yet implemented");
        }
        public static get E(): Half {
            throw new Error("not yet implemented");
        }
        public static get Pi(): Half {
            throw new Error("not yet implemented");
        }
        public static get Tau(): Half {
            throw new Error("not yet implemented");
        }
        public static get NegativeZero(): Half {
            throw new Error("not yet implemented");
        }
        public static get MultiplicativeIdentity(): Half {
            throw new Error("not yet implemented");
        }
        public static get One(): Half {
            throw new Error("not yet implemented");
        }
        private static get System_Numerics_INumberBase__System_Half___Radix(): number {
            throw new Error("not yet implemented");
        }
        public static get Zero(): Half {
            throw new Error("not yet implemented");
        }
        public static get NegativeOne(): Half {
            throw new Error("not yet implemented");
        }
        private static get System_IBinaryFloatParseAndFormatInfo__System_Half___NumberBufferLength(): number {
            throw new Error("not yet implemented");
        }
        private static get System_IBinaryFloatParseAndFormatInfo__System_Half___ZeroBits(): number {
            throw new Error("not yet implemented");
        }
        private static get System_IBinaryFloatParseAndFormatInfo__System_Half___InfinityBits(): number {
            throw new Error("not yet implemented");
        }
        private static get System_IBinaryFloatParseAndFormatInfo__System_Half___NormalMantissaMask(): number {
            throw new Error("not yet implemented");
        }
        private static get System_IBinaryFloatParseAndFormatInfo__System_Half___DenormalMantissaMask(): number {
            throw new Error("not yet implemented");
        }
        private static get System_IBinaryFloatParseAndFormatInfo__System_Half___MinBinaryExponent(): number {
            throw new Error("not yet implemented");
        }
        private static get System_IBinaryFloatParseAndFormatInfo__System_Half___MaxBinaryExponent(): number {
            throw new Error("not yet implemented");
        }
        private static get System_IBinaryFloatParseAndFormatInfo__System_Half___MinDecimalExponent(): number {
            throw new Error("not yet implemented");
        }
        private static get System_IBinaryFloatParseAndFormatInfo__System_Half___MaxDecimalExponent(): number {
            throw new Error("not yet implemented");
        }
        private static get System_IBinaryFloatParseAndFormatInfo__System_Half___ExponentBias(): number {
            throw new Error("not yet implemented");
        }
        private static get System_IBinaryFloatParseAndFormatInfo__System_Half___ExponentBits(): number {
            throw new Error("not yet implemented");
        }
        private static get System_IBinaryFloatParseAndFormatInfo__System_Half___OverflowDecimalExponent(): number {
            throw new Error("not yet implemented");
        }
        private static get System_IBinaryFloatParseAndFormatInfo__System_Half___InfinityExponent(): number {
            throw new Error("not yet implemented");
        }
        private static get System_IBinaryFloatParseAndFormatInfo__System_Half___NormalMantissaBits(): number {
            throw new Error("not yet implemented");
        }
        private static get System_IBinaryFloatParseAndFormatInfo__System_Half___DenormalMantissaBits(): number {
            throw new Error("not yet implemented");
        }
        private static get System_IBinaryFloatParseAndFormatInfo__System_Half___MinFastFloatDecimalExponent(): number {
            throw new Error("not yet implemented");
        }
        private static get System_IBinaryFloatParseAndFormatInfo__System_Half___MaxFastFloatDecimalExponent(): number {
            throw new Error("not yet implemented");
        }
        private static get System_IBinaryFloatParseAndFormatInfo__System_Half___MinExponentRoundToEven(): number {
            throw new Error("not yet implemented");
        }
        private static get System_IBinaryFloatParseAndFormatInfo__System_Half___MaxExponentRoundToEven(): number {
            throw new Error("not yet implemented");
        }
        private static get System_IBinaryFloatParseAndFormatInfo__System_Half___MaxExponentFastPath(): number {
            throw new Error("not yet implemented");
        }
        private static get System_IBinaryFloatParseAndFormatInfo__System_Half___MaxMantissaFastPath(): number {
            throw new Error("not yet implemented");
        }

        private _value: number;

        private get BiasedExponent(): number {
            throw new Error("not yet implemented");
        }
        private get Exponent(): number {
            throw new Error("not yet implemented");
        }
        private get Significand(): number {
            throw new Error("not yet implemented");
        }
        private get TrailingSignificand(): number {
            throw new Error("not yet implemented");
        }

        protected constructor(value: number) {
            throw new Error("not yet implemented");
        }
        private constructor(sign: boolean, exp: number, sig: number) {
            throw new Error("not yet implemented");
        }

        private static ExtractBiasedExponentFromBits(bits: number): number {
            throw new Error("not yet implemented");
        }
        private static ExtractTrailingSignificandFromBits(bits: number): number {
            throw new Error("not yet implemented");
        }
        public static IsFinite(value: Half): boolean {
            throw new Error("not yet implemented");
        }
        public static IsInfinity(value: Half): boolean {
            throw new Error("not yet implemented");
        }
        public static IsNaN(value: Half): boolean {
            throw new Error("not yet implemented");
        }
        public static IsNegative(value: Half): boolean {
            throw new Error("not yet implemented");
        }
        public static IsNegativeInfinity(value: Half): boolean {
            throw new Error("not yet implemented");
        }
        public static IsNormal(value: Half): boolean {
            throw new Error("not yet implemented");
        }
        public static IsPositiveInfinity(value: Half): boolean {
            throw new Error("not yet implemented");
        }
        public static IsSubnormal(value: Half): boolean {
            throw new Error("not yet implemented");
        }
        public static Parse(s: string): Half {
            throw new Error("not yet implemented");
        }
        public static Parse(s: string, style: NumberStyles): Half {
            throw new Error("not yet implemented");
        }
        public static Parse(s: string, provider: IFormatProvider): Half {
            throw new Error("not yet implemented");
        }
        public static Parse(s: string, style: NumberStyles, provider: IFormatProvider): Half {
            throw new Error("not yet implemented");
        }
        public static Parse(s: ReadOnlySpan<string>, style: NumberStyles, provider: IFormatProvider): Half {
            throw new Error("not yet implemented");
        }
        public static TryParse(s: string, out result: Half): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParse(s: ReadOnlySpan<string>, out result: Half): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParse(utf8Text: ReadOnlySpan<number>, out result: Half): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParse(s: string, style: NumberStyles, provider: IFormatProvider, out result: Half): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParse(s: ReadOnlySpan<string>, style: NumberStyles, provider: IFormatProvider, out result: Half): boolean {
            throw new Error("not yet implemented");
        }
        private static AreZero(left: Half, right: Half): boolean {
            throw new Error("not yet implemented");
        }
        private static IsNaNOrZero(value: Half): boolean {
            throw new Error("not yet implemented");
        }
        private static StripSign(value: Half): number {
            throw new Error("not yet implemented");
        }
        public CompareTo(obj: any): number {
            throw new Error("not yet implemented");
        }
        public CompareTo(other: Half): number {
            throw new Error("not yet implemented");
        }
        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public Equals(other: Half): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
        public ToString(format: string): string {
            throw new Error("not yet implemented");
        }
        public ToString(provider: IFormatProvider): string {
            throw new Error("not yet implemented");
        }
        public ToString(format: string, provider: IFormatProvider): string {
            throw new Error("not yet implemented");
        }
        public TryFormat(destination: Span<string>, out charsWritten: number, format: ReadOnlySpan<string>, provider: IFormatProvider): boolean {
            throw new Error("not yet implemented");
        }
        public TryFormat(utf8Destination: Span<number>, out bytesWritten: number, format: ReadOnlySpan<string>, provider: IFormatProvider): boolean {
            throw new Error("not yet implemented");
        }
        private static Negate(value: Half): Half {
            throw new Error("not yet implemented");
        }
        private static NormSubnormalF16Sig(sig: number): ValueTuple<number, number> {
            throw new Error("not yet implemented");
        }
        private static CreateHalfNaN(sign: boolean, significand: number): Half {
            throw new Error("not yet implemented");
        }
        private static RoundPackToHalf(sign: boolean, exp: number, sig: number): number {
            throw new Error("not yet implemented");
        }
        private static ShiftRightJam(i: number, dist: number): number {
            throw new Error("not yet implemented");
        }
        private static ShiftRightJam(l: number, dist: number): number {
            throw new Error("not yet implemented");
        }
        private static CreateDoubleNaN(sign: boolean, significand: number): number {
            throw new Error("not yet implemented");
        }
        private static CreateDouble(sign: boolean, exp: number, sig: number): number {
            throw new Error("not yet implemented");
        }
        public static IsPow2(value: Half): boolean {
            throw new Error("not yet implemented");
        }
        public static Log2(value: Half): Half {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_IBitwiseOperators__System_Half_System_Half_System_Half___op_BitwiseAnd(left: Half, right: Half): Half {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_IBitwiseOperators__System_Half_System_Half_System_Half___op_BitwiseOr(left: Half, right: Half): Half {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_IBitwiseOperators__System_Half_System_Half_System_Half___op_ExclusiveOr(left: Half, right: Half): Half {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_IBitwiseOperators__System_Half_System_Half_System_Half___op_OnesComplement(value: Half): Half {
            throw new Error("not yet implemented");
        }
        public static Exp(x: Half): Half {
            throw new Error("not yet implemented");
        }
        public static ExpM1(x: Half): Half {
            throw new Error("not yet implemented");
        }
        public static Exp2(x: Half): Half {
            throw new Error("not yet implemented");
        }
        public static Exp2M1(x: Half): Half {
            throw new Error("not yet implemented");
        }
        public static Exp10(x: Half): Half {
            throw new Error("not yet implemented");
        }
        public static Exp10M1(x: Half): Half {
            throw new Error("not yet implemented");
        }
        public static Ceiling(x: Half): Half {
            throw new Error("not yet implemented");
        }
        public static Floor(x: Half): Half {
            throw new Error("not yet implemented");
        }
        public static Round(x: Half): Half {
            throw new Error("not yet implemented");
        }
        public static Round(x: Half, digits: number): Half {
            throw new Error("not yet implemented");
        }
        public static Round(x: Half, mode: MidpointRounding): Half {
            throw new Error("not yet implemented");
        }
        public static Round(x: Half, digits: number, mode: MidpointRounding): Half {
            throw new Error("not yet implemented");
        }
        public static Truncate(x: Half): Half {
            throw new Error("not yet implemented");
        }
        private __explicit__Half___GetExponentByteCount(): number {
            throw new Error("not yet implemented");
        }
        public GetExponentByteCount(): number {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__Half___GetExponentShortestBitLength(): number {
            throw new Error("not yet implemented");
        }
        public GetExponentShortestBitLength(): number {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__Half___GetSignificandByteCount(): number {
            throw new Error("not yet implemented");
        }
        public GetSignificandByteCount(): number {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__Half___GetSignificandBitLength(): number {
            throw new Error("not yet implemented");
        }
        public GetSignificandBitLength(): number {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__Half___TryWriteExponentBigEndian(destination: Span<number>, out bytesWritten: number): boolean {
            throw new Error("not yet implemented");
        }
        public TryWriteExponentBigEndian(destination: Span<number>, out bytesWritten: number): boolean {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__Half___TryWriteExponentLittleEndian(destination: Span<number>, out bytesWritten: number): boolean {
            throw new Error("not yet implemented");
        }
        public TryWriteExponentLittleEndian(destination: Span<number>, out bytesWritten: number): boolean {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__Half___TryWriteSignificandBigEndian(destination: Span<number>, out bytesWritten: number): boolean {
            throw new Error("not yet implemented");
        }
        public TryWriteSignificandBigEndian(destination: Span<number>, out bytesWritten: number): boolean {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__Half___TryWriteSignificandLittleEndian(destination: Span<number>, out bytesWritten: number): boolean {
            throw new Error("not yet implemented");
        }
        public TryWriteSignificandLittleEndian(destination: Span<number>, out bytesWritten: number): boolean {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        public static Atan2(y: Half, x: Half): Half {
            throw new Error("not yet implemented");
        }
        public static Atan2Pi(y: Half, x: Half): Half {
            throw new Error("not yet implemented");
        }
        public static BitDecrement(x: Half): Half {
            throw new Error("not yet implemented");
        }
        public static BitIncrement(x: Half): Half {
            throw new Error("not yet implemented");
        }
        public static FusedMultiplyAdd(left: Half, right: Half, addend: Half): Half {
            throw new Error("not yet implemented");
        }
        public static Ieee754Remainder(left: Half, right: Half): Half {
            throw new Error("not yet implemented");
        }
        public static ILogB(x: Half): number {
            throw new Error("not yet implemented");
        }
        public static Lerp(value1: Half, value2: Half, amount: Half): Half {
            throw new Error("not yet implemented");
        }
        public static ReciprocalEstimate(x: Half): Half {
            throw new Error("not yet implemented");
        }
        public static ReciprocalSqrtEstimate(x: Half): Half {
            throw new Error("not yet implemented");
        }
        public static ScaleB(x: Half, n: number): Half {
            throw new Error("not yet implemented");
        }
        public static Acosh(x: Half): Half {
            throw new Error("not yet implemented");
        }
        public static Asinh(x: Half): Half {
            throw new Error("not yet implemented");
        }
        public static Atanh(x: Half): Half {
            throw new Error("not yet implemented");
        }
        public static Cosh(x: Half): Half {
            throw new Error("not yet implemented");
        }
        public static Sinh(x: Half): Half {
            throw new Error("not yet implemented");
        }
        public static Tanh(x: Half): Half {
            throw new Error("not yet implemented");
        }
        public static Log(x: Half): Half {
            throw new Error("not yet implemented");
        }
        public static Log(x: Half, newBase: Half): Half {
            throw new Error("not yet implemented");
        }
        public static Log10(x: Half): Half {
            throw new Error("not yet implemented");
        }
        public static LogP1(x: Half): Half {
            throw new Error("not yet implemented");
        }
        public static Log2P1(x: Half): Half {
            throw new Error("not yet implemented");
        }
        public static Log10P1(x: Half): Half {
            throw new Error("not yet implemented");
        }
        public static Clamp(value: Half, min: Half, max: Half): Half {
            throw new Error("not yet implemented");
        }
        public static CopySign(value: Half, sign: Half): Half {
            throw new Error("not yet implemented");
        }
        public static Max(x: Half, y: Half): Half {
            throw new Error("not yet implemented");
        }
        public static MaxNumber(x: Half, y: Half): Half {
            throw new Error("not yet implemented");
        }
        public static Min(x: Half, y: Half): Half {
            throw new Error("not yet implemented");
        }
        public static MinNumber(x: Half, y: Half): Half {
            throw new Error("not yet implemented");
        }
        public static Sign(value: Half): number {
            throw new Error("not yet implemented");
        }
        public static Abs(value: Half): Half {
            throw new Error("not yet implemented");
        }
        public static CreateChecked(value: TOther): Half {
            throw new Error("not yet implemented");
        }
        public static CreateSaturating(value: TOther): Half {
            throw new Error("not yet implemented");
        }
        public static CreateTruncating(value: TOther): Half {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_Half___IsCanonical(value: Half): boolean {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_Half___IsComplexNumber(value: Half): boolean {
            throw new Error("not yet implemented");
        }
        public static IsEvenInteger(value: Half): boolean {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_Half___IsImaginaryNumber(value: Half): boolean {
            throw new Error("not yet implemented");
        }
        public static IsInteger(value: Half): boolean {
            throw new Error("not yet implemented");
        }
        public static IsOddInteger(value: Half): boolean {
            throw new Error("not yet implemented");
        }
        public static IsPositive(value: Half): boolean {
            throw new Error("not yet implemented");
        }
        public static IsRealNumber(value: Half): boolean {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_Half___IsZero(value: Half): boolean {
            throw new Error("not yet implemented");
        }
        public static MaxMagnitude(x: Half, y: Half): Half {
            throw new Error("not yet implemented");
        }
        public static MaxMagnitudeNumber(x: Half, y: Half): Half {
            throw new Error("not yet implemented");
        }
        public static MinMagnitude(x: Half, y: Half): Half {
            throw new Error("not yet implemented");
        }
        public static MinMagnitudeNumber(x: Half, y: Half): Half {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_Half___TryConvertFromChecked(value: TOther, out result: Half): boolean {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_Half___TryConvertFromSaturating(value: TOther, out result: Half): boolean {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_Half___TryConvertFromTruncating(value: TOther, out result: Half): boolean {
            throw new Error("not yet implemented");
        }
        private static TryConvertFrom(value: TOther, out result: Half): boolean {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_Half___TryConvertToChecked(value: Half, out result: TOther): boolean {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_Half___TryConvertToSaturating(value: Half, out result: TOther): boolean {
            throw new Error("not yet implemented");
        }
        private static System_Numerics_INumberBase__System_Half___TryConvertToTruncating(value: Half, out result: TOther): boolean {
            throw new Error("not yet implemented");
        }
        private static TryConvertTo(value: Half, out result: TOther): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParse(s: string, provider: IFormatProvider, out result: Half): boolean {
            throw new Error("not yet implemented");
        }
        public static Pow(x: Half, y: Half): Half {
            throw new Error("not yet implemented");
        }
        public static Cbrt(x: Half): Half {
            throw new Error("not yet implemented");
        }
        public static Hypot(x: Half, y: Half): Half {
            throw new Error("not yet implemented");
        }
        public static RootN(x: Half, n: number): Half {
            throw new Error("not yet implemented");
        }
        public static Sqrt(x: Half): Half {
            throw new Error("not yet implemented");
        }
        public static Parse(s: ReadOnlySpan<string>, provider: IFormatProvider): Half {
            throw new Error("not yet implemented");
        }
        public static TryParse(s: ReadOnlySpan<string>, provider: IFormatProvider, out result: Half): boolean {
            throw new Error("not yet implemented");
        }
        public static Acos(x: Half): Half {
            throw new Error("not yet implemented");
        }
        public static AcosPi(x: Half): Half {
            throw new Error("not yet implemented");
        }
        public static Asin(x: Half): Half {
            throw new Error("not yet implemented");
        }
        public static AsinPi(x: Half): Half {
            throw new Error("not yet implemented");
        }
        public static Atan(x: Half): Half {
            throw new Error("not yet implemented");
        }
        public static AtanPi(x: Half): Half {
            throw new Error("not yet implemented");
        }
        public static Cos(x: Half): Half {
            throw new Error("not yet implemented");
        }
        public static CosPi(x: Half): Half {
            throw new Error("not yet implemented");
        }
        public static DegreesToRadians(degrees: Half): Half {
            throw new Error("not yet implemented");
        }
        public static RadiansToDegrees(radians: Half): Half {
            throw new Error("not yet implemented");
        }
        public static Sin(x: Half): Half {
            throw new Error("not yet implemented");
        }
        public static SinCos(x: Half): ValueTuple<Half, Half> {
            throw new Error("not yet implemented");
        }
        public static SinCosPi(x: Half): ValueTuple<Half, Half> {
            throw new Error("not yet implemented");
        }
        public static SinPi(x: Half): Half {
            throw new Error("not yet implemented");
        }
        public static Tan(x: Half): Half {
            throw new Error("not yet implemented");
        }
        public static TanPi(x: Half): Half {
            throw new Error("not yet implemented");
        }
        public static Parse(utf8Text: ReadOnlySpan<number>, style: NumberStyles, provider: IFormatProvider): Half {
            throw new Error("not yet implemented");
        }
        public static TryParse(utf8Text: ReadOnlySpan<number>, style: NumberStyles, provider: IFormatProvider, out result: Half): boolean {
            throw new Error("not yet implemented");
        }
        public static Parse(utf8Text: ReadOnlySpan<number>, provider: IFormatProvider): Half {
            throw new Error("not yet implemented");
        }
        public static TryParse(utf8Text: ReadOnlySpan<number>, provider: IFormatProvider, out result: Half): boolean {
            throw new Error("not yet implemented");
        }
        private static System_IBinaryFloatParseAndFormatInfo__System_Half___BitsToFloat(bits: number): Half {
            throw new Error("not yet implemented");
        }
        private static System_IBinaryFloatParseAndFormatInfo__System_Half___FloatToBits(value: Half): number {
            throw new Error("not yet implemented");
        }
    }
    export class Signature {
        private m_arguments: RuntimeType[];
        private m_declaringType: RuntimeType;
        private m_returnTypeORfieldType: RuntimeType;
        private m_keepalive: any;
        private m_sig: void*;
        private m_managedCallingConventionAndArgIteratorFlags: number;
        private m_nSizeOfArgStack: number;
        private m_csig: number;
        private m_pMethod: RuntimeMethodHandleInternal;

        private get CallingConvention(): CallingConventions {
            throw new Error("not yet implemented");
        }
        private get Arguments(): RuntimeType[] {
            throw new Error("not yet implemented");
        }
        private get ReturnType(): RuntimeType {
            throw new Error("not yet implemented");
        }
        private get FieldType(): RuntimeType {
            throw new Error("not yet implemented");
        }

        public constructor(method: IRuntimeMethodInfo, arguments: RuntimeType[], returnType: RuntimeType, callingConvention: CallingConventions) {
            throw new Error("not yet implemented");
        }
        public constructor(methodHandle: IRuntimeMethodInfo, declaringType: RuntimeType) {
            throw new Error("not yet implemented");
        }
        public constructor(fieldHandle: IRuntimeFieldInfo, declaringType: RuntimeType) {
            throw new Error("not yet implemented");
        }
        public constructor(pCorSig: void*, cCorSig: number, declaringType: RuntimeType) {
            throw new Error("not yet implemented");
        }

        private GetSignature(pCorSig: void*, cCorSig: number, fieldHandle: RuntimeFieldHandleInternal, methodHandle: IRuntimeMethodInfo, declaringType: RuntimeType) {
            throw new Error("not yet implemented");
        }
        private static CompareSig(sig1: Signature, sig2: Signature): boolean {
            throw new Error("not yet implemented");
        }
        private GetCustomModifiers(parameterIndex: number, required: boolean): Type[] {
            throw new Error("not yet implemented");
        }
        private GetParameterOffset(parameterIndex: number): number {
            throw new Error("not yet implemented");
        }
        private GetTypeParameterOffset(offset: number, index: number): number {
            throw new Error("not yet implemented");
        }
        private GetCallingConventionFromFunctionPointerAtOffset(offset: number): SignatureCallingConvention {
            throw new Error("not yet implemented");
        }
        private GetCustomModifiersAtOffset(offset: number, required: boolean): Type[] {
            throw new Error("not yet implemented");
        }
    }
    export abstract class Resolver {
        protected constructor() {
            throw new Error("not yet implemented");
        }

        private GetJitContext(out securityControlFlags: number): RuntimeType;
        private GetCodeInfo(out stackSize: number, out initLocals: number, out EHCount: number): number[];
        private GetLocalsSignature(): number[];
        private GetEHInfo(EHNumber: number, exception: void*): void;
        private GetRawEHInfo(): number[];
        private GetStringLiteral(token: number): string;
        private ResolveToken(token: number, out typeHandle: number, out methodHandle: number, out fieldHandle: number): void;
        private ResolveSignature(token: number, fromMethod: number): number[];
        private GetDynamicMethod(): MethodInfo;
    }
    export namespace Resolver {
        export class CORINFO_EH_CLAUSE extends ValueType {
            private Flags: number;
            private TryOffset: number;
            private TryLength: number;
            private HandlerOffset: number;
            private HandlerLength: number;
            private ClassTokenOrFilterOffset: number;

        }
    }
    export class ModuleHandle extends ValueType implements IEquatable<ModuleHandle> {
        public static readonly EmptyHandle: ModuleHandle;

        private m_ptr: RuntimeModule;

        public get MDStreamVersion(): number {
            throw new Error("not yet implemented");
        }

        protected constructor(module: RuntimeModule) {
            throw new Error("not yet implemented");
        }

        private GetRuntimeModule(): RuntimeModule {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public Equals(handle: ModuleHandle): boolean {
            throw new Error("not yet implemented");
        }
        private static GetDynamicMethod(method: DynamicMethod, module: RuntimeModule, name: string, sig: number[], resolver: Resolver): IRuntimeMethodInfo {
            throw new Error("not yet implemented");
        }
        private static GetToken(module: RuntimeModule): number {
            throw new Error("not yet implemented");
        }
        private static ValidateModulePointer(module: RuntimeModule) {
            throw new Error("not yet implemented");
        }
        public GetRuntimeTypeHandleFromMetadataToken(typeToken: number): RuntimeTypeHandle {
            throw new Error("not yet implemented");
        }
        public ResolveTypeHandle(typeToken: number): RuntimeTypeHandle {
            throw new Error("not yet implemented");
        }
        public ResolveTypeHandle(typeToken: number, typeInstantiationContext: RuntimeTypeHandle[], methodInstantiationContext: RuntimeTypeHandle[]): RuntimeTypeHandle {
            throw new Error("not yet implemented");
        }
        private static ResolveType(module: QCallModule, typeToken: number, typeInstArgs: number*, typeInstCount: number, methodInstArgs: number*, methodInstCount: number, type: ObjectHandleOnStack) {
            throw new Error("not yet implemented");
        }
        public GetRuntimeMethodHandleFromMetadataToken(methodToken: number): RuntimeMethodHandle {
            throw new Error("not yet implemented");
        }
        public ResolveMethodHandle(methodToken: number): RuntimeMethodHandle {
            throw new Error("not yet implemented");
        }
        public ResolveMethodHandle(methodToken: number, typeInstantiationContext: RuntimeTypeHandle[], methodInstantiationContext: RuntimeTypeHandle[]): RuntimeMethodHandle {
            throw new Error("not yet implemented");
        }
        private static ResolveMethodHandleInternal(module: RuntimeModule, methodToken: number, typeInstantiationContext: ReadOnlySpan<number>, methodInstantiationContext: ReadOnlySpan<number>): RuntimeMethodHandleInternal {
            throw new Error("not yet implemented");
        }
        private static ResolveMethod(module: QCallModule, methodToken: number, typeInstArgs: number*, typeInstCount: number, methodInstArgs: number*, methodInstCount: number): RuntimeMethodHandleInternal {
            throw new Error("not yet implemented");
        }
        public GetRuntimeFieldHandleFromMetadataToken(fieldToken: number): RuntimeFieldHandle {
            throw new Error("not yet implemented");
        }
        public ResolveFieldHandle(fieldToken: number): RuntimeFieldHandle {
            throw new Error("not yet implemented");
        }
        public ResolveFieldHandle(fieldToken: number, typeInstantiationContext: RuntimeTypeHandle[], methodInstantiationContext: RuntimeTypeHandle[]): RuntimeFieldHandle {
            throw new Error("not yet implemented");
        }
        private static ResolveField(module: QCallModule, fieldToken: number, typeInstArgs: number*, typeInstCount: number, methodInstArgs: number*, methodInstCount: number, retField: ObjectHandleOnStack) {
            throw new Error("not yet implemented");
        }
        private static GetModuleType(handle: QCallModule, type: ObjectHandleOnStack) {
            throw new Error("not yet implemented");
        }
        private static GetModuleType(module: RuntimeModule): RuntimeType {
            throw new Error("not yet implemented");
        }
        private static GetPEKind(handle: QCallModule, peKind: number*, machine: number*) {
            throw new Error("not yet implemented");
        }
        private static GetPEKind(module: RuntimeModule, out peKind: PortableExecutableKinds, out machine: ImageFileMachine) {
            throw new Error("not yet implemented");
        }
        private static GetMDStreamVersion(module: RuntimeModule): number {
            throw new Error("not yet implemented");
        }
        private static _GetMetadataImport(module: RuntimeModule): number {
            throw new Error("not yet implemented");
        }
        private static GetMetadataImport(module: RuntimeModule): MetadataImport {
            throw new Error("not yet implemented");
        }
        private static __ValidateModulePointer__g__ThrowInvalidOperationException_11_0() {
            throw new Error("not yet implemented");
        }
    }
    export enum StringComparison {
        CurrentCulture = 0,
        CurrentCultureIgnoreCase = 1,
        InvariantCulture = 2,
        InvariantCultureIgnoreCase = 3,
        Ordinal = 4,
        OrdinalIgnoreCase = 5,
    }
    export class TypedReference extends ValueType {
        private _value: number;
        private _type: number;

        private get IsNull(): boolean {
            throw new Error("not yet implemented");
        }

        public static ToObject(value: TypedReference): any {
            throw new Error("not yet implemented");
        }
        public static MakeTypedReference(target: any, flds: FieldInfo[]): TypedReference {
            throw new Error("not yet implemented");
        }
        private static InternalMakeTypedReference(result: void*, target: any, flds: number[], lastFieldType: RuntimeType) {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public Equals(o: any): boolean {
            throw new Error("not yet implemented");
        }
        public static GetTargetType(value: TypedReference): Type {
            throw new Error("not yet implemented");
        }
        public static TargetTypeToken(value: TypedReference): RuntimeTypeHandle {
            throw new Error("not yet implemented");
        }
        public static SetTypedReference(target: TypedReference, value: any) {
            throw new Error("not yet implemented");
        }
    }
    export class RuntimeFieldHandle extends ValueType implements IEquatable<RuntimeFieldHandle>, ISerializable {
        private m_ptr: IRuntimeFieldInfo;

        public get Value(): number {
            throw new Error("not yet implemented");
        }

        protected constructor(fieldInfo: IRuntimeFieldInfo) {
            throw new Error("not yet implemented");
        }

        private GetRuntimeFieldInfo(): IRuntimeFieldInfo {
            throw new Error("not yet implemented");
        }
        private IsNullHandle(): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public Equals(handle: RuntimeFieldHandle): boolean {
            throw new Error("not yet implemented");
        }
        public static FromIntPtr(value: number): RuntimeFieldHandle {
            throw new Error("not yet implemented");
        }
        public static ToIntPtr(value: RuntimeFieldHandle): number {
            throw new Error("not yet implemented");
        }
        private static GetName(field: RtFieldInfo): string {
            throw new Error("not yet implemented");
        }
        private static _GetUtf8Name(field: RuntimeFieldHandleInternal): void* {
            throw new Error("not yet implemented");
        }
        private static GetUtf8Name(field: RuntimeFieldHandleInternal): MdUtf8String {
            throw new Error("not yet implemented");
        }
        private static GetAttributes(field: RuntimeFieldHandleInternal): FieldAttributes {
            throw new Error("not yet implemented");
        }
        private static GetApproxDeclaringType(field: RuntimeFieldHandleInternal): RuntimeType {
            throw new Error("not yet implemented");
        }
        private static GetApproxDeclaringType(field: IRuntimeFieldInfo): RuntimeType {
            throw new Error("not yet implemented");
        }
        private static GetToken(field: RtFieldInfo): number {
            throw new Error("not yet implemented");
        }
        private static GetValue(field: RtFieldInfo, instance: any, fieldType: RuntimeType, declaringType: RuntimeType, ref domainInitialized: boolean): any {
            throw new Error("not yet implemented");
        }
        private static GetValueDirect(field: RtFieldInfo, fieldType: RuntimeType, pTypedRef: void*, contextType: RuntimeType): any {
            throw new Error("not yet implemented");
        }
        private static SetValue(field: RtFieldInfo, obj: any, value: any, fieldType: RuntimeType, fieldAttr: FieldAttributes, declaringType: RuntimeType, ref domainInitialized: boolean) {
            throw new Error("not yet implemented");
        }
        private static SetValueDirect(field: RtFieldInfo, fieldType: RuntimeType, pTypedRef: void*, value: any, contextType: RuntimeType) {
            throw new Error("not yet implemented");
        }
        private static GetStaticFieldForGenericType(field: RuntimeFieldHandleInternal, declaringType: RuntimeType): RuntimeFieldHandleInternal {
            throw new Error("not yet implemented");
        }
        private static AcquiresContextFromThis(field: RuntimeFieldHandleInternal): boolean {
            throw new Error("not yet implemented");
        }
        private static GetLoaderAllocator(method: RuntimeFieldHandleInternal): LoaderAllocator {
            throw new Error("not yet implemented");
        }
        public GetObjectData(info: SerializationInfo, context: StreamingContext) {
            throw new Error("not yet implemented");
        }
    }
    export enum MemberListType {
        All = 0,
        CaseSensitive = 1,
        CaseInsensitive = 2,
        HandleToInfo = 3,
    }
    export class Filter extends ValueType {
        private m_name: MdUtf8String;
        private m_listType: MemberListType;

        public constructor(pUtf8Name: number*, cUtf8Name: number, listType: MemberListType) {
            throw new Error("not yet implemented");
        }

        public Match(name: MdUtf8String): boolean {
            throw new Error("not yet implemented");
        }
        public RequiresStringComparison(): boolean {
            throw new Error("not yet implemented");
        }
        public CaseSensitive(): boolean {
            throw new Error("not yet implemented");
        }
    }
    export class ListBuilder<T> extends ValueType {
        private _items: T[];
        private _item: T;
        private _count: number;
        private _capacity: number;

        public get Item(): T {
            throw new Error("not yet implemented");
        }
        public get Count(): number {
            throw new Error("not yet implemented");
        }

        public constructor(capacity: number) {
            throw new Error("not yet implemented");
        }

        public ToArray(): T[] {
            throw new Error("not yet implemented");
        }
        public CopyTo(array: any[], index: number) {
            throw new Error("not yet implemented");
        }
        public Add(item: T) {
            throw new Error("not yet implemented");
        }
    }
    export class MemberInfoCache<T> {
        private m_csMemberInfos: CerHashtable<string, T[]>;
        private m_cisMemberInfos: CerHashtable<string, T[]>;
        private m_allMembers: T[];
        private m_cacheComplete: boolean;
        private m_runtimeTypeCache: RuntimeTypeCache;

        private get ReflectedType(): RuntimeType {
            throw new Error("not yet implemented");
        }

        protected constructor(runtimeTypeCache: RuntimeTypeCache) {
            throw new Error("not yet implemented");
        }

        private AddMethod(declaringType: RuntimeType, method: RuntimeMethodHandleInternal, cacheType: CacheType): MethodBase {
            throw new Error("not yet implemented");
        }
        private AddField(field: RuntimeFieldHandleInternal): FieldInfo {
            throw new Error("not yet implemented");
        }
        private Populate(name: string, listType: MemberListType, cacheType: CacheType): T[] {
            throw new Error("not yet implemented");
        }
        private GetListByName(pName: string*, cNameLen: number, pUtf8Name: number*, cUtf8Name: number, listType: MemberListType, cacheType: CacheType): T[] {
            throw new Error("not yet implemented");
        }
        private Insert(ref list: T[], name: string, listType: MemberListType) {
            throw new Error("not yet implemented");
        }
        private MergeWithGlobalListInOrder(list: T[]) {
            throw new Error("not yet implemented");
        }
        private MergeWithGlobalList(list: T[]) {
            throw new Error("not yet implemented");
        }
        private PopulateMethods(filter: Filter): RuntimeMethodInfo[] {
            throw new Error("not yet implemented");
        }
        private PopulateConstructors(filter: Filter): RuntimeConstructorInfo[] {
            throw new Error("not yet implemented");
        }
        private PopulateFields(filter: Filter): RuntimeFieldInfo[] {
            throw new Error("not yet implemented");
        }
        private PopulateRtFields(filter: Filter, declaringType: RuntimeType, ref list: ListBuilder<RuntimeFieldInfo>) {
            throw new Error("not yet implemented");
        }
        private PopulateRtFields(filter: Filter, ppFieldHandles: number*, count: number, declaringType: RuntimeType, ref list: ListBuilder<RuntimeFieldInfo>) {
            throw new Error("not yet implemented");
        }
        private PopulateLiteralFields(filter: Filter, declaringType: RuntimeType, ref list: ListBuilder<RuntimeFieldInfo>) {
            throw new Error("not yet implemented");
        }
        private AddSpecialInterface(ref list: ListBuilder<RuntimeType>, filter: Filter, iList: RuntimeType, addSubInterface: boolean) {
            throw new Error("not yet implemented");
        }
        private PopulateInterfaces(filter: Filter): RuntimeType[] {
            throw new Error("not yet implemented");
        }
        private PopulateNestedClasses(filter: Filter): RuntimeType[] {
            throw new Error("not yet implemented");
        }
        private PopulateEvents(filter: Filter): RuntimeEventInfo[] {
            throw new Error("not yet implemented");
        }
        private PopulateEvents(filter: Filter, declaringType: RuntimeType, csEventInfos: Dictionary<string, RuntimeEventInfo>, ref list: ListBuilder<RuntimeEventInfo>) {
            throw new Error("not yet implemented");
        }
        private PopulateProperties(filter: Filter): RuntimePropertyInfo[] {
            throw new Error("not yet implemented");
        }
        private PopulateProperties(filter: Filter, declaringType: RuntimeType, csPropertyInfos: Dictionary<string, List<RuntimePropertyInfo>>, usedSlots: Span<boolean>, isInterface: boolean, ref list: ListBuilder<RuntimePropertyInfo>) {
            throw new Error("not yet implemented");
        }
        private GetMemberList(listType: MemberListType, name: string, cacheType: CacheType): T[] {
            throw new Error("not yet implemented");
        }
    }
    export enum TypeNameFormatFlags {
        FormatBasic = 0,
        FormatNamespace = 1,
        FormatFullInst = 2,
        FormatAssembly = 4,
        FormatSignature = 8,
        FormatNoVersion = 16,
        FormatAngleBrackets = 64,
        FormatStubInfo = 128,
        FormatGenericParam = 256,
    }
    export enum TypeNameKind {
        Name = 0,
        ToString = 1,
        FullName = 2,
    }
    export class RuntimeTypeCache {
        private static s_methodInstantiations: CerHashtable<RuntimeMethodInfo, RuntimeMethodInfo>;
        private static s_methodInstantiationsLock: any;

        private m_runtimeType: RuntimeType;
        private m_enclosingType: RuntimeType;
        private m_typeCode: TypeCode;
        private m_name: string;
        private m_fullname: string;
        private m_toString: string;
        private m_namespace: string;
        private m_isGlobal: boolean;
        private m_bIsDomainInitialized: boolean;
        private m_methodInfoCache: MemberInfoCache<RuntimeMethodInfo>;
        private m_constructorInfoCache: MemberInfoCache<RuntimeConstructorInfo>;
        private m_fieldInfoCache: MemberInfoCache<RuntimeFieldInfo>;
        private m_interfaceCache: MemberInfoCache<RuntimeType>;
        private m_nestedClassesCache: MemberInfoCache<RuntimeType>;
        private m_propertyInfoCache: MemberInfoCache<RuntimePropertyInfo>;
        private m_eventInfoCache: MemberInfoCache<RuntimeEventInfo>;
        private m_defaultMemberName: string;
        private m_genericCache: any;
        private _emptyArray: any[];
        private _genericTypeDefinition: RuntimeType;

        private get GenericCache(): any {
            throw new Error("not yet implemented");
        }
        private set GenericCache(value: any) {
            throw new Error("not yet implemented");
        }
        private get FunctionPointerReturnAndParameterTypes(): Type[] {
            throw new Error("not yet implemented");
        }
        private get DomainInitialized(): boolean {
            throw new Error("not yet implemented");
        }
        private set DomainInitialized(value: boolean) {
            throw new Error("not yet implemented");
        }
        private get TypeCode(): TypeCode {
            throw new Error("not yet implemented");
        }
        private set TypeCode(value: TypeCode) {
            throw new Error("not yet implemented");
        }
        private get IsGlobal(): boolean {
            throw new Error("not yet implemented");
        }

        protected constructor(runtimeType: RuntimeType) {
            throw new Error("not yet implemented");
        }

        private ConstructName(ref name: string, formatFlags: TypeNameFormatFlags): string {
            throw new Error("not yet implemented");
        }
        private GetMemberList(ref m_cache: MemberInfoCache<T>, listType: MemberListType, name: string, cacheType: CacheType): T[] {
            throw new Error("not yet implemented");
        }
        private GetMemberCache(ref m_cache: MemberInfoCache<T>): MemberInfoCache<T> {
            throw new Error("not yet implemented");
        }
        private GetName(kind: TypeNameKind): string {
            throw new Error("not yet implemented");
        }
        private GetNameSpace(): string {
            throw new Error("not yet implemented");
        }
        private GetEnclosingType(): RuntimeType {
            throw new Error("not yet implemented");
        }
        private GetRuntimeType(): RuntimeType {
            throw new Error("not yet implemented");
        }
        private InvalidateCachedNestedType() {
            throw new Error("not yet implemented");
        }
        private GetDefaultMemberName(): string {
            throw new Error("not yet implemented");
        }
        private GetEmptyArray(): any[] {
            throw new Error("not yet implemented");
        }
        private GetGenericTypeDefinition(): RuntimeType {
            throw new Error("not yet implemented");
        }
        private GetGenericMethodInfo(genericMethod: RuntimeMethodHandleInternal): MethodInfo {
            throw new Error("not yet implemented");
        }
        private GetMethodList(listType: MemberListType, name: string): RuntimeMethodInfo[] {
            throw new Error("not yet implemented");
        }
        private GetConstructorList(listType: MemberListType, name: string): RuntimeConstructorInfo[] {
            throw new Error("not yet implemented");
        }
        private GetPropertyList(listType: MemberListType, name: string): RuntimePropertyInfo[] {
            throw new Error("not yet implemented");
        }
        private GetEventList(listType: MemberListType, name: string): RuntimeEventInfo[] {
            throw new Error("not yet implemented");
        }
        private GetFieldList(listType: MemberListType, name: string): RuntimeFieldInfo[] {
            throw new Error("not yet implemented");
        }
        private GetInterfaceList(listType: MemberListType, name: string): RuntimeType[] {
            throw new Error("not yet implemented");
        }
        private GetNestedTypeList(listType: MemberListType, name: string): RuntimeType[] {
            throw new Error("not yet implemented");
        }
        private GetMethod(declaringType: RuntimeType, method: RuntimeMethodHandleInternal): MethodBase {
            throw new Error("not yet implemented");
        }
        private GetConstructor(declaringType: RuntimeType, constructor: RuntimeMethodHandleInternal): MethodBase {
            throw new Error("not yet implemented");
        }
        private GetField(field: RuntimeFieldHandleInternal): FieldInfo {
            throw new Error("not yet implemented");
        }
        private __GetGenericTypeDefinition__g__CacheGenericDefinition_50_0(): RuntimeType {
            throw new Error("not yet implemented");
        }
    }
    export namespace RuntimeTypeCache {
        export enum CacheType {
            Method = 0,
            Constructor = 1,
            Field = 2,
            Property = 3,
            Event = 4,
            Interface = 5,
            NestedType = 6,
        }

        export class Filter extends ValueType {
            private m_name: MdUtf8String;
            private m_listType: MemberListType;

            public constructor(pUtf8Name: number*, cUtf8Name: number, listType: MemberListType) {
                throw new Error("not yet implemented");
            }

            public Match(name: MdUtf8String): boolean {
                throw new Error("not yet implemented");
            }
            public RequiresStringComparison(): boolean {
                throw new Error("not yet implemented");
            }
            public CaseSensitive(): boolean {
                throw new Error("not yet implemented");
            }
        }

        export class MemberInfoCache<T> {
            private m_csMemberInfos: CerHashtable<string, T[]>;
            private m_cisMemberInfos: CerHashtable<string, T[]>;
            private m_allMembers: T[];
            private m_cacheComplete: boolean;
            private m_runtimeTypeCache: RuntimeTypeCache;

            private get ReflectedType(): RuntimeType {
                throw new Error("not yet implemented");
            }

            protected constructor(runtimeTypeCache: RuntimeTypeCache) {
                throw new Error("not yet implemented");
            }

            private AddMethod(declaringType: RuntimeType, method: RuntimeMethodHandleInternal, cacheType: CacheType): MethodBase {
                throw new Error("not yet implemented");
            }
            private AddField(field: RuntimeFieldHandleInternal): FieldInfo {
                throw new Error("not yet implemented");
            }
            private Populate(name: string, listType: MemberListType, cacheType: CacheType): T[] {
                throw new Error("not yet implemented");
            }
            private GetListByName(pName: string*, cNameLen: number, pUtf8Name: number*, cUtf8Name: number, listType: MemberListType, cacheType: CacheType): T[] {
                throw new Error("not yet implemented");
            }
            private Insert(ref list: T[], name: string, listType: MemberListType) {
                throw new Error("not yet implemented");
            }
            private MergeWithGlobalListInOrder(list: T[]) {
                throw new Error("not yet implemented");
            }
            private MergeWithGlobalList(list: T[]) {
                throw new Error("not yet implemented");
            }
            private PopulateMethods(filter: Filter): RuntimeMethodInfo[] {
                throw new Error("not yet implemented");
            }
            private PopulateConstructors(filter: Filter): RuntimeConstructorInfo[] {
                throw new Error("not yet implemented");
            }
            private PopulateFields(filter: Filter): RuntimeFieldInfo[] {
                throw new Error("not yet implemented");
            }
            private PopulateRtFields(filter: Filter, declaringType: RuntimeType, ref list: ListBuilder<RuntimeFieldInfo>) {
                throw new Error("not yet implemented");
            }
            private PopulateRtFields(filter: Filter, ppFieldHandles: number*, count: number, declaringType: RuntimeType, ref list: ListBuilder<RuntimeFieldInfo>) {
                throw new Error("not yet implemented");
            }
            private PopulateLiteralFields(filter: Filter, declaringType: RuntimeType, ref list: ListBuilder<RuntimeFieldInfo>) {
                throw new Error("not yet implemented");
            }
            private AddSpecialInterface(ref list: ListBuilder<RuntimeType>, filter: Filter, iList: RuntimeType, addSubInterface: boolean) {
                throw new Error("not yet implemented");
            }
            private PopulateInterfaces(filter: Filter): RuntimeType[] {
                throw new Error("not yet implemented");
            }
            private PopulateNestedClasses(filter: Filter): RuntimeType[] {
                throw new Error("not yet implemented");
            }
            private PopulateEvents(filter: Filter): RuntimeEventInfo[] {
                throw new Error("not yet implemented");
            }
            private PopulateEvents(filter: Filter, declaringType: RuntimeType, csEventInfos: Dictionary<string, RuntimeEventInfo>, ref list: ListBuilder<RuntimeEventInfo>) {
                throw new Error("not yet implemented");
            }
            private PopulateProperties(filter: Filter): RuntimePropertyInfo[] {
                throw new Error("not yet implemented");
            }
            private PopulateProperties(filter: Filter, declaringType: RuntimeType, csPropertyInfos: Dictionary<string, List<RuntimePropertyInfo>>, usedSlots: Span<boolean>, isInterface: boolean, ref list: ListBuilder<RuntimePropertyInfo>) {
                throw new Error("not yet implemented");
            }
            private GetMemberList(listType: MemberListType, name: string, cacheType: CacheType): T[] {
                throw new Error("not yet implemented");
            }
        }
    }
    export enum DelegateBindingFlags {
        StaticMethodOnly = 1,
        InstanceMethodOnly = 2,
        OpenDelegateOnly = 4,
        ClosedDelegateOnly = 8,
        NeverCloseOverNull = 16,
        CaselessMatching = 32,
        RelaxedSignature = 64,
    }
    export abstract class Delegate implements ICloneable, ISerializable {
        private _target: any;
        private _methodBase: any;
        private _methodPtr: number;
        private _methodPtrAux: number;

        public get Target(): any {
            throw new Error("not yet implemented");
        }
        public get Method(): MethodInfo {
            throw new Error("not yet implemented");
        }

        protected constructor(target: any, method: string) {
            throw new Error("not yet implemented");
        }
        protected constructor(target: Type, method: string) {
            throw new Error("not yet implemented");
        }

        private DynamicInvokeImpl(args: any[]): any {
            throw new Error("not yet implemented");
        }
        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        private GetMethodImpl(): MethodInfo {
            throw new Error("not yet implemented");
        }
        public static CreateDelegate(type: Type, target: any, method: string, ignoreCase: boolean, throwOnBindFailure: boolean): Delegate {
            throw new Error("not yet implemented");
        }
        public static CreateDelegate(type: Type, target: Type, method: string, ignoreCase: boolean, throwOnBindFailure: boolean): Delegate {
            throw new Error("not yet implemented");
        }
        public static CreateDelegate(type: Type, method: MethodInfo, throwOnBindFailure: boolean): Delegate {
            throw new Error("not yet implemented");
        }
        public static CreateDelegate(type: Type, firstArgument: any, method: MethodInfo, throwOnBindFailure: boolean): Delegate {
            throw new Error("not yet implemented");
        }
        private static CreateDelegateNoSecurityCheck(type: Type, target: any, method: RuntimeMethodHandle): Delegate {
            throw new Error("not yet implemented");
        }
        private static CreateDelegateInternal(rtType: RuntimeType, rtMethod: RuntimeMethodInfo, firstArgument: any, flags: DelegateBindingFlags): Delegate {
            throw new Error("not yet implemented");
        }
        private BindToMethodName(target: any, methodType: RuntimeType, method: string, flags: DelegateBindingFlags): boolean {
            throw new Error("not yet implemented");
        }
        private BindToMethodInfo(target: any, method: IRuntimeMethodInfo, methodType: RuntimeType, flags: DelegateBindingFlags): boolean {
            throw new Error("not yet implemented");
        }
        private static InternalAlloc(type: RuntimeType): MulticastDelegate {
            throw new Error("not yet implemented");
        }
        private static InternalAllocLike(d: Delegate): MulticastDelegate {
            throw new Error("not yet implemented");
        }
        private static InternalEqualTypes(a: any, b: any): boolean {
            throw new Error("not yet implemented");
        }
        private DelegateConstruct(target: any, slot: number) {
            throw new Error("not yet implemented");
        }
        private GetMulticastInvoke(): number {
            throw new Error("not yet implemented");
        }
        private GetInvokeMethod(): number {
            throw new Error("not yet implemented");
        }
        private FindMethodHandle(): IRuntimeMethodInfo {
            throw new Error("not yet implemented");
        }
        private static InternalEqualMethodHandles(left: Delegate, right: Delegate): boolean {
            throw new Error("not yet implemented");
        }
        private AdjustTarget(target: any, methodPtr: number): number {
            throw new Error("not yet implemented");
        }
        private GetCallStub(methodPtr: number): number {
            throw new Error("not yet implemented");
        }
        private GetTarget(): any {
            throw new Error("not yet implemented");
        }
        public Clone(): any {
            throw new Error("not yet implemented");
        }
        public static Combine(a: Delegate, b: Delegate): Delegate {
            throw new Error("not yet implemented");
        }
        public static Combine(delegates: Delegate[]): Delegate {
            throw new Error("not yet implemented");
        }
        public static CreateDelegate(type: Type, firstArgument: any, method: MethodInfo): Delegate {
            throw new Error("not yet implemented");
        }
        public static CreateDelegate(type: Type, method: MethodInfo): Delegate {
            throw new Error("not yet implemented");
        }
        public static CreateDelegate(type: Type, target: any, method: string): Delegate {
            throw new Error("not yet implemented");
        }
        public static CreateDelegate(type: Type, target: any, method: string, ignoreCase: boolean): Delegate {
            throw new Error("not yet implemented");
        }
        public static CreateDelegate(type: Type, target: Type, method: string): Delegate {
            throw new Error("not yet implemented");
        }
        public static CreateDelegate(type: Type, target: Type, method: string, ignoreCase: boolean): Delegate {
            throw new Error("not yet implemented");
        }
        private CombineImpl(d: Delegate): Delegate {
            throw new Error("not yet implemented");
        }
        private RemoveImpl(d: Delegate): Delegate {
            throw new Error("not yet implemented");
        }
        public GetInvocationList(): Delegate[] {
            throw new Error("not yet implemented");
        }
        public DynamicInvoke(args: any[]): any {
            throw new Error("not yet implemented");
        }
        public GetObjectData(info: SerializationInfo, context: StreamingContext) {
            throw new Error("not yet implemented");
        }
        public static Remove(source: Delegate, value: Delegate): Delegate {
            throw new Error("not yet implemented");
        }
        public static RemoveAll(source: Delegate, value: Delegate): Delegate {
            throw new Error("not yet implemented");
        }
    }
    export abstract class MulticastDelegate extends Delegate implements ICloneable, ISerializable {
        private _invocationList: any;
        private _invocationCount: number;

        protected constructor(target: any, method: string) {
            throw new Error("not yet implemented");
        }
        protected constructor(target: Type, method: string) {
            throw new Error("not yet implemented");
        }

        private IsUnmanagedFunctionPtr(): boolean {
            throw new Error("not yet implemented");
        }
        private InvocationListLogicallyNull(): boolean {
            throw new Error("not yet implemented");
        }
        public GetObjectData(info: SerializationInfo, context: StreamingContext) {
            throw new Error("not yet implemented");
        }
        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        private InvocationListEquals(d: MulticastDelegate): boolean {
            throw new Error("not yet implemented");
        }
        private static TrySetSlot(a: any[], index: number, o: any): boolean {
            throw new Error("not yet implemented");
        }
        private NewMulticastDelegate(invocationList: any[], invocationCount: number, thisIsMultiCastAlready: boolean): MulticastDelegate {
            throw new Error("not yet implemented");
        }
        private NewMulticastDelegate(invocationList: any[], invocationCount: number): MulticastDelegate {
            throw new Error("not yet implemented");
        }
        private StoreDynamicMethod(dynamicMethod: MethodInfo) {
            throw new Error("not yet implemented");
        }
        private CombineImpl(follow: Delegate): Delegate {
            throw new Error("not yet implemented");
        }
        private DeleteFromInvocationList(invocationList: any[], invocationCount: number, deleteIndex: number, deleteCount: number): any[] {
            throw new Error("not yet implemented");
        }
        private static EqualInvocationLists(a: any[], b: any[], start: number, count: number): boolean {
            throw new Error("not yet implemented");
        }
        private RemoveImpl(value: Delegate): Delegate {
            throw new Error("not yet implemented");
        }
        public GetInvocationList(): Delegate[] {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        private GetTarget(): any {
            throw new Error("not yet implemented");
        }
        private GetMethodImpl(): MethodInfo {
            throw new Error("not yet implemented");
        }
        private static ThrowNullThisInDelegateToInstance() {
            throw new Error("not yet implemented");
        }
        private CtorClosed(target: any, methodPtr: number) {
            throw new Error("not yet implemented");
        }
        private CtorClosedStatic(target: any, methodPtr: number) {
            throw new Error("not yet implemented");
        }
        private CtorRTClosed(target: any, methodPtr: number) {
            throw new Error("not yet implemented");
        }
        private CtorOpened(target: any, methodPtr: number, shuffleThunk: number) {
            throw new Error("not yet implemented");
        }
        private CtorVirtualDispatch(target: any, methodPtr: number, shuffleThunk: number) {
            throw new Error("not yet implemented");
        }
        private CtorCollectibleClosedStatic(target: any, methodPtr: number, gchandle: number) {
            throw new Error("not yet implemented");
        }
        private CtorCollectibleOpened(target: any, methodPtr: number, shuffleThunk: number, gchandle: number) {
            throw new Error("not yet implemented");
        }
        private CtorCollectibleVirtualDispatch(target: any, methodPtr: number, shuffleThunk: number, gchandle: number) {
            throw new Error("not yet implemented");
        }
    }
    export class Converter<TInput, TOutput> extends MulticastDelegate implements ICloneable, ISerializable {
        public constructor(object: any, method: number) {
            throw new Error("not yet implemented");
        }

        public Invoke(input: TInput): TOutput {
            throw new Error("not yet implemented");
        }
        public BeginInvoke(input: TInput, callback: AsyncCallback, object: any): IAsyncResult {
            throw new Error("not yet implemented");
        }
        public EndInvoke(result: IAsyncResult): TOutput {
            throw new Error("not yet implemented");
        }
    }
    export class Predicate<T> extends MulticastDelegate implements ICloneable, ISerializable {
        public constructor(object: any, method: number) {
            throw new Error("not yet implemented");
        }

        public Invoke(obj: T): boolean {
            throw new Error("not yet implemented");
        }
        public BeginInvoke(obj: T, callback: AsyncCallback, object: any): IAsyncResult {
            throw new Error("not yet implemented");
        }
        public EndInvoke(result: IAsyncResult): boolean {
            throw new Error("not yet implemented");
        }
    }
    export class Comparison<T> extends MulticastDelegate implements ICloneable, ISerializable {
        public constructor(object: any, method: number) {
            throw new Error("not yet implemented");
        }

        public Invoke(x: T, y: T): number {
            throw new Error("not yet implemented");
        }
        public BeginInvoke(x: T, y: T, callback: AsyncCallback, object: any): IAsyncResult {
            throw new Error("not yet implemented");
        }
        public EndInvoke(result: IAsyncResult): number {
            throw new Error("not yet implemented");
        }
    }
    export class IntroducedMethodEnumerator extends ValueType {
        private _firstCall: boolean;
        private _handle: RuntimeMethodHandleInternal;

        public get Current(): RuntimeMethodHandleInternal {
            throw new Error("not yet implemented");
        }

        protected constructor(type: RuntimeType) {
            throw new Error("not yet implemented");
        }

        public MoveNext(): boolean {
            throw new Error("not yet implemented");
        }
        public GetEnumerator(): IntroducedMethodEnumerator {
            throw new Error("not yet implemented");
        }
    }
    export class RuntimeTypeHandle extends ValueType implements IEquatable<RuntimeTypeHandle>, ISerializable {
        private m_type: RuntimeType;

        public get Value(): number {
            throw new Error("not yet implemented");
        }

        protected constructor(type: RuntimeType) {
            throw new Error("not yet implemented");
        }

        private GetNativeHandle(): RuntimeTypeHandle {
            throw new Error("not yet implemented");
        }
        private GetTypeChecked(): RuntimeType {
            throw new Error("not yet implemented");
        }
        private static IsInstanceOfType(type: RuntimeType, o: any): boolean {
            throw new Error("not yet implemented");
        }
        public static FromIntPtr(value: number): RuntimeTypeHandle {
            throw new Error("not yet implemented");
        }
        public static ToIntPtr(value: RuntimeTypeHandle): number {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public Equals(handle: RuntimeTypeHandle): boolean {
            throw new Error("not yet implemented");
        }
        private static IsTypeDefinition(type: RuntimeType): boolean {
            throw new Error("not yet implemented");
        }
        private static IsPrimitive(type: RuntimeType): boolean {
            throw new Error("not yet implemented");
        }
        private static IsByRef(type: RuntimeType): boolean {
            throw new Error("not yet implemented");
        }
        private static IsPointer(type: RuntimeType): boolean {
            throw new Error("not yet implemented");
        }
        private static IsArray(type: RuntimeType): boolean {
            throw new Error("not yet implemented");
        }
        private static IsSZArray(type: RuntimeType): boolean {
            throw new Error("not yet implemented");
        }
        private static IsFunctionPointer(type: RuntimeType): boolean {
            throw new Error("not yet implemented");
        }
        private static HasElementType(type: RuntimeType): boolean {
            throw new Error("not yet implemented");
        }
        private static CopyRuntimeTypeHandles(inHandles: RuntimeTypeHandle[], stackScratch: Span<number>): ReadOnlySpan<number> {
            throw new Error("not yet implemented");
        }
        private static CopyRuntimeTypeHandles(inHandles: Type[], out length: number): number[] {
            throw new Error("not yet implemented");
        }
        private static CreateInstanceForAnotherGenericParameter(type: RuntimeType, genericParameter: RuntimeType): any {
            throw new Error("not yet implemented");
        }
        private static CreateInstanceForAnotherGenericParameter(type: RuntimeType, genericParameter1: RuntimeType, genericParameter2: RuntimeType): any {
            throw new Error("not yet implemented");
        }
        private static CreateInstanceForAnotherGenericParameter(baseType: QCallTypeHandle, pTypeHandles: number*, cTypeHandles: number, instantiatedObject: ObjectHandleOnStack) {
            throw new Error("not yet implemented");
        }
        private static GetActivationInfo(rt: RuntimeType, out pfnAllocator: _, out vAllocatorFirstArg: Void*, out pfnCtor: _, out ctorIsPublic: boolean) {
            throw new Error("not yet implemented");
        }
        private static GetActivationInfo(pRuntimeType: ObjectHandleOnStack, ppfnAllocator: _*, pvAllocatorFirstArg: Void**, ppfnCtor: _*, pfCtorIsPublic: BOOL*) {
            throw new Error("not yet implemented");
        }
        private static AllocateComObject(pClassFactory: void*): any {
            throw new Error("not yet implemented");
        }
        private GetRuntimeType(): RuntimeType {
            throw new Error("not yet implemented");
        }
        private static GetCorElementType(type: RuntimeType): CorElementType {
            throw new Error("not yet implemented");
        }
        private static GetAssembly(type: RuntimeType): RuntimeAssembly {
            throw new Error("not yet implemented");
        }
        private static GetModule(type: RuntimeType): RuntimeModule {
            throw new Error("not yet implemented");
        }
        public GetModuleHandle(): ModuleHandle {
            throw new Error("not yet implemented");
        }
        private static GetBaseType(type: RuntimeType): RuntimeType {
            throw new Error("not yet implemented");
        }
        private static GetAttributes(type: RuntimeType): TypeAttributes {
            throw new Error("not yet implemented");
        }
        private static GetElementType(type: RuntimeType): RuntimeType {
            throw new Error("not yet implemented");
        }
        private static CompareCanonicalHandles(left: RuntimeType, right: RuntimeType): boolean {
            throw new Error("not yet implemented");
        }
        private static GetArrayRank(type: RuntimeType): number {
            throw new Error("not yet implemented");
        }
        private static GetToken(type: RuntimeType): number {
            throw new Error("not yet implemented");
        }
        private static GetMethodAt(type: RuntimeType, slot: number): RuntimeMethodHandleInternal {
            throw new Error("not yet implemented");
        }
        private static GetArgumentTypesFromFunctionPointer(type: RuntimeType): Type[] {
            throw new Error("not yet implemented");
        }
        private static IsUnmanagedFunctionPointer(type: RuntimeType): boolean {
            throw new Error("not yet implemented");
        }
        private static GetIntroducedMethods(type: RuntimeType): IntroducedMethodEnumerator {
            throw new Error("not yet implemented");
        }
        private static GetFirstIntroducedMethod(type: RuntimeType): RuntimeMethodHandleInternal {
            throw new Error("not yet implemented");
        }
        private static GetNextIntroducedMethod(ref method: RuntimeMethodHandleInternal) {
            throw new Error("not yet implemented");
        }
        private static GetFields(type: RuntimeType, result: number*, count: number*): boolean {
            throw new Error("not yet implemented");
        }
        private static GetInterfaces(type: RuntimeType): Type[] {
            throw new Error("not yet implemented");
        }
        private static GetConstraints(handle: QCallTypeHandle, types: ObjectHandleOnStack) {
            throw new Error("not yet implemented");
        }
        private GetConstraints(): Type[] {
            throw new Error("not yet implemented");
        }
        private static GetGCHandle(handle: QCallTypeHandle, type: GCHandleType): number {
            throw new Error("not yet implemented");
        }
        private GetGCHandle(type: GCHandleType): number {
            throw new Error("not yet implemented");
        }
        private static FreeGCHandle(typeHandle: QCallTypeHandle, objHandle: number): number {
            throw new Error("not yet implemented");
        }
        private FreeGCHandle(objHandle: number): number {
            throw new Error("not yet implemented");
        }
        private static GetNumVirtuals(type: RuntimeType): number {
            throw new Error("not yet implemented");
        }
        private static GetNumVirtualsAndStaticVirtuals(type: RuntimeType): number {
            throw new Error("not yet implemented");
        }
        private static VerifyInterfaceIsImplemented(handle: QCallTypeHandle, interfaceHandle: QCallTypeHandle) {
            throw new Error("not yet implemented");
        }
        private VerifyInterfaceIsImplemented(interfaceHandle: RuntimeTypeHandle) {
            throw new Error("not yet implemented");
        }
        private static GetInterfaceMethodImplementation(handle: QCallTypeHandle, interfaceHandle: QCallTypeHandle, interfaceMethodHandle: RuntimeMethodHandleInternal): RuntimeMethodHandleInternal {
            throw new Error("not yet implemented");
        }
        private GetInterfaceMethodImplementation(interfaceHandle: RuntimeTypeHandle, interfaceMethodHandle: RuntimeMethodHandleInternal): RuntimeMethodHandleInternal {
            throw new Error("not yet implemented");
        }
        private static IsComObject(type: RuntimeType, isGenericCOM: boolean): boolean {
            throw new Error("not yet implemented");
        }
        private static IsInterface(type: RuntimeType): boolean {
            throw new Error("not yet implemented");
        }
        private static IsByRefLike(type: RuntimeType): boolean {
            throw new Error("not yet implemented");
        }
        private static _IsVisible(typeHandle: QCallTypeHandle): boolean {
            throw new Error("not yet implemented");
        }
        private static IsVisible(type: RuntimeType): boolean {
            throw new Error("not yet implemented");
        }
        private static IsValueType(type: RuntimeType): boolean {
            throw new Error("not yet implemented");
        }
        private static ConstructName(handle: QCallTypeHandle, formatFlags: TypeNameFormatFlags, retString: StringHandleOnStack) {
            throw new Error("not yet implemented");
        }
        private ConstructName(formatFlags: TypeNameFormatFlags): string {
            throw new Error("not yet implemented");
        }
        private static _GetUtf8Name(type: RuntimeType): void* {
            throw new Error("not yet implemented");
        }
        private static GetUtf8Name(type: RuntimeType): MdUtf8String {
            throw new Error("not yet implemented");
        }
        private static CanCastTo(type: RuntimeType, target: RuntimeType): boolean {
            throw new Error("not yet implemented");
        }
        private static GetDeclaringType(type: RuntimeType): RuntimeType {
            throw new Error("not yet implemented");
        }
        private static GetDeclaringMethod(type: RuntimeType): IRuntimeMethodInfo {
            throw new Error("not yet implemented");
        }
        private static GetInstantiation(type: QCallTypeHandle, types: ObjectHandleOnStack, fAsRuntimeTypeArray: BOOL) {
            throw new Error("not yet implemented");
        }
        private GetInstantiationInternal(): RuntimeType[] {
            throw new Error("not yet implemented");
        }
        private GetInstantiationPublic(): Type[] {
            throw new Error("not yet implemented");
        }
        private static Instantiate(handle: QCallTypeHandle, pInst: number*, numGenericArgs: number, type: ObjectHandleOnStack) {
            throw new Error("not yet implemented");
        }
        private Instantiate(inst: RuntimeType): RuntimeType {
            throw new Error("not yet implemented");
        }
        private Instantiate(inst: Type[]): RuntimeType {
            throw new Error("not yet implemented");
        }
        private static MakeArray(handle: QCallTypeHandle, rank: number, type: ObjectHandleOnStack) {
            throw new Error("not yet implemented");
        }
        private MakeArray(rank: number): RuntimeType {
            throw new Error("not yet implemented");
        }
        private static MakeSZArray(handle: QCallTypeHandle, type: ObjectHandleOnStack) {
            throw new Error("not yet implemented");
        }
        private MakeSZArray(): RuntimeType {
            throw new Error("not yet implemented");
        }
        private static MakeByRef(handle: QCallTypeHandle, type: ObjectHandleOnStack) {
            throw new Error("not yet implemented");
        }
        private MakeByRef(): RuntimeType {
            throw new Error("not yet implemented");
        }
        private static MakePointer(handle: QCallTypeHandle, type: ObjectHandleOnStack) {
            throw new Error("not yet implemented");
        }
        private MakePointer(): RuntimeType {
            throw new Error("not yet implemented");
        }
        private static IsCollectible(handle: QCallTypeHandle): BOOL {
            throw new Error("not yet implemented");
        }
        private static GetGenericTypeDefinition(type: QCallTypeHandle, retType: ObjectHandleOnStack) {
            throw new Error("not yet implemented");
        }
        private static IsGenericVariable(type: RuntimeType): boolean {
            throw new Error("not yet implemented");
        }
        private static GetGenericVariableIndex(type: RuntimeType): number {
            throw new Error("not yet implemented");
        }
        private GetGenericVariableIndex(): number {
            throw new Error("not yet implemented");
        }
        private static ContainsGenericVariables(handle: RuntimeType): boolean {
            throw new Error("not yet implemented");
        }
        private ContainsGenericVariables(): boolean {
            throw new Error("not yet implemented");
        }
        private static SatisfiesConstraints(paramType: RuntimeType, pTypeContext: number*, typeContextLength: number, pMethodContext: number*, methodContextLength: number, toType: RuntimeType): boolean {
            throw new Error("not yet implemented");
        }
        private static SatisfiesConstraints(paramType: RuntimeType, typeContext: RuntimeType[], methodContext: RuntimeType[], toType: RuntimeType): boolean {
            throw new Error("not yet implemented");
        }
        private static _GetMetadataImport(type: RuntimeType): number {
            throw new Error("not yet implemented");
        }
        private static GetMetadataImport(type: RuntimeType): MetadataImport {
            throw new Error("not yet implemented");
        }
        private static RegisterCollectibleTypeDependency(type: QCallTypeHandle, assembly: QCallAssembly) {
            throw new Error("not yet implemented");
        }
        private static RegisterCollectibleTypeDependency(type: RuntimeType, assembly: RuntimeAssembly) {
            throw new Error("not yet implemented");
        }
        public GetObjectData(info: SerializationInfo, context: StreamingContext) {
            throw new Error("not yet implemented");
        }
        private static IsEquivalentTo(rtType1: RuntimeType, rtType2: RuntimeType): boolean {
            throw new Error("not yet implemented");
        }
        private static ___IsVisible__g____PInvoke_67_0(__typeHandle_native: QCallTypeHandle): number {
            throw new Error("not yet implemented");
        }
    }
    export namespace RuntimeTypeHandle {
        export class IntroducedMethodEnumerator extends ValueType {
            private _firstCall: boolean;
            private _handle: RuntimeMethodHandleInternal;

            public get Current(): RuntimeMethodHandleInternal {
                throw new Error("not yet implemented");
            }

            protected constructor(type: RuntimeType) {
                throw new Error("not yet implemented");
            }

            public MoveNext(): boolean {
                throw new Error("not yet implemented");
            }
            public GetEnumerator(): IntroducedMethodEnumerator {
                throw new Error("not yet implemented");
            }
        }
    }
    export class RuntimeMethodHandle extends ValueType implements IEquatable<RuntimeMethodHandle>, ISerializable {
        private m_value: IRuntimeMethodInfo;

        public get Value(): number {
            throw new Error("not yet implemented");
        }

        protected constructor(method: IRuntimeMethodInfo) {
            throw new Error("not yet implemented");
        }

        private static EnsureNonNullMethodInfo(method: IRuntimeMethodInfo): IRuntimeMethodInfo {
            throw new Error("not yet implemented");
        }
        private GetMethodInfo(): IRuntimeMethodInfo {
            throw new Error("not yet implemented");
        }
        public GetObjectData(info: SerializationInfo, context: StreamingContext) {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public static FromIntPtr(value: number): RuntimeMethodHandle {
            throw new Error("not yet implemented");
        }
        public static ToIntPtr(value: RuntimeMethodHandle): number {
            throw new Error("not yet implemented");
        }
        public Equals(handle: RuntimeMethodHandle): boolean {
            throw new Error("not yet implemented");
        }
        private IsNullHandle(): boolean {
            throw new Error("not yet implemented");
        }
        private static GetFunctionPointer(handle: RuntimeMethodHandleInternal): number {
            throw new Error("not yet implemented");
        }
        public GetFunctionPointer(): number {
            throw new Error("not yet implemented");
        }
        private static GetIsCollectible(handle: RuntimeMethodHandleInternal): BOOL {
            throw new Error("not yet implemented");
        }
        private static IsCAVisibleFromDecoratedType(attrTypeHandle: QCallTypeHandle, attrCtor: RuntimeMethodHandleInternal, sourceTypeHandle: QCallTypeHandle, sourceModule: QCallModule): BOOL {
            throw new Error("not yet implemented");
        }
        private static _GetCurrentMethod(ref stackMark: StackCrawlMark): IRuntimeMethodInfo {
            throw new Error("not yet implemented");
        }
        private static GetCurrentMethod(ref stackMark: StackCrawlMark): IRuntimeMethodInfo {
            throw new Error("not yet implemented");
        }
        private static GetAttributes(method: RuntimeMethodHandleInternal): MethodAttributes {
            throw new Error("not yet implemented");
        }
        private static GetAttributes(method: IRuntimeMethodInfo): MethodAttributes {
            throw new Error("not yet implemented");
        }
        private static GetImplAttributes(method: IRuntimeMethodInfo): MethodImplAttributes {
            throw new Error("not yet implemented");
        }
        private static ConstructInstantiation(method: RuntimeMethodHandleInternal, format: TypeNameFormatFlags, retString: StringHandleOnStack) {
            throw new Error("not yet implemented");
        }
        private static ConstructInstantiation(method: IRuntimeMethodInfo, format: TypeNameFormatFlags): string {
            throw new Error("not yet implemented");
        }
        private static GetDeclaringType(method: RuntimeMethodHandleInternal): RuntimeType {
            throw new Error("not yet implemented");
        }
        private static GetDeclaringType(method: IRuntimeMethodInfo): RuntimeType {
            throw new Error("not yet implemented");
        }
        private static GetSlot(method: RuntimeMethodHandleInternal): number {
            throw new Error("not yet implemented");
        }
        private static GetSlot(method: IRuntimeMethodInfo): number {
            throw new Error("not yet implemented");
        }
        private static GetMethodDef(method: IRuntimeMethodInfo): number {
            throw new Error("not yet implemented");
        }
        private static GetName(method: RuntimeMethodHandleInternal): string {
            throw new Error("not yet implemented");
        }
        private static GetName(method: IRuntimeMethodInfo): string {
            throw new Error("not yet implemented");
        }
        private static _GetUtf8Name(method: RuntimeMethodHandleInternal): void* {
            throw new Error("not yet implemented");
        }
        private static GetUtf8Name(method: RuntimeMethodHandleInternal): MdUtf8String {
            throw new Error("not yet implemented");
        }
        private static InvokeMethod(target: any, arguments: Void**, sig: Signature, isConstructor: boolean): any {
            throw new Error("not yet implemented");
        }
        private static ReboxFromNullable(src: any): any {
            throw new Error("not yet implemented");
        }
        private static ReboxToNullable(src: any, destNullableType: RuntimeType): any {
            throw new Error("not yet implemented");
        }
        private static GetMethodInstantiation(method: RuntimeMethodHandleInternal, types: ObjectHandleOnStack, fAsRuntimeTypeArray: BOOL) {
            throw new Error("not yet implemented");
        }
        private static GetMethodInstantiationInternal(method: IRuntimeMethodInfo): RuntimeType[] {
            throw new Error("not yet implemented");
        }
        private static GetMethodInstantiationInternal(method: RuntimeMethodHandleInternal): RuntimeType[] {
            throw new Error("not yet implemented");
        }
        private static GetMethodInstantiationPublic(method: IRuntimeMethodInfo): Type[] {
            throw new Error("not yet implemented");
        }
        private static HasMethodInstantiation(method: RuntimeMethodHandleInternal): boolean {
            throw new Error("not yet implemented");
        }
        private static HasMethodInstantiation(method: IRuntimeMethodInfo): boolean {
            throw new Error("not yet implemented");
        }
        private static GetStubIfNeeded(method: RuntimeMethodHandleInternal, declaringType: RuntimeType, methodInstantiation: RuntimeType[]): RuntimeMethodHandleInternal {
            throw new Error("not yet implemented");
        }
        private static GetMethodFromCanonical(method: RuntimeMethodHandleInternal, declaringType: RuntimeType): RuntimeMethodHandleInternal {
            throw new Error("not yet implemented");
        }
        private static IsGenericMethodDefinition(method: RuntimeMethodHandleInternal): boolean {
            throw new Error("not yet implemented");
        }
        private static IsGenericMethodDefinition(method: IRuntimeMethodInfo): boolean {
            throw new Error("not yet implemented");
        }
        private static IsTypicalMethodDefinition(method: IRuntimeMethodInfo): boolean {
            throw new Error("not yet implemented");
        }
        private static GetTypicalMethodDefinition(method: RuntimeMethodHandleInternal, outMethod: ObjectHandleOnStack) {
            throw new Error("not yet implemented");
        }
        private static GetTypicalMethodDefinition(method: IRuntimeMethodInfo): IRuntimeMethodInfo {
            throw new Error("not yet implemented");
        }
        private static GetGenericParameterCount(method: RuntimeMethodHandleInternal): number {
            throw new Error("not yet implemented");
        }
        private static GetGenericParameterCount(method: IRuntimeMethodInfo): number {
            throw new Error("not yet implemented");
        }
        private static StripMethodInstantiation(method: RuntimeMethodHandleInternal, outMethod: ObjectHandleOnStack) {
            throw new Error("not yet implemented");
        }
        private static StripMethodInstantiation(method: IRuntimeMethodInfo): IRuntimeMethodInfo {
            throw new Error("not yet implemented");
        }
        private static IsDynamicMethod(method: RuntimeMethodHandleInternal): boolean {
            throw new Error("not yet implemented");
        }
        private static Destroy(method: RuntimeMethodHandleInternal) {
            throw new Error("not yet implemented");
        }
        private static GetResolver(method: RuntimeMethodHandleInternal): Resolver {
            throw new Error("not yet implemented");
        }
        private static GetMethodBody(method: IRuntimeMethodInfo, declaringType: RuntimeType): RuntimeMethodBody {
            throw new Error("not yet implemented");
        }
        private static IsConstructor(method: RuntimeMethodHandleInternal): boolean {
            throw new Error("not yet implemented");
        }
        private static GetLoaderAllocator(method: RuntimeMethodHandleInternal): LoaderAllocator {
            throw new Error("not yet implemented");
        }
    }
    export enum Primitives {
        Boolean = 0x8,
        Char = 0x10,
        SByte = 0x20,
        Byte = 0x40,
        Int16 = 0x80,
        UInt16 = 0x100,
        Int32 = 0x200,
        UInt32 = 0x400,
        Int64 = 0x800,
        UInt64 = 0x1000,
        Single = 0x2000,
        Double = 0x4000,
        Decimal = 0x8000,
        DateTime = 0x10000,
        String = 0x40000,
    }
    export class DefaultBinder extends Binder {
        private static readonly s_primitiveConversions: Primitives[];

        public constructor() {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

        public BindToMethod(bindingAttr: BindingFlags, match: MethodBase[], ref args: any[], modifiers: ParameterModifier[], cultureInfo: CultureInfo, names: string[], out state: any): MethodBase {
            throw new Error("not yet implemented");
        }
        public BindToField(bindingAttr: BindingFlags, match: FieldInfo[], value: any, cultureInfo: CultureInfo): FieldInfo {
            throw new Error("not yet implemented");
        }
        public SelectMethod(bindingAttr: BindingFlags, match: MethodBase[], types: Type[], modifiers: ParameterModifier[]): MethodBase {
            throw new Error("not yet implemented");
        }
        public SelectProperty(bindingAttr: BindingFlags, match: PropertyInfo[], returnType: Type, indexes: Type[], modifiers: ParameterModifier[]): PropertyInfo {
            throw new Error("not yet implemented");
        }
        public ChangeType(value: any, type: Type, cultureInfo: CultureInfo): any {
            throw new Error("not yet implemented");
        }
        public ReorderArgumentArray(ref args: any[], state: any) {
            throw new Error("not yet implemented");
        }
        public static ExactBinding(match: MethodBase[], types: Type[]): MethodBase {
            throw new Error("not yet implemented");
        }
        public static ExactPropertyBinding(match: PropertyInfo[], returnType: Type, types: Type[]): PropertyInfo {
            throw new Error("not yet implemented");
        }
        private static FindMostSpecific(p1: ParameterInfo[], paramOrder1: number[], paramArrayType1: Type, p2: ParameterInfo[], paramOrder2: number[], paramArrayType2: Type, types: Type[], args: any[]): number {
            throw new Error("not yet implemented");
        }
        private static FindMostSpecificType(c1: Type, c2: Type, t: Type): number {
            throw new Error("not yet implemented");
        }
        private static FindMostSpecificMethod(m1: MethodBase, paramOrder1: number[], paramArrayType1: Type, m2: MethodBase, paramOrder2: number[], paramArrayType2: Type, types: Type[], args: any[]): number {
            throw new Error("not yet implemented");
        }
        private static FindMostSpecificField(cur1: FieldInfo, cur2: FieldInfo): number {
            throw new Error("not yet implemented");
        }
        private static FindMostSpecificProperty(cur1: PropertyInfo, cur2: PropertyInfo): number {
            throw new Error("not yet implemented");
        }
        public static CompareMethodSig(m1: MethodBase, m2: MethodBase): boolean {
            throw new Error("not yet implemented");
        }
        private static GetHierarchyDepth(t: Type): number {
            throw new Error("not yet implemented");
        }
        private static FindMostDerivedNewSlotMeth(match: MethodBase[], cMatches: number): MethodBase {
            throw new Error("not yet implemented");
        }
        private static ReorderParams(paramOrder: number[], vars: any[]) {
            throw new Error("not yet implemented");
        }
        private static CreateParamOrder(paramOrder: number[], pars: ParameterInfo[], names: string[]): boolean {
            throw new Error("not yet implemented");
        }
        private static CanChangePrimitive(source: Type, target: Type): boolean {
            throw new Error("not yet implemented");
        }
    }
    export namespace DefaultBinder {
        export enum Primitives {
            Boolean = 0x8,
            Char = 0x10,
            SByte = 0x20,
            Byte = 0x40,
            Int16 = 0x80,
            UInt16 = 0x100,
            Int32 = 0x200,
            UInt32 = 0x400,
            Int64 = 0x800,
            UInt64 = 0x1000,
            Single = 0x2000,
            Double = 0x4000,
            Decimal = 0x8000,
            DateTime = 0x10000,
            String = 0x40000,
        }

        export class BinderState {
            private _argsMap: number[];
            private _originalSize: number;
            private _isParamArray: boolean;

            protected constructor(argsMap: number[], originalSize: number, isParamArray: boolean) {
                throw new Error("not yet implemented");
            }

        }
    }
    export class OleAutBinder extends DefaultBinder {
        public constructor() {
            throw new Error("not yet implemented");
        }

        public ChangeType(value: any, type: Type, cultureInfo: CultureInfo): any {
            throw new Error("not yet implemented");
        }
    }
    export enum AttributeTargets {
        Assembly = 0x1,
        Module = 0x2,
        Class = 0x4,
        Struct = 0x8,
        Enum = 0x10,
        Constructor = 0x20,
        Method = 0x40,
        Property = 0x80,
        Field = 0x100,
        Event = 0x200,
        Interface = 0x400,
        Parameter = 0x800,
        Delegate = 0x1000,
        ReturnValue = 0x2000,
        GenericParameter = 0x4000,
        All = 0x7fff,
    }
    export class AttributeUsageAttribute extends Attribute {
        private static readonly Default: AttributeUsageAttribute;

        private _attributeTarget: AttributeTargets;
        private _allowMultiple: boolean;
        private _inherited: boolean;

        public get ValidOn(): AttributeTargets {
            throw new Error("not yet implemented");
        }
        public get AllowMultiple(): boolean {
            throw new Error("not yet implemented");
        }
        public set AllowMultiple(value: boolean) {
            throw new Error("not yet implemented");
        }
        public get Inherited(): boolean {
            throw new Error("not yet implemented");
        }
        public set Inherited(value: boolean) {
            throw new Error("not yet implemented");
        }

        public constructor(validOn: AttributeTargets) {
            throw new Error("not yet implemented");
        }
        protected constructor(validOn: AttributeTargets, allowMultiple: boolean, inherited: boolean) {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

    }
    export abstract class Attribute {
        public get TypeId(): any {
            throw new Error("not yet implemented");
        }

        protected constructor() {
            throw new Error("not yet implemented");
        }

        private static InternalGetCustomAttributes(element: PropertyInfo, type: Type, inherit: boolean): Attribute[] {
            throw new Error("not yet implemented");
        }
        private static InternalIsDefined(element: PropertyInfo, attributeType: Type, inherit: boolean): boolean {
            throw new Error("not yet implemented");
        }
        private static GetParentDefinition(property: PropertyInfo, propertyParameters: Type[]): PropertyInfo {
            throw new Error("not yet implemented");
        }
        private static InternalGetCustomAttributes(element: EventInfo, type: Type, inherit: boolean): Attribute[] {
            throw new Error("not yet implemented");
        }
        private static GetParentDefinition(ev: EventInfo): EventInfo {
            throw new Error("not yet implemented");
        }
        private static InternalIsDefined(element: EventInfo, attributeType: Type, inherit: boolean): boolean {
            throw new Error("not yet implemented");
        }
        private static GetParentDefinition(param: ParameterInfo): ParameterInfo {
            throw new Error("not yet implemented");
        }
        private static InternalParamGetCustomAttributes(param: ParameterInfo, type: Type, inherit: boolean): Attribute[] {
            throw new Error("not yet implemented");
        }
        private static InternalParamIsDefined(param: ParameterInfo, type: Type, inherit: boolean): boolean {
            throw new Error("not yet implemented");
        }
        private static CopyToAttributeList(attributeList: List<Attribute>, attributes: Attribute[], types: Dictionary<Type, AttributeUsageAttribute>) {
            throw new Error("not yet implemented");
        }
        private static GetIndexParameterTypes(element: PropertyInfo): Type[] {
            throw new Error("not yet implemented");
        }
        private static AddAttributesToList(attributeList: List<Attribute>, attributes: Attribute[], types: Dictionary<Type, AttributeUsageAttribute>) {
            throw new Error("not yet implemented");
        }
        private static InternalGetAttributeUsage(type: Type): AttributeUsageAttribute {
            throw new Error("not yet implemented");
        }
        private static CreateAttributeArrayHelper(elementType: Type, elementCount: number): Attribute[] {
            throw new Error("not yet implemented");
        }
        public static GetCustomAttributes(element: MemberInfo, attributeType: Type): Attribute[] {
            throw new Error("not yet implemented");
        }
        public static GetCustomAttributes(element: MemberInfo, attributeType: Type, inherit: boolean): Attribute[] {
            throw new Error("not yet implemented");
        }
        public static GetCustomAttributes(element: MemberInfo): Attribute[] {
            throw new Error("not yet implemented");
        }
        public static GetCustomAttributes(element: MemberInfo, inherit: boolean): Attribute[] {
            throw new Error("not yet implemented");
        }
        public static IsDefined(element: MemberInfo, attributeType: Type): boolean {
            throw new Error("not yet implemented");
        }
        public static IsDefined(element: MemberInfo, attributeType: Type, inherit: boolean): boolean {
            throw new Error("not yet implemented");
        }
        public static GetCustomAttribute(element: MemberInfo, attributeType: Type): Attribute {
            throw new Error("not yet implemented");
        }
        public static GetCustomAttribute(element: MemberInfo, attributeType: Type, inherit: boolean): Attribute {
            throw new Error("not yet implemented");
        }
        public static GetCustomAttributes(element: ParameterInfo): Attribute[] {
            throw new Error("not yet implemented");
        }
        public static GetCustomAttributes(element: ParameterInfo, attributeType: Type): Attribute[] {
            throw new Error("not yet implemented");
        }
        public static GetCustomAttributes(element: ParameterInfo, attributeType: Type, inherit: boolean): Attribute[] {
            throw new Error("not yet implemented");
        }
        public static GetCustomAttributes(element: ParameterInfo, inherit: boolean): Attribute[] {
            throw new Error("not yet implemented");
        }
        public static IsDefined(element: ParameterInfo, attributeType: Type): boolean {
            throw new Error("not yet implemented");
        }
        public static IsDefined(element: ParameterInfo, attributeType: Type, inherit: boolean): boolean {
            throw new Error("not yet implemented");
        }
        public static GetCustomAttribute(element: ParameterInfo, attributeType: Type): Attribute {
            throw new Error("not yet implemented");
        }
        public static GetCustomAttribute(element: ParameterInfo, attributeType: Type, inherit: boolean): Attribute {
            throw new Error("not yet implemented");
        }
        public static GetCustomAttributes(element: Module, attributeType: Type): Attribute[] {
            throw new Error("not yet implemented");
        }
        public static GetCustomAttributes(element: Module): Attribute[] {
            throw new Error("not yet implemented");
        }
        public static GetCustomAttributes(element: Module, inherit: boolean): Attribute[] {
            throw new Error("not yet implemented");
        }
        public static GetCustomAttributes(element: Module, attributeType: Type, inherit: boolean): Attribute[] {
            throw new Error("not yet implemented");
        }
        public static IsDefined(element: Module, attributeType: Type): boolean {
            throw new Error("not yet implemented");
        }
        public static IsDefined(element: Module, attributeType: Type, inherit: boolean): boolean {
            throw new Error("not yet implemented");
        }
        public static GetCustomAttribute(element: Module, attributeType: Type): Attribute {
            throw new Error("not yet implemented");
        }
        public static GetCustomAttribute(element: Module, attributeType: Type, inherit: boolean): Attribute {
            throw new Error("not yet implemented");
        }
        public static GetCustomAttributes(element: Assembly, attributeType: Type): Attribute[] {
            throw new Error("not yet implemented");
        }
        public static GetCustomAttributes(element: Assembly, attributeType: Type, inherit: boolean): Attribute[] {
            throw new Error("not yet implemented");
        }
        public static GetCustomAttributes(element: Assembly): Attribute[] {
            throw new Error("not yet implemented");
        }
        public static GetCustomAttributes(element: Assembly, inherit: boolean): Attribute[] {
            throw new Error("not yet implemented");
        }
        public static IsDefined(element: Assembly, attributeType: Type): boolean {
            throw new Error("not yet implemented");
        }
        public static IsDefined(element: Assembly, attributeType: Type, inherit: boolean): boolean {
            throw new Error("not yet implemented");
        }
        public static GetCustomAttribute(element: Assembly, attributeType: Type): Attribute {
            throw new Error("not yet implemented");
        }
        public static GetCustomAttribute(element: Assembly, attributeType: Type, inherit: boolean): Attribute {
            throw new Error("not yet implemented");
        }
        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        private static AreFieldValuesEqual(thisValue: any, thatValue: any): boolean {
            throw new Error("not yet implemented");
        }
        public Match(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public IsDefaultAttribute(): boolean {
            throw new Error("not yet implemented");
        }
    }
    export enum CheckValueStatus {
        Success = 0,
        ArgumentException = 1,
        NotSupported_ByRefLike = 2,
    }
    export class RuntimeType extends TypeInfo implements ICustomAttributeProvider, IReflect, IReflectableType, ICloneable {
        private static readonly ValueType: RuntimeType;
        private static readonly ObjectType: RuntimeType;
        private static readonly StringType: RuntimeType;
        private static s_ForwardCallBinder: OleAutBinder;
        private static GenericParameterCountAny: number;

        private static get ForwardCallBinder(): OleAutBinder {
            throw new Error("not yet implemented");
        }

        private m_keepalive: any;
        private m_cache: number;
        private m_handle: number;

        private get GenericCache(): any {
            throw new Error("not yet implemented");
        }
        private set GenericCache(value: any) {
            throw new Error("not yet implemented");
        }
        private get DomainInitialized(): boolean {
            throw new Error("not yet implemented");
        }
        private set DomainInitialized(value: boolean) {
            throw new Error("not yet implemented");
        }
        private get CacheIfExists(): RuntimeTypeCache {
            throw new Error("not yet implemented");
        }
        private get Cache(): RuntimeTypeCache {
            throw new Error("not yet implemented");
        }
        public get IsCollectible(): boolean {
            throw new Error("not yet implemented");
        }
        public get DeclaringMethod(): MethodBase {
            throw new Error("not yet implemented");
        }
        public get FullName(): string {
            throw new Error("not yet implemented");
        }
        public get AssemblyQualifiedName(): string {
            throw new Error("not yet implemented");
        }
        public get Namespace(): string {
            throw new Error("not yet implemented");
        }
        public get GUID(): Guid {
            throw new Error("not yet implemented");
        }
        public get IsEnum(): boolean {
            throw new Error("not yet implemented");
        }
        private get IsActualEnum(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsConstructedGenericType(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsGenericType(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsGenericTypeDefinition(): boolean {
            throw new Error("not yet implemented");
        }
        public get GenericParameterAttributes(): GenericParameterAttributes {
            throw new Error("not yet implemented");
        }
        public get IsSZArray(): boolean {
            throw new Error("not yet implemented");
        }
        public get GenericParameterPosition(): number {
            throw new Error("not yet implemented");
        }
        public get ContainsGenericParameters(): boolean {
            throw new Error("not yet implemented");
        }
        private get IsNullableOfT(): boolean {
            throw new Error("not yet implemented");
        }
        public get StructLayoutAttribute(): StructLayoutAttribute {
            throw new Error("not yet implemented");
        }
        public get IsFunctionPointer(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsUnmanagedFunctionPointer(): boolean {
            throw new Error("not yet implemented");
        }
        public get Name(): string {
            throw new Error("not yet implemented");
        }
        public get DeclaringType(): Type {
            throw new Error("not yet implemented");
        }
        public get Assembly(): Assembly {
            throw new Error("not yet implemented");
        }
        public get BaseType(): Type {
            throw new Error("not yet implemented");
        }
        public get IsByRefLike(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsGenericParameter(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsTypeDefinition(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsSecurityCritical(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsSecuritySafeCritical(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsSecurityTransparent(): boolean {
            throw new Error("not yet implemented");
        }
        public get MemberType(): MemberTypes {
            throw new Error("not yet implemented");
        }
        public get MetadataToken(): number {
            throw new Error("not yet implemented");
        }
        public get Module(): Module {
            throw new Error("not yet implemented");
        }
        public get ReflectedType(): Type {
            throw new Error("not yet implemented");
        }
        public get TypeHandle(): RuntimeTypeHandle {
            throw new Error("not yet implemented");
        }
        public get UnderlyingSystemType(): Type {
            throw new Error("not yet implemented");
        }

        protected constructor() {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

        private static GetMethodBase(scope: RuntimeModule, typeMetadataToken: number): MethodBase {
            throw new Error("not yet implemented");
        }
        private static GetMethodBase(methodHandle: IRuntimeMethodInfo): MethodBase {
            throw new Error("not yet implemented");
        }
        private static GetMethodBase(reflectedType: RuntimeType, methodHandle: IRuntimeMethodInfo): MethodBase {
            throw new Error("not yet implemented");
        }
        private static GetMethodBase(reflectedType: RuntimeType, methodHandle: RuntimeMethodHandleInternal): MethodBase {
            throw new Error("not yet implemented");
        }
        private static GetFieldInfo(fieldHandle: IRuntimeFieldInfo): FieldInfo {
            throw new Error("not yet implemented");
        }
        private static GetFieldInfo(reflectedType: RuntimeType, field: IRuntimeFieldInfo): FieldInfo {
            throw new Error("not yet implemented");
        }
        private static GetPropertyInfo(reflectedType: RuntimeType, tkProperty: number): RuntimePropertyInfo {
            throw new Error("not yet implemented");
        }
        private static ValidateGenericArguments(definition: MemberInfo, genericArguments: RuntimeType[], e: Exception) {
            throw new Error("not yet implemented");
        }
        private static SplitName(fullname: string, out name: string, out ns: string) {
            throw new Error("not yet implemented");
        }
        private static FilterPreCalculate(isPublic: boolean, isInherited: boolean, isStatic: boolean): BindingFlags {
            throw new Error("not yet implemented");
        }
        private static FilterHelper(bindingFlags: BindingFlags, ref name: string, allowPrefixLookup: boolean, out prefixLookup: boolean, out ignoreCase: boolean, out listType: MemberListType) {
            throw new Error("not yet implemented");
        }
        private static FilterHelper(bindingFlags: BindingFlags, ref name: string, out ignoreCase: boolean, out listType: MemberListType) {
            throw new Error("not yet implemented");
        }
        private static FilterApplyPrefixLookup(memberInfo: MemberInfo, name: string, ignoreCase: boolean): boolean {
            throw new Error("not yet implemented");
        }
        private static FilterApplyBase(memberInfo: MemberInfo, bindingFlags: BindingFlags, isPublic: boolean, isNonProtectedInternal: boolean, isStatic: boolean, name: string, prefixLookup: boolean): boolean {
            throw new Error("not yet implemented");
        }
        private static FilterApplyType(type: Type, bindingFlags: BindingFlags, name: string, prefixLookup: boolean, ns: string): boolean {
            throw new Error("not yet implemented");
        }
        private static FilterApplyMethodInfo(method: RuntimeMethodInfo, bindingFlags: BindingFlags, callConv: CallingConventions, argumentTypes: Type[]): boolean {
            throw new Error("not yet implemented");
        }
        private static FilterApplyConstructorInfo(constructor: RuntimeConstructorInfo, bindingFlags: BindingFlags, callConv: CallingConventions, argumentTypes: Type[]): boolean {
            throw new Error("not yet implemented");
        }
        private static FilterApplyMethodBase(methodBase: MethodBase, methodFlags: BindingFlags, bindingFlags: BindingFlags, callConv: CallingConventions, argumentTypes: Type[]): boolean {
            throw new Error("not yet implemented");
        }
        private GetNativeTypeHandle(): TypeHandle {
            throw new Error("not yet implemented");
        }
        private GetUnderlyingNativeHandle(): number {
            throw new Error("not yet implemented");
        }
        private CacheEquals(o: any): boolean {
            throw new Error("not yet implemented");
        }
        private InitializeCache(): RuntimeTypeCache {
            throw new Error("not yet implemented");
        }
        private ClearCache() {
            throw new Error("not yet implemented");
        }
        private GetDefaultMemberName(): string {
            throw new Error("not yet implemented");
        }
        private GetMethodCandidates(name: string, genericParameterCount: number, bindingAttr: BindingFlags, callConv: CallingConventions, types: Type[], allowPrefixLookup: boolean): ListBuilder<MethodInfo> {
            throw new Error("not yet implemented");
        }
        private GetConstructorCandidates(name: string, bindingAttr: BindingFlags, callConv: CallingConventions, types: Type[], allowPrefixLookup: boolean): ListBuilder<ConstructorInfo> {
            throw new Error("not yet implemented");
        }
        private GetPropertyCandidates(name: string, bindingAttr: BindingFlags, types: Type[], allowPrefixLookup: boolean): ListBuilder<PropertyInfo> {
            throw new Error("not yet implemented");
        }
        private GetEventCandidates(name: string, bindingAttr: BindingFlags, allowPrefixLookup: boolean): ListBuilder<EventInfo> {
            throw new Error("not yet implemented");
        }
        private GetFieldCandidates(name: string, bindingAttr: BindingFlags, allowPrefixLookup: boolean): ListBuilder<FieldInfo> {
            throw new Error("not yet implemented");
        }
        private GetNestedTypeCandidates(fullname: string, bindingAttr: BindingFlags, allowPrefixLookup: boolean): ListBuilder<Type> {
            throw new Error("not yet implemented");
        }
        public GetMethods(bindingAttr: BindingFlags): MethodInfo[] {
            throw new Error("not yet implemented");
        }
        public GetConstructors(bindingAttr: BindingFlags): ConstructorInfo[] {
            throw new Error("not yet implemented");
        }
        public GetProperties(bindingAttr: BindingFlags): PropertyInfo[] {
            throw new Error("not yet implemented");
        }
        public GetEvents(bindingAttr: BindingFlags): EventInfo[] {
            throw new Error("not yet implemented");
        }
        public GetFields(bindingAttr: BindingFlags): FieldInfo[] {
            throw new Error("not yet implemented");
        }
        public GetInterfaces(): Type[] {
            throw new Error("not yet implemented");
        }
        public GetNestedTypes(bindingAttr: BindingFlags): Type[] {
            throw new Error("not yet implemented");
        }
        public GetMembers(bindingAttr: BindingFlags): MemberInfo[] {
            throw new Error("not yet implemented");
        }
        public GetInterfaceMap(interfaceType: Type): InterfaceMapping {
            throw new Error("not yet implemented");
        }
        private GetMethodImpl(name: string, bindingAttr: BindingFlags, binder: Binder, callConv: CallingConventions, types: Type[], modifiers: ParameterModifier[]): MethodInfo {
            throw new Error("not yet implemented");
        }
        private GetMethodImpl(name: string, genericParameterCount: number, bindingAttr: BindingFlags, binder: Binder, callConv: CallingConventions, types: Type[], modifiers: ParameterModifier[]): MethodInfo {
            throw new Error("not yet implemented");
        }
        private GetMethodImplCommon(name: string, genericParameterCount: number, bindingAttr: BindingFlags, binder: Binder, callConv: CallingConventions, types: Type[], modifiers: ParameterModifier[]): MethodInfo {
            throw new Error("not yet implemented");
        }
        private GetConstructorImpl(bindingAttr: BindingFlags, binder: Binder, callConvention: CallingConventions, types: Type[], modifiers: ParameterModifier[]): ConstructorInfo {
            throw new Error("not yet implemented");
        }
        private GetPropertyImpl(name: string, bindingAttr: BindingFlags, binder: Binder, returnType: Type, types: Type[], modifiers: ParameterModifier[]): PropertyInfo {
            throw new Error("not yet implemented");
        }
        public GetEvent(name: string, bindingAttr: BindingFlags): EventInfo {
            throw new Error("not yet implemented");
        }
        public GetField(name: string, bindingAttr: BindingFlags): FieldInfo {
            throw new Error("not yet implemented");
        }
        public GetInterface(fullname: string, ignoreCase: boolean): Type {
            throw new Error("not yet implemented");
        }
        public GetNestedType(fullname: string, bindingAttr: BindingFlags): Type {
            throw new Error("not yet implemented");
        }
        public GetMember(name: string, type: MemberTypes, bindingAttr: BindingFlags): MemberInfo[] {
            throw new Error("not yet implemented");
        }
        public GetMemberWithSameMetadataDefinitionAs(member: MemberInfo): MemberInfo {
            throw new Error("not yet implemented");
        }
        private static GetMethodWithSameMetadataDefinitionAs(runtimeType: RuntimeType, method: MemberInfo): RuntimeMethodInfo {
            throw new Error("not yet implemented");
        }
        private static GetConstructorWithSameMetadataDefinitionAs(runtimeType: RuntimeType, constructor: MemberInfo): RuntimeConstructorInfo {
            throw new Error("not yet implemented");
        }
        private static GetPropertyWithSameMetadataDefinitionAs(runtimeType: RuntimeType, property: MemberInfo): RuntimePropertyInfo {
            throw new Error("not yet implemented");
        }
        private static GetFieldWithSameMetadataDefinitionAs(runtimeType: RuntimeType, field: MemberInfo): RuntimeFieldInfo {
            throw new Error("not yet implemented");
        }
        private static GetEventWithSameMetadataDefinitionAs(runtimeType: RuntimeType, eventInfo: MemberInfo): RuntimeEventInfo {
            throw new Error("not yet implemented");
        }
        private static GetNestedTypeWithSameMetadataDefinitionAs(runtimeType: RuntimeType, nestedType: MemberInfo): RuntimeType {
            throw new Error("not yet implemented");
        }
        public IsSubclassOf(type: Type): boolean {
            throw new Error("not yet implemented");
        }
        public IsEquivalentTo(other: Type): boolean {
            throw new Error("not yet implemented");
        }
        private GetGUID(ref result: Guid) {
            throw new Error("not yet implemented");
        }
        private IsValueTypeImpl(): boolean {
            throw new Error("not yet implemented");
        }
        private IsDelegate(): boolean {
            throw new Error("not yet implemented");
        }
        public GetGenericTypeDefinition(): Type {
            throw new Error("not yet implemented");
        }
        private GetEmptyArray(): any[] {
            throw new Error("not yet implemented");
        }
        private GetGenericArgumentsInternal(): RuntimeType[] {
            throw new Error("not yet implemented");
        }
        public GetGenericArguments(): Type[] {
            throw new Error("not yet implemented");
        }
        public MakeGenericType(instantiation: Type[]): Type {
            throw new Error("not yet implemented");
        }
        public GetGenericParameterConstraints(): Type[] {
            throw new Error("not yet implemented");
        }
        public HasSameMetadataDefinitionAs(other: MemberInfo): boolean {
            throw new Error("not yet implemented");
        }
        public MakePointerType(): Type {
            throw new Error("not yet implemented");
        }
        public MakeByRefType(): Type {
            throw new Error("not yet implemented");
        }
        public MakeArrayType(): Type {
            throw new Error("not yet implemented");
        }
        public MakeArrayType(rank: number): Type {
            throw new Error("not yet implemented");
        }
        private static CanValueSpecialCast(valueType: RuntimeType, targetType: RuntimeType): boolean {
            throw new Error("not yet implemented");
        }
        private static AllocateValueType(type: RuntimeType, value: any): any {
            throw new Error("not yet implemented");
        }
        private TryChangeTypeSpecial(ref value: any): CheckValueStatus {
            throw new Error("not yet implemented");
        }
        public GetFunctionPointerCallingConventions(): Type[] {
            throw new Error("not yet implemented");
        }
        public GetFunctionPointerParameterTypes(): Type[] {
            throw new Error("not yet implemented");
        }
        public GetFunctionPointerReturnType(): Type {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
        private GetCachedName(kind: TypeNameKind): string {
            throw new Error("not yet implemented");
        }
        private CreateInstanceCheckThis() {
            throw new Error("not yet implemented");
        }
        private CreateInstanceImpl(bindingAttr: BindingFlags, binder: Binder, args: any[], culture: CultureInfo): any {
            throw new Error("not yet implemented");
        }
        private CreateInstanceDefaultCtor(publicOnly: boolean, wrapExceptions: boolean): any {
            throw new Error("not yet implemented");
        }
        private CreateInstanceOfT(): any {
            throw new Error("not yet implemented");
        }
        private InvalidateCachedNestedType() {
            throw new Error("not yet implemented");
        }
        private IsGenericCOMObjectImpl(): boolean {
            throw new Error("not yet implemented");
        }
        private static _CreateEnum(enumType: RuntimeType, value: number): any {
            throw new Error("not yet implemented");
        }
        private static CreateEnum(enumType: RuntimeType, value: number): any {
            throw new Error("not yet implemented");
        }
        private InvokeDispMethod(name: string, invokeAttr: BindingFlags, target: any, args: any[], byrefModifiers: boolean[], culture: number, namedParameters: string[]): any {
            throw new Error("not yet implemented");
        }
        private ForwardCallToInvokeMember(memberName: string, flags: BindingFlags, target: any, aArgs: any[], aArgsIsByRef: boolean[], aArgsWrapperTypes: number[], aArgsTypes: Type[], retType: Type): any {
            throw new Error("not yet implemented");
        }
        private static WrapArgsForInvokeCall(aArgs: any[], aArgsWrapperTypes: number[]) {
            throw new Error("not yet implemented");
        }
        public Clone(): any {
            throw new Error("not yet implemented");
        }
        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public GetArrayRank(): number {
            throw new Error("not yet implemented");
        }
        private GetAttributeFlagsImpl(): TypeAttributes {
            throw new Error("not yet implemented");
        }
        public GetCustomAttributes(inherit: boolean): any[] {
            throw new Error("not yet implemented");
        }
        public GetCustomAttributes(attributeType: Type, inherit: boolean): any[] {
            throw new Error("not yet implemented");
        }
        public GetCustomAttributesData(): IList<CustomAttributeData> {
            throw new Error("not yet implemented");
        }
        public GetDefaultMembers(): MemberInfo[] {
            throw new Error("not yet implemented");
        }
        public GetElementType(): Type {
            throw new Error("not yet implemented");
        }
        public GetEnumName(value: any): string {
            throw new Error("not yet implemented");
        }
        private static ThrowMustBeEnum() {
            throw new Error("not yet implemented");
        }
        public GetEnumNames(): string[] {
            throw new Error("not yet implemented");
        }
        public GetEnumValues(): Array {
            throw new Error("not yet implemented");
        }
        public GetEnumValuesAsUnderlyingType(): Array {
            throw new Error("not yet implemented");
        }
        public GetEnumUnderlyingType(): Type {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        private GetRuntimeModule(): RuntimeModule {
            throw new Error("not yet implemented");
        }
        private GetTypeCodeImpl(): TypeCode {
            throw new Error("not yet implemented");
        }
        private HasElementTypeImpl(): boolean {
            throw new Error("not yet implemented");
        }
        private IsArrayImpl(): boolean {
            throw new Error("not yet implemented");
        }
        private IsContextfulImpl(): boolean {
            throw new Error("not yet implemented");
        }
        public IsDefined(attributeType: Type, inherit: boolean): boolean {
            throw new Error("not yet implemented");
        }
        public IsEnumDefined(value: any): boolean {
            throw new Error("not yet implemented");
        }
        private IsByRefImpl(): boolean {
            throw new Error("not yet implemented");
        }
        private IsPrimitiveImpl(): boolean {
            throw new Error("not yet implemented");
        }
        private IsPointerImpl(): boolean {
            throw new Error("not yet implemented");
        }
        private IsCOMObjectImpl(): boolean {
            throw new Error("not yet implemented");
        }
        public IsInstanceOfType(o: any): boolean {
            throw new Error("not yet implemented");
        }
        public IsAssignableFrom(typeInfo: TypeInfo): boolean {
            throw new Error("not yet implemented");
        }
        public IsAssignableFrom(c: Type): boolean {
            throw new Error("not yet implemented");
        }
        public InvokeMember(name: string, bindingFlags: BindingFlags, binder: Binder, target: any, providedArgs: any[], modifiers: ParameterModifier[], culture: CultureInfo, namedParams: string[]): any {
            throw new Error("not yet implemented");
        }
        private GetBaseType(): RuntimeType {
            throw new Error("not yet implemented");
        }
        private static ThrowIfTypeNeverValidGenericArgument(type: RuntimeType) {
            throw new Error("not yet implemented");
        }
        private static SanityCheckGenericArguments(genericArguments: RuntimeType[], genericParameters: RuntimeType[]) {
            throw new Error("not yet implemented");
        }
        private static GetUnderlyingType(type: RuntimeType): CorElementType {
            throw new Error("not yet implemented");
        }
        private static TryGetByRefElementType(type: RuntimeType, out elementType: RuntimeType): boolean {
            throw new Error("not yet implemented");
        }
        private CheckValue(ref value: any): boolean {
            throw new Error("not yet implemented");
        }
        private CheckValue(ref value: any, binder: Binder, culture: CultureInfo, invokeAttr: BindingFlags): boolean {
            throw new Error("not yet implemented");
        }
        private TryChangeType(ref value: any, ref copyBack: boolean): CheckValueStatus {
            throw new Error("not yet implemented");
        }
        private __CreateInstanceImpl__g__CreateInstanceLocal_145_0(wrapExceptions: boolean): any {
            throw new Error("not yet implemented");
        }
    }
    export namespace RuntimeType {
        export class ActivatorCache {
            private _pfnAllocator: _;
            private _allocatorFirstArg: void*;
            private _pfnCtor: _;
            private _ctorIsPublic: boolean;

            private get CtorIsPublic(): boolean {
                throw new Error("not yet implemented");
            }

            protected constructor(rt: RuntimeType) {
                throw new Error("not yet implemented");
            }

            private CreateUninitializedObject(rt: RuntimeType): any {
                throw new Error("not yet implemented");
            }
            private CallConstructor(uninitializedObject: any) {
                throw new Error("not yet implemented");
            }
            private static ___ctor__g__ReturnNull_4_0(_: void*): any {
                throw new Error("not yet implemented");
            }
            private static ___ctor__g__CtorNoopStub_4_1(uninitializedObject: any) {
                throw new Error("not yet implemented");
            }
        }

        export enum MemberListType {
            All = 0,
            CaseSensitive = 1,
            CaseInsensitive = 2,
            HandleToInfo = 3,
        }

        export class ListBuilder<T> extends ValueType {
            private _items: T[];
            private _item: T;
            private _count: number;
            private _capacity: number;

            public get Item(): T {
                throw new Error("not yet implemented");
            }
            public get Count(): number {
                throw new Error("not yet implemented");
            }

            public constructor(capacity: number) {
                throw new Error("not yet implemented");
            }

            public ToArray(): T[] {
                throw new Error("not yet implemented");
            }
            public CopyTo(array: any[], index: number) {
                throw new Error("not yet implemented");
            }
            public Add(item: T) {
                throw new Error("not yet implemented");
            }
        }

        export class RuntimeTypeCache {
            private static s_methodInstantiations: CerHashtable<RuntimeMethodInfo, RuntimeMethodInfo>;
            private static s_methodInstantiationsLock: any;

            private m_runtimeType: RuntimeType;
            private m_enclosingType: RuntimeType;
            private m_typeCode: TypeCode;
            private m_name: string;
            private m_fullname: string;
            private m_toString: string;
            private m_namespace: string;
            private m_isGlobal: boolean;
            private m_bIsDomainInitialized: boolean;
            private m_methodInfoCache: MemberInfoCache<RuntimeMethodInfo>;
            private m_constructorInfoCache: MemberInfoCache<RuntimeConstructorInfo>;
            private m_fieldInfoCache: MemberInfoCache<RuntimeFieldInfo>;
            private m_interfaceCache: MemberInfoCache<RuntimeType>;
            private m_nestedClassesCache: MemberInfoCache<RuntimeType>;
            private m_propertyInfoCache: MemberInfoCache<RuntimePropertyInfo>;
            private m_eventInfoCache: MemberInfoCache<RuntimeEventInfo>;
            private m_defaultMemberName: string;
            private m_genericCache: any;
            private _emptyArray: any[];
            private _genericTypeDefinition: RuntimeType;

            private get GenericCache(): any {
                throw new Error("not yet implemented");
            }
            private set GenericCache(value: any) {
                throw new Error("not yet implemented");
            }
            private get FunctionPointerReturnAndParameterTypes(): Type[] {
                throw new Error("not yet implemented");
            }
            private get DomainInitialized(): boolean {
                throw new Error("not yet implemented");
            }
            private set DomainInitialized(value: boolean) {
                throw new Error("not yet implemented");
            }
            private get TypeCode(): TypeCode {
                throw new Error("not yet implemented");
            }
            private set TypeCode(value: TypeCode) {
                throw new Error("not yet implemented");
            }
            private get IsGlobal(): boolean {
                throw new Error("not yet implemented");
            }

            protected constructor(runtimeType: RuntimeType) {
                throw new Error("not yet implemented");
            }

            private ConstructName(ref name: string, formatFlags: TypeNameFormatFlags): string {
                throw new Error("not yet implemented");
            }
            private GetMemberList(ref m_cache: MemberInfoCache<T>, listType: MemberListType, name: string, cacheType: CacheType): T[] {
                throw new Error("not yet implemented");
            }
            private GetMemberCache(ref m_cache: MemberInfoCache<T>): MemberInfoCache<T> {
                throw new Error("not yet implemented");
            }
            private GetName(kind: TypeNameKind): string {
                throw new Error("not yet implemented");
            }
            private GetNameSpace(): string {
                throw new Error("not yet implemented");
            }
            private GetEnclosingType(): RuntimeType {
                throw new Error("not yet implemented");
            }
            private GetRuntimeType(): RuntimeType {
                throw new Error("not yet implemented");
            }
            private InvalidateCachedNestedType() {
                throw new Error("not yet implemented");
            }
            private GetDefaultMemberName(): string {
                throw new Error("not yet implemented");
            }
            private GetEmptyArray(): any[] {
                throw new Error("not yet implemented");
            }
            private GetGenericTypeDefinition(): RuntimeType {
                throw new Error("not yet implemented");
            }
            private GetGenericMethodInfo(genericMethod: RuntimeMethodHandleInternal): MethodInfo {
                throw new Error("not yet implemented");
            }
            private GetMethodList(listType: MemberListType, name: string): RuntimeMethodInfo[] {
                throw new Error("not yet implemented");
            }
            private GetConstructorList(listType: MemberListType, name: string): RuntimeConstructorInfo[] {
                throw new Error("not yet implemented");
            }
            private GetPropertyList(listType: MemberListType, name: string): RuntimePropertyInfo[] {
                throw new Error("not yet implemented");
            }
            private GetEventList(listType: MemberListType, name: string): RuntimeEventInfo[] {
                throw new Error("not yet implemented");
            }
            private GetFieldList(listType: MemberListType, name: string): RuntimeFieldInfo[] {
                throw new Error("not yet implemented");
            }
            private GetInterfaceList(listType: MemberListType, name: string): RuntimeType[] {
                throw new Error("not yet implemented");
            }
            private GetNestedTypeList(listType: MemberListType, name: string): RuntimeType[] {
                throw new Error("not yet implemented");
            }
            private GetMethod(declaringType: RuntimeType, method: RuntimeMethodHandleInternal): MethodBase {
                throw new Error("not yet implemented");
            }
            private GetConstructor(declaringType: RuntimeType, constructor: RuntimeMethodHandleInternal): MethodBase {
                throw new Error("not yet implemented");
            }
            private GetField(field: RuntimeFieldHandleInternal): FieldInfo {
                throw new Error("not yet implemented");
            }
            private __GetGenericTypeDefinition__g__CacheGenericDefinition_50_0(): RuntimeType {
                throw new Error("not yet implemented");
            }
        }
        export namespace RuntimeTypeCache {
            export enum CacheType {
                Method = 0,
                Constructor = 1,
                Field = 2,
                Property = 3,
                Event = 4,
                Interface = 5,
                NestedType = 6,
            }

            export class Filter extends ValueType {
                private m_name: MdUtf8String;
                private m_listType: MemberListType;

                public constructor(pUtf8Name: number*, cUtf8Name: number, listType: MemberListType) {
                    throw new Error("not yet implemented");
                }

                public Match(name: MdUtf8String): boolean {
                    throw new Error("not yet implemented");
                }
                public RequiresStringComparison(): boolean {
                    throw new Error("not yet implemented");
                }
                public CaseSensitive(): boolean {
                    throw new Error("not yet implemented");
                }
            }

            export class MemberInfoCache<T> {
                private m_csMemberInfos: CerHashtable<string, T[]>;
                private m_cisMemberInfos: CerHashtable<string, T[]>;
                private m_allMembers: T[];
                private m_cacheComplete: boolean;
                private m_runtimeTypeCache: RuntimeTypeCache;

                private get ReflectedType(): RuntimeType {
                    throw new Error("not yet implemented");
                }

                protected constructor(runtimeTypeCache: RuntimeTypeCache) {
                    throw new Error("not yet implemented");
                }

                private AddMethod(declaringType: RuntimeType, method: RuntimeMethodHandleInternal, cacheType: CacheType): MethodBase {
                    throw new Error("not yet implemented");
                }
                private AddField(field: RuntimeFieldHandleInternal): FieldInfo {
                    throw new Error("not yet implemented");
                }
                private Populate(name: string, listType: MemberListType, cacheType: CacheType): T[] {
                    throw new Error("not yet implemented");
                }
                private GetListByName(pName: string*, cNameLen: number, pUtf8Name: number*, cUtf8Name: number, listType: MemberListType, cacheType: CacheType): T[] {
                    throw new Error("not yet implemented");
                }
                private Insert(ref list: T[], name: string, listType: MemberListType) {
                    throw new Error("not yet implemented");
                }
                private MergeWithGlobalListInOrder(list: T[]) {
                    throw new Error("not yet implemented");
                }
                private MergeWithGlobalList(list: T[]) {
                    throw new Error("not yet implemented");
                }
                private PopulateMethods(filter: Filter): RuntimeMethodInfo[] {
                    throw new Error("not yet implemented");
                }
                private PopulateConstructors(filter: Filter): RuntimeConstructorInfo[] {
                    throw new Error("not yet implemented");
                }
                private PopulateFields(filter: Filter): RuntimeFieldInfo[] {
                    throw new Error("not yet implemented");
                }
                private PopulateRtFields(filter: Filter, declaringType: RuntimeType, ref list: ListBuilder<RuntimeFieldInfo>) {
                    throw new Error("not yet implemented");
                }
                private PopulateRtFields(filter: Filter, ppFieldHandles: number*, count: number, declaringType: RuntimeType, ref list: ListBuilder<RuntimeFieldInfo>) {
                    throw new Error("not yet implemented");
                }
                private PopulateLiteralFields(filter: Filter, declaringType: RuntimeType, ref list: ListBuilder<RuntimeFieldInfo>) {
                    throw new Error("not yet implemented");
                }
                private AddSpecialInterface(ref list: ListBuilder<RuntimeType>, filter: Filter, iList: RuntimeType, addSubInterface: boolean) {
                    throw new Error("not yet implemented");
                }
                private PopulateInterfaces(filter: Filter): RuntimeType[] {
                    throw new Error("not yet implemented");
                }
                private PopulateNestedClasses(filter: Filter): RuntimeType[] {
                    throw new Error("not yet implemented");
                }
                private PopulateEvents(filter: Filter): RuntimeEventInfo[] {
                    throw new Error("not yet implemented");
                }
                private PopulateEvents(filter: Filter, declaringType: RuntimeType, csEventInfos: Dictionary<string, RuntimeEventInfo>, ref list: ListBuilder<RuntimeEventInfo>) {
                    throw new Error("not yet implemented");
                }
                private PopulateProperties(filter: Filter): RuntimePropertyInfo[] {
                    throw new Error("not yet implemented");
                }
                private PopulateProperties(filter: Filter, declaringType: RuntimeType, csPropertyInfos: Dictionary<string, List<RuntimePropertyInfo>>, usedSlots: Span<boolean>, isInterface: boolean, ref list: ListBuilder<RuntimePropertyInfo>) {
                    throw new Error("not yet implemented");
                }
                private GetMemberList(listType: MemberListType, name: string, cacheType: CacheType): T[] {
                    throw new Error("not yet implemented");
                }
            }
        }

        export enum DispatchWrapperType {
            Unknown = 0x1,
            Dispatch = 0x2,
            Error = 0x8,
            Currency = 0x10,
            BStr = 0x20,
            SafeArray = 0x10000,
        }

        export enum CheckValueStatus {
            Success = 0,
            ArgumentException = 1,
            NotSupported_ByRefLike = 2,
        }
    }
    export abstract class Array implements ICloneable, IList, ICollection, IEnumerable, IStructuralComparable, IStructuralEquatable {
        public static get MaxLength(): number {
            throw new Error("not yet implemented");
        }

        public get Length(): number {
            throw new Error("not yet implemented");
        }
        private get NativeLength(): number {
            throw new Error("not yet implemented");
        }
        public get LongLength(): number {
            throw new Error("not yet implemented");
        }
        public get Rank(): number {
            throw new Error("not yet implemented");
        }
        private get __explicit__ICollection_Count(): number {
            throw new Error("not yet implemented");
        }
        public get Count(): number {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        public get SyncRoot(): any {
            throw new Error("not yet implemented");
        }
        public get IsReadOnly(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsFixedSize(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsSynchronized(): boolean {
            throw new Error("not yet implemented");
        }
        private get __explicit__IList_Item(): any {
            throw new Error("not yet implemented");
        }
        private set __explicit__IList_Item(index: number) {
            throw new Error("not yet implemented");
        }
        public get Item(): any {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        public set Item(index: number) {
            throw new Error("Invalid call (use ExplicitAs property)");
        }

        protected constructor() {
            throw new Error("not yet implemented");
        }

        private static InternalCreate(elementType: RuntimeType, rank: number, pLengths: number*, pLowerBounds: number*): Array {
            throw new Error("not yet implemented");
        }
        private static CopyImpl(sourceArray: Array, sourceIndex: number, destinationArray: Array, destinationIndex: number, length: number, reliable: boolean) {
            throw new Error("not yet implemented");
        }
        private static IsSimpleCopy(sourceArray: Array, destinationArray: Array): boolean {
            throw new Error("not yet implemented");
        }
        private static CopySlow(sourceArray: Array, sourceIndex: number, destinationArray: Array, destinationIndex: number, length: number) {
            throw new Error("not yet implemented");
        }
        public static ConstrainedCopy(sourceArray: Array, sourceIndex: number, destinationArray: Array, destinationIndex: number, length: number) {
            throw new Error("not yet implemented");
        }
        public static Clear(array: Array) {
            throw new Error("not yet implemented");
        }
        public static Clear(array: Array, index: number, length: number) {
            throw new Error("not yet implemented");
        }
        private GetFlattenedIndex(rawIndex: number): number {
            throw new Error("not yet implemented");
        }
        private GetFlattenedIndex(indices: ReadOnlySpan<number>): number {
            throw new Error("not yet implemented");
        }
        private InternalGetValue(flattenedIndex: number): any {
            throw new Error("not yet implemented");
        }
        private InternalSetValue(value: any, flattenedIndex: number) {
            throw new Error("not yet implemented");
        }
        public GetLength(dimension: number): number {
            throw new Error("not yet implemented");
        }
        public GetUpperBound(dimension: number): number {
            throw new Error("not yet implemented");
        }
        public GetLowerBound(dimension: number): number {
            throw new Error("not yet implemented");
        }
        private GetCorElementTypeOfElementType(): CorElementType {
            throw new Error("not yet implemented");
        }
        private IsValueOfElementType(value: any): boolean {
            throw new Error("not yet implemented");
        }
        public Initialize() {
            throw new Error("not yet implemented");
        }
        public static AsReadOnly(array: T[]): ReadOnlyCollection<T> {
            throw new Error("not yet implemented");
        }
        public static Resize(ref array: T[], newSize: number) {
            throw new Error("not yet implemented");
        }
        public static CreateInstance(elementType: Type, length: number): Array {
            throw new Error("not yet implemented");
        }
        public static CreateInstance(elementType: Type, length1: number, length2: number): Array {
            throw new Error("not yet implemented");
        }
        public static CreateInstance(elementType: Type, length1: number, length2: number, length3: number): Array {
            throw new Error("not yet implemented");
        }
        public static CreateInstance(elementType: Type, lengths: number[]): Array {
            throw new Error("not yet implemented");
        }
        public static CreateInstance(elementType: Type, lengths: number[], lowerBounds: number[]): Array {
            throw new Error("not yet implemented");
        }
        public static CreateInstance(elementType: Type, lengths: number[]): Array {
            throw new Error("not yet implemented");
        }
        public static Copy(sourceArray: Array, destinationArray: Array, length: number) {
            throw new Error("not yet implemented");
        }
        public static Copy(sourceArray: Array, sourceIndex: number, destinationArray: Array, destinationIndex: number, length: number) {
            throw new Error("not yet implemented");
        }
        public static Copy(sourceArray: Array, destinationArray: Array, length: number) {
            throw new Error("not yet implemented");
        }
        public static Copy(sourceArray: Array, sourceIndex: number, destinationArray: Array, destinationIndex: number, length: number) {
            throw new Error("not yet implemented");
        }
        public GetValue(indices: number[]): any {
            throw new Error("not yet implemented");
        }
        public GetValue(index: number): any {
            throw new Error("not yet implemented");
        }
        public GetValue(index1: number, index2: number): any {
            throw new Error("not yet implemented");
        }
        public GetValue(index1: number, index2: number, index3: number): any {
            throw new Error("not yet implemented");
        }
        public SetValue(value: any, index: number) {
            throw new Error("not yet implemented");
        }
        public SetValue(value: any, index1: number, index2: number) {
            throw new Error("not yet implemented");
        }
        public SetValue(value: any, index1: number, index2: number, index3: number) {
            throw new Error("not yet implemented");
        }
        public SetValue(value: any, indices: number[]) {
            throw new Error("not yet implemented");
        }
        public GetValue(index: number): any {
            throw new Error("not yet implemented");
        }
        public GetValue(index1: number, index2: number): any {
            throw new Error("not yet implemented");
        }
        public GetValue(index1: number, index2: number, index3: number): any {
            throw new Error("not yet implemented");
        }
        public GetValue(indices: number[]): any {
            throw new Error("not yet implemented");
        }
        public SetValue(value: any, index: number) {
            throw new Error("not yet implemented");
        }
        public SetValue(value: any, index1: number, index2: number) {
            throw new Error("not yet implemented");
        }
        public SetValue(value: any, index1: number, index2: number, index3: number) {
            throw new Error("not yet implemented");
        }
        public SetValue(value: any, indices: number[]) {
            throw new Error("not yet implemented");
        }
        private static GetMedian(low: number, hi: number): number {
            throw new Error("not yet implemented");
        }
        public GetLongLength(dimension: number): number {
            throw new Error("not yet implemented");
        }
        private __explicit__IList_Add(value: any): number {
            throw new Error("not yet implemented");
        }
        public Add(value: any): number {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__IList_Contains(value: any): boolean {
            throw new Error("not yet implemented");
        }
        public Contains(value: any): boolean {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__IList_Clear() {
            throw new Error("not yet implemented");
        }
        private __explicit__IList_IndexOf(value: any): number {
            throw new Error("not yet implemented");
        }
        private __explicit__IList_Insert(index: number, value: any) {
            throw new Error("not yet implemented");
        }
        public Insert(index: number, value: any) {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__IList_Remove(value: any) {
            throw new Error("not yet implemented");
        }
        public Remove(value: any) {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__IList_RemoveAt(index: number) {
            throw new Error("not yet implemented");
        }
        public RemoveAt(index: number) {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        public Clone(): any {
            throw new Error("not yet implemented");
        }
        private __explicit__IStructuralComparable_CompareTo(other: any, comparer: IComparer): number {
            throw new Error("not yet implemented");
        }
        public CompareTo(other: any, comparer: IComparer): number {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__IStructuralEquatable_Equals(other: any, comparer: IEqualityComparer): boolean {
            throw new Error("not yet implemented");
        }
        public Equals(other: any, comparer: IEqualityComparer): boolean {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__IStructuralEquatable_GetHashCode(comparer: IEqualityComparer): number {
            throw new Error("not yet implemented");
        }
        public GetHashCode(comparer: IEqualityComparer): number {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        public static BinarySearch(array: Array, value: any): number {
            throw new Error("not yet implemented");
        }
        public static BinarySearch(array: Array, index: number, length: number, value: any): number {
            throw new Error("not yet implemented");
        }
        public static BinarySearch(array: Array, value: any, comparer: IComparer): number {
            throw new Error("not yet implemented");
        }
        public static BinarySearch(array: Array, index: number, length: number, value: any, comparer: IComparer): number {
            throw new Error("not yet implemented");
        }
        public static BinarySearch(array: T[], value: T): number {
            throw new Error("not yet implemented");
        }
        public static BinarySearch(array: T[], value: T, comparer: IComparer<T>): number {
            throw new Error("not yet implemented");
        }
        public static BinarySearch(array: T[], index: number, length: number, value: T): number {
            throw new Error("not yet implemented");
        }
        public static BinarySearch(array: T[], index: number, length: number, value: T, comparer: IComparer<T>): number {
            throw new Error("not yet implemented");
        }
        public static ConvertAll(array: TInput[], converter: Converter<TInput, TOutput>): TOutput[] {
            throw new Error("not yet implemented");
        }
        public CopyTo(array: Array, index: number) {
            throw new Error("not yet implemented");
        }
        public CopyTo(array: Array, index: number) {
            throw new Error("not yet implemented");
        }
        public static Empty(): T[] {
            throw new Error("not yet implemented");
        }
        public static Exists(array: T[], match: Predicate<T>): boolean {
            throw new Error("not yet implemented");
        }
        public static Fill(array: T[], value: T) {
            throw new Error("not yet implemented");
        }
        public static Fill(array: T[], value: T, startIndex: number, count: number) {
            throw new Error("not yet implemented");
        }
        public static Find(array: T[], match: Predicate<T>): T {
            throw new Error("not yet implemented");
        }
        public static FindAll(array: T[], match: Predicate<T>): T[] {
            throw new Error("not yet implemented");
        }
        public static FindIndex(array: T[], match: Predicate<T>): number {
            throw new Error("not yet implemented");
        }
        public static FindIndex(array: T[], startIndex: number, match: Predicate<T>): number {
            throw new Error("not yet implemented");
        }
        public static FindIndex(array: T[], startIndex: number, count: number, match: Predicate<T>): number {
            throw new Error("not yet implemented");
        }
        public static FindLast(array: T[], match: Predicate<T>): T {
            throw new Error("not yet implemented");
        }
        public static FindLastIndex(array: T[], match: Predicate<T>): number {
            throw new Error("not yet implemented");
        }
        public static FindLastIndex(array: T[], startIndex: number, match: Predicate<T>): number {
            throw new Error("not yet implemented");
        }
        public static FindLastIndex(array: T[], startIndex: number, count: number, match: Predicate<T>): number {
            throw new Error("not yet implemented");
        }
        public static ForEach(array: T[], action: Action<T>) {
            throw new Error("not yet implemented");
        }
        public static IndexOf(array: Array, value: any): number {
            throw new Error("not yet implemented");
        }
        public static IndexOf(array: Array, value: any, startIndex: number): number {
            throw new Error("not yet implemented");
        }
        public static IndexOf(array: Array, value: any, startIndex: number, count: number): number {
            throw new Error("not yet implemented");
        }
        public static IndexOf(array: T[], value: T): number {
            throw new Error("not yet implemented");
        }
        public static IndexOf(array: T[], value: T, startIndex: number): number {
            throw new Error("not yet implemented");
        }
        public static IndexOf(array: T[], value: T, startIndex: number, count: number): number {
            throw new Error("not yet implemented");
        }
        public static LastIndexOf(array: Array, value: any): number {
            throw new Error("not yet implemented");
        }
        public static LastIndexOf(array: Array, value: any, startIndex: number): number {
            throw new Error("not yet implemented");
        }
        public static LastIndexOf(array: Array, value: any, startIndex: number, count: number): number {
            throw new Error("not yet implemented");
        }
        public static LastIndexOf(array: T[], value: T): number {
            throw new Error("not yet implemented");
        }
        public static LastIndexOf(array: T[], value: T, startIndex: number): number {
            throw new Error("not yet implemented");
        }
        public static LastIndexOf(array: T[], value: T, startIndex: number, count: number): number {
            throw new Error("not yet implemented");
        }
        public static Reverse(array: Array) {
            throw new Error("not yet implemented");
        }
        public static Reverse(array: Array, index: number, length: number) {
            throw new Error("not yet implemented");
        }
        public static Reverse(array: T[]) {
            throw new Error("not yet implemented");
        }
        public static Reverse(array: T[], index: number, length: number) {
            throw new Error("not yet implemented");
        }
        public static Sort(array: Array) {
            throw new Error("not yet implemented");
        }
        public static Sort(keys: Array, items: Array) {
            throw new Error("not yet implemented");
        }
        public static Sort(array: Array, index: number, length: number) {
            throw new Error("not yet implemented");
        }
        public static Sort(keys: Array, items: Array, index: number, length: number) {
            throw new Error("not yet implemented");
        }
        public static Sort(array: Array, comparer: IComparer) {
            throw new Error("not yet implemented");
        }
        public static Sort(keys: Array, items: Array, comparer: IComparer) {
            throw new Error("not yet implemented");
        }
        public static Sort(array: Array, index: number, length: number, comparer: IComparer) {
            throw new Error("not yet implemented");
        }
        public static Sort(keys: Array, items: Array, index: number, length: number, comparer: IComparer) {
            throw new Error("not yet implemented");
        }
        public static Sort(array: T[]) {
            throw new Error("not yet implemented");
        }
        public static Sort(keys: TKey[], items: TValue[]) {
            throw new Error("not yet implemented");
        }
        public static Sort(array: T[], index: number, length: number) {
            throw new Error("not yet implemented");
        }
        public static Sort(keys: TKey[], items: TValue[], index: number, length: number) {
            throw new Error("not yet implemented");
        }
        public static Sort(array: T[], comparer: IComparer<T>) {
            throw new Error("not yet implemented");
        }
        public static Sort(keys: TKey[], items: TValue[], comparer: IComparer<TKey>) {
            throw new Error("not yet implemented");
        }
        public static Sort(array: T[], index: number, length: number, comparer: IComparer<T>) {
            throw new Error("not yet implemented");
        }
        public static Sort(keys: TKey[], items: TValue[], index: number, length: number, comparer: IComparer<TKey>) {
            throw new Error("not yet implemented");
        }
        public static Sort(array: T[], comparison: Comparison<T>) {
            throw new Error("not yet implemented");
        }
        public static TrueForAll(array: T[], match: Predicate<T>): boolean {
            throw new Error("not yet implemented");
        }
        private static UnsafeArrayAsSpan(array: Array, adjustedIndex: number, length: number): Span<T> {
            throw new Error("not yet implemented");
        }
        public GetEnumerator(): IEnumerator {
            throw new Error("not yet implemented");
        }
        private static __BinarySearch__g__GenericBinarySearch_85_0(array: Array, adjustedIndex: number, length: number, value: any): number {
            throw new Error("not yet implemented");
        }
        private static __IndexOf__g__GenericIndexOf_110_0(array: Array, value: any, adjustedIndex: number, length: number): number {
            throw new Error("not yet implemented");
        }
        private static __LastIndexOf__g__GenericLastIndexOf_116_0(array: Array, value: any, adjustedIndex: number, length: number): number {
            throw new Error("not yet implemented");
        }
        private static __Sort__g__GenericSort_131_0(keys: Array, items: Array, adjustedIndex: number, length: number) {
            throw new Error("not yet implemented");
        }

        public readonly ExplicitAsICloneable: ICloneable = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Count') {
                    return target.__explicit__ICollection_Count;
                }
                if (prop === 'Item') {
                    return target.__explicit__IList_Item;
                }
        
                if (prop === 'Add') {
                    return target.__explicit__IList_Add.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__IList_Contains.bind(target);
                }
                if (prop === 'Clear') {
                    return target.__explicit__IList_Clear.bind(target);
                }
                if (prop === 'IndexOf') {
                    return target.__explicit__IList_IndexOf.bind(target);
                }
                if (prop === 'Insert') {
                    return target.__explicit__IList_Insert.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__IList_Remove.bind(target);
                }
                if (prop === 'RemoveAt') {
                    return target.__explicit__IList_RemoveAt.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IStructuralComparable_CompareTo.bind(target);
                }
                if (prop === 'Equals') {
                    return target.__explicit__IStructuralEquatable_Equals.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IStructuralEquatable_GetHashCode.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIList: IList = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Count') {
                    return target.__explicit__ICollection_Count;
                }
                if (prop === 'Item') {
                    return target.__explicit__IList_Item;
                }
        
                if (prop === 'Add') {
                    return target.__explicit__IList_Add.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__IList_Contains.bind(target);
                }
                if (prop === 'Clear') {
                    return target.__explicit__IList_Clear.bind(target);
                }
                if (prop === 'IndexOf') {
                    return target.__explicit__IList_IndexOf.bind(target);
                }
                if (prop === 'Insert') {
                    return target.__explicit__IList_Insert.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__IList_Remove.bind(target);
                }
                if (prop === 'RemoveAt') {
                    return target.__explicit__IList_RemoveAt.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IStructuralComparable_CompareTo.bind(target);
                }
                if (prop === 'Equals') {
                    return target.__explicit__IStructuralEquatable_Equals.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IStructuralEquatable_GetHashCode.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsICollection: ICollection = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Count') {
                    return target.__explicit__ICollection_Count;
                }
                if (prop === 'Item') {
                    return target.__explicit__IList_Item;
                }
        
                if (prop === 'Add') {
                    return target.__explicit__IList_Add.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__IList_Contains.bind(target);
                }
                if (prop === 'Clear') {
                    return target.__explicit__IList_Clear.bind(target);
                }
                if (prop === 'IndexOf') {
                    return target.__explicit__IList_IndexOf.bind(target);
                }
                if (prop === 'Insert') {
                    return target.__explicit__IList_Insert.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__IList_Remove.bind(target);
                }
                if (prop === 'RemoveAt') {
                    return target.__explicit__IList_RemoveAt.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IStructuralComparable_CompareTo.bind(target);
                }
                if (prop === 'Equals') {
                    return target.__explicit__IStructuralEquatable_Equals.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IStructuralEquatable_GetHashCode.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIEnumerable: IEnumerable = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Count') {
                    return target.__explicit__ICollection_Count;
                }
                if (prop === 'Item') {
                    return target.__explicit__IList_Item;
                }
        
                if (prop === 'Add') {
                    return target.__explicit__IList_Add.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__IList_Contains.bind(target);
                }
                if (prop === 'Clear') {
                    return target.__explicit__IList_Clear.bind(target);
                }
                if (prop === 'IndexOf') {
                    return target.__explicit__IList_IndexOf.bind(target);
                }
                if (prop === 'Insert') {
                    return target.__explicit__IList_Insert.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__IList_Remove.bind(target);
                }
                if (prop === 'RemoveAt') {
                    return target.__explicit__IList_RemoveAt.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IStructuralComparable_CompareTo.bind(target);
                }
                if (prop === 'Equals') {
                    return target.__explicit__IStructuralEquatable_Equals.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IStructuralEquatable_GetHashCode.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIStructuralComparable: IStructuralComparable = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Count') {
                    return target.__explicit__ICollection_Count;
                }
                if (prop === 'Item') {
                    return target.__explicit__IList_Item;
                }
        
                if (prop === 'Add') {
                    return target.__explicit__IList_Add.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__IList_Contains.bind(target);
                }
                if (prop === 'Clear') {
                    return target.__explicit__IList_Clear.bind(target);
                }
                if (prop === 'IndexOf') {
                    return target.__explicit__IList_IndexOf.bind(target);
                }
                if (prop === 'Insert') {
                    return target.__explicit__IList_Insert.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__IList_Remove.bind(target);
                }
                if (prop === 'RemoveAt') {
                    return target.__explicit__IList_RemoveAt.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IStructuralComparable_CompareTo.bind(target);
                }
                if (prop === 'Equals') {
                    return target.__explicit__IStructuralEquatable_Equals.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IStructuralEquatable_GetHashCode.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIStructuralEquatable: IStructuralEquatable = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Count') {
                    return target.__explicit__ICollection_Count;
                }
                if (prop === 'Item') {
                    return target.__explicit__IList_Item;
                }
        
                if (prop === 'Add') {
                    return target.__explicit__IList_Add.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__IList_Contains.bind(target);
                }
                if (prop === 'Clear') {
                    return target.__explicit__IList_Clear.bind(target);
                }
                if (prop === 'IndexOf') {
                    return target.__explicit__IList_IndexOf.bind(target);
                }
                if (prop === 'Insert') {
                    return target.__explicit__IList_Insert.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__IList_Remove.bind(target);
                }
                if (prop === 'RemoveAt') {
                    return target.__explicit__IList_RemoveAt.bind(target);
                }
                if (prop === 'CompareTo') {
                    return target.__explicit__IStructuralComparable_CompareTo.bind(target);
                }
                if (prop === 'Equals') {
                    return target.__explicit__IStructuralEquatable_Equals.bind(target);
                }
                if (prop === 'GetHashCode') {
                    return target.__explicit__IStructuralEquatable_GetHashCode.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
    }
    export namespace Array {
        export class ArrayInitializeCache {
            private ConstructorEntrypoint: _;

            public constructor(arrayType: RuntimeType) {
                throw new Error("not yet implemented");
            }

            private static GetElementConstructorEntrypoint(arrayType: QCallTypeHandle): _ {
                throw new Error("not yet implemented");
            }
        }

        export class EmptyArray<T> {
            private static readonly Value: T[];

            private static staticctor_initialize = (() => {
                throw new Error("not yet implemented");
            })();
            private constructor() { }

        }

        export class SorterObjectArray extends ValueType {
            private keys: any[];
            private items: any[];
            private comparer: IComparer;

            protected constructor(keys: any[], items: any[], comparer: IComparer) {
                throw new Error("not yet implemented");
            }

            private SwapIfGreater(a: number, b: number) {
                throw new Error("not yet implemented");
            }
            private Swap(i: number, j: number) {
                throw new Error("not yet implemented");
            }
            private Sort(left: number, length: number) {
                throw new Error("not yet implemented");
            }
            private IntrospectiveSort(left: number, length: number) {
                throw new Error("not yet implemented");
            }
            private IntroSort(lo: number, hi: number, depthLimit: number) {
                throw new Error("not yet implemented");
            }
            private PickPivotAndPartition(lo: number, hi: number): number {
                throw new Error("not yet implemented");
            }
            private Heapsort(lo: number, hi: number) {
                throw new Error("not yet implemented");
            }
            private DownHeap(i: number, n: number, lo: number) {
                throw new Error("not yet implemented");
            }
            private InsertionSort(lo: number, hi: number) {
                throw new Error("not yet implemented");
            }
        }

        export class SorterGenericArray extends ValueType {
            private keys: Array;
            private items: Array;
            private comparer: IComparer;

            protected constructor(keys: Array, items: Array, comparer: IComparer) {
                throw new Error("not yet implemented");
            }

            private SwapIfGreater(a: number, b: number) {
                throw new Error("not yet implemented");
            }
            private Swap(i: number, j: number) {
                throw new Error("not yet implemented");
            }
            private Sort(left: number, length: number) {
                throw new Error("not yet implemented");
            }
            private IntrospectiveSort(left: number, length: number) {
                throw new Error("not yet implemented");
            }
            private IntroSort(lo: number, hi: number, depthLimit: number) {
                throw new Error("not yet implemented");
            }
            private PickPivotAndPartition(lo: number, hi: number): number {
                throw new Error("not yet implemented");
            }
            private Heapsort(lo: number, hi: number) {
                throw new Error("not yet implemented");
            }
            private DownHeap(i: number, n: number, lo: number) {
                throw new Error("not yet implemented");
            }
            private InsertionSort(lo: number, hi: number) {
                throw new Error("not yet implemented");
            }
        }
    }
    export class InvalidCastException extends SystemException implements ISerializable {
        public constructor() {
            throw new Error("not yet implemented");
        }
        public constructor(message: string) {
            throw new Error("not yet implemented");
        }
        public constructor(message: string, innerException: Exception) {
            throw new Error("not yet implemented");
        }
        public constructor(message: string, errorCode: number) {
            throw new Error("not yet implemented");
        }
        protected constructor(info: SerializationInfo, context: StreamingContext) {
            throw new Error("not yet implemented");
        }

    }
    export class DateTime extends ValueType implements IComparable, ISpanFormattable, IFormattable, IConvertible, IComparable<DateTime>, IEquatable<DateTime>, ISerializable, ISpanParsable<DateTime>, IParsable<DateTime>, IUtf8SpanFormattable {
        public static readonly MinValue: DateTime;
        public static readonly MaxValue: DateTime;
        public static readonly UnixEpoch: DateTime;

        private static get DaysToMonth365(): ReadOnlySpan<number> {
            throw new Error("not yet implemented");
        }
        private static get DaysToMonth366(): ReadOnlySpan<number> {
            throw new Error("not yet implemented");
        }
        private static get DaysInMonth365(): ReadOnlySpan<number> {
            throw new Error("not yet implemented");
        }
        private static get DaysInMonth366(): ReadOnlySpan<number> {
            throw new Error("not yet implemented");
        }
        public static get Now(): DateTime {
            throw new Error("not yet implemented");
        }
        public static get Today(): DateTime {
            throw new Error("not yet implemented");
        }
        private static get SystemSupportsLeapSeconds(): boolean {
            throw new Error("not yet implemented");
        }
        public static get UtcNow(): DateTime {
            throw new Error("not yet implemented");
        }

        private _dateData: number;

        private get UTicks(): number {
            throw new Error("not yet implemented");
        }
        private get InternalKind(): number {
            throw new Error("not yet implemented");
        }
        public get Date(): DateTime {
            throw new Error("not yet implemented");
        }
        public get Day(): number {
            throw new Error("not yet implemented");
        }
        public get DayOfWeek(): DayOfWeek {
            throw new Error("not yet implemented");
        }
        public get DayOfYear(): number {
            throw new Error("not yet implemented");
        }
        public get Hour(): number {
            throw new Error("not yet implemented");
        }
        public get Kind(): DateTimeKind {
            throw new Error("not yet implemented");
        }
        public get Millisecond(): number {
            throw new Error("not yet implemented");
        }
        public get Microsecond(): number {
            throw new Error("not yet implemented");
        }
        public get Nanosecond(): number {
            throw new Error("not yet implemented");
        }
        public get Minute(): number {
            throw new Error("not yet implemented");
        }
        public get Month(): number {
            throw new Error("not yet implemented");
        }
        public get Second(): number {
            throw new Error("not yet implemented");
        }
        public get Ticks(): number {
            throw new Error("not yet implemented");
        }
        public get TimeOfDay(): TimeSpan {
            throw new Error("not yet implemented");
        }
        public get Year(): number {
            throw new Error("not yet implemented");
        }

        public constructor(ticks: number) {
            throw new Error("not yet implemented");
        }
        private constructor(dateData: number) {
            throw new Error("not yet implemented");
        }
        public constructor(ticks: number, kind: DateTimeKind) {
            throw new Error("not yet implemented");
        }
        public constructor(date: DateOnly, time: TimeOnly) {
            throw new Error("not yet implemented");
        }
        public constructor(date: DateOnly, time: TimeOnly, kind: DateTimeKind) {
            throw new Error("not yet implemented");
        }
        protected constructor(ticks: number, kind: DateTimeKind, isAmbiguousDst: boolean) {
            throw new Error("not yet implemented");
        }
        public constructor(year: number, month: number, day: number) {
            throw new Error("not yet implemented");
        }
        public constructor(year: number, month: number, day: number, calendar: Calendar) {
            throw new Error("not yet implemented");
        }
        public constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, calendar: Calendar, kind: DateTimeKind) {
            throw new Error("not yet implemented");
        }
        public constructor(year: number, month: number, day: number, hour: number, minute: number, second: number) {
            throw new Error("not yet implemented");
        }
        public constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, kind: DateTimeKind) {
            throw new Error("not yet implemented");
        }
        public constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, calendar: Calendar) {
            throw new Error("not yet implemented");
        }
        public constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number) {
            throw new Error("not yet implemented");
        }
        public constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, kind: DateTimeKind) {
            throw new Error("not yet implemented");
        }
        public constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, calendar: Calendar) {
            throw new Error("not yet implemented");
        }
        public constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, microsecond: number) {
            throw new Error("not yet implemented");
        }
        public constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, microsecond: number, kind: DateTimeKind) {
            throw new Error("not yet implemented");
        }
        public constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, microsecond: number, calendar: Calendar) {
            throw new Error("not yet implemented");
        }
        public constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, microsecond: number, calendar: Calendar, kind: DateTimeKind) {
            throw new Error("not yet implemented");
        }
        private constructor(info: SerializationInfo, context: StreamingContext) {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

        private static UnsafeCreate(ticks: number): DateTime {
            throw new Error("not yet implemented");
        }
        private static ThrowTicksOutOfRange() {
            throw new Error("not yet implemented");
        }
        private static ThrowInvalidKind() {
            throw new Error("not yet implemented");
        }
        private static ThrowMillisecondOutOfRange() {
            throw new Error("not yet implemented");
        }
        private static ThrowMicrosecondOutOfRange() {
            throw new Error("not yet implemented");
        }
        private static ThrowDateArithmetic(param: number) {
            throw new Error("not yet implemented");
        }
        private static ThrowAddOutOfRange() {
            throw new Error("not yet implemented");
        }
        private static Init(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, kind: DateTimeKind): number {
            throw new Error("not yet implemented");
        }
        private ValidateLeapSecond() {
            throw new Error("not yet implemented");
        }
        public Add(value: TimeSpan): DateTime {
            throw new Error("not yet implemented");
        }
        private AddUnits(value: number, maxUnitCount: number, ticksPerUnit: number): DateTime {
            throw new Error("not yet implemented");
        }
        public AddDays(value: number): DateTime {
            throw new Error("not yet implemented");
        }
        public AddHours(value: number): DateTime {
            throw new Error("not yet implemented");
        }
        public AddMilliseconds(value: number): DateTime {
            throw new Error("not yet implemented");
        }
        public AddMicroseconds(value: number): DateTime {
            throw new Error("not yet implemented");
        }
        public AddMinutes(value: number): DateTime {
            throw new Error("not yet implemented");
        }
        public AddMonths(months: number): DateTime {
            throw new Error("not yet implemented");
        }
        public AddSeconds(value: number): DateTime {
            throw new Error("not yet implemented");
        }
        public AddTicks(value: number): DateTime {
            throw new Error("not yet implemented");
        }
        private TryAddTicks(value: number, out result: DateTime): boolean {
            throw new Error("not yet implemented");
        }
        public AddYears(value: number): DateTime {
            throw new Error("not yet implemented");
        }
        public static Compare(t1: DateTime, t2: DateTime): number {
            throw new Error("not yet implemented");
        }
        public CompareTo(value: any): number {
            throw new Error("not yet implemented");
        }
        public CompareTo(value: DateTime): number {
            throw new Error("not yet implemented");
        }
        private static DateToTicks(year: number, month: number, day: number): number {
            throw new Error("not yet implemented");
        }
        private static DaysToYear(year: number): number {
            throw new Error("not yet implemented");
        }
        private static TimeToTicks(hour: number, minute: number, second: number): number {
            throw new Error("not yet implemented");
        }
        private static TimeToTicks(hour: number, minute: number, second: number, millisecond: number): number {
            throw new Error("not yet implemented");
        }
        private static TimeToTicks(hour: number, minute: number, second: number, millisecond: number, microsecond: number): number {
            throw new Error("not yet implemented");
        }
        public static DaysInMonth(year: number, month: number): number {
            throw new Error("not yet implemented");
        }
        private static DoubleDateToTicks(value: number): number {
            throw new Error("not yet implemented");
        }
        public Equals(value: any): boolean {
            throw new Error("not yet implemented");
        }
        public Equals(value: DateTime): boolean {
            throw new Error("not yet implemented");
        }
        public static Equals(t1: DateTime, t2: DateTime): boolean {
            throw new Error("not yet implemented");
        }
        public static FromBinary(dateData: number): DateTime {
            throw new Error("not yet implemented");
        }
        public static FromFileTime(fileTime: number): DateTime {
            throw new Error("not yet implemented");
        }
        public static FromFileTimeUtc(fileTime: number): DateTime {
            throw new Error("not yet implemented");
        }
        public static FromOADate(d: number): DateTime {
            throw new Error("not yet implemented");
        }
        private __explicit__ISerializable_GetObjectData(info: SerializationInfo, context: StreamingContext) {
            throw new Error("not yet implemented");
        }
        public GetObjectData(info: SerializationInfo, context: StreamingContext) {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        public IsDaylightSavingTime(): boolean {
            throw new Error("not yet implemented");
        }
        public static SpecifyKind(value: DateTime, kind: DateTimeKind): DateTime {
            throw new Error("not yet implemented");
        }
        public ToBinary(): number {
            throw new Error("not yet implemented");
        }
        private GetDate(out year: number, out month: number, out day: number) {
            throw new Error("not yet implemented");
        }
        private GetTime(out hour: number, out minute: number, out second: number) {
            throw new Error("not yet implemented");
        }
        private GetTime(out hour: number, out minute: number, out second: number, out millisecond: number) {
            throw new Error("not yet implemented");
        }
        private GetTimePrecise(out hour: number, out minute: number, out second: number, out tick: number) {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        private IsAmbiguousDaylightSavingTime(): boolean {
            throw new Error("not yet implemented");
        }
        public static IsLeapYear(year: number): boolean {
            throw new Error("not yet implemented");
        }
        public static Parse(s: string): DateTime {
            throw new Error("not yet implemented");
        }
        public static Parse(s: string, provider: IFormatProvider): DateTime {
            throw new Error("not yet implemented");
        }
        public static Parse(s: string, provider: IFormatProvider, styles: DateTimeStyles): DateTime {
            throw new Error("not yet implemented");
        }
        public static Parse(s: ReadOnlySpan<string>, provider: IFormatProvider, styles: DateTimeStyles): DateTime {
            throw new Error("not yet implemented");
        }
        public static ParseExact(s: string, format: string, provider: IFormatProvider): DateTime {
            throw new Error("not yet implemented");
        }
        public static ParseExact(s: string, format: string, provider: IFormatProvider, style: DateTimeStyles): DateTime {
            throw new Error("not yet implemented");
        }
        public static ParseExact(s: ReadOnlySpan<string>, format: ReadOnlySpan<string>, provider: IFormatProvider, style: DateTimeStyles): DateTime {
            throw new Error("not yet implemented");
        }
        public static ParseExact(s: string, formats: string[], provider: IFormatProvider, style: DateTimeStyles): DateTime {
            throw new Error("not yet implemented");
        }
        public static ParseExact(s: ReadOnlySpan<string>, formats: string[], provider: IFormatProvider, style: DateTimeStyles): DateTime {
            throw new Error("not yet implemented");
        }
        public Subtract(value: DateTime): TimeSpan {
            throw new Error("not yet implemented");
        }
        public Subtract(value: TimeSpan): DateTime {
            throw new Error("not yet implemented");
        }
        private static TicksToOADate(value: number): number {
            throw new Error("not yet implemented");
        }
        public ToOADate(): number {
            throw new Error("not yet implemented");
        }
        public ToFileTime(): number {
            throw new Error("not yet implemented");
        }
        public ToFileTimeUtc(): number {
            throw new Error("not yet implemented");
        }
        public ToLocalTime(): DateTime {
            throw new Error("not yet implemented");
        }
        public ToLongDateString(): string {
            throw new Error("not yet implemented");
        }
        public ToLongTimeString(): string {
            throw new Error("not yet implemented");
        }
        public ToShortDateString(): string {
            throw new Error("not yet implemented");
        }
        public ToShortTimeString(): string {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
        public ToString(format: string): string {
            throw new Error("not yet implemented");
        }
        public ToString(provider: IFormatProvider): string {
            throw new Error("not yet implemented");
        }
        public ToString(format: string, provider: IFormatProvider): string {
            throw new Error("not yet implemented");
        }
        public TryFormat(destination: Span<string>, out charsWritten: number, format: ReadOnlySpan<string>, provider: IFormatProvider): boolean {
            throw new Error("not yet implemented");
        }
        public TryFormat(utf8Destination: Span<number>, out bytesWritten: number, format: ReadOnlySpan<string>, provider: IFormatProvider): boolean {
            throw new Error("not yet implemented");
        }
        public ToUniversalTime(): DateTime {
            throw new Error("not yet implemented");
        }
        public static TryParse(s: string, out result: DateTime): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParse(s: ReadOnlySpan<string>, out result: DateTime): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParse(s: string, provider: IFormatProvider, styles: DateTimeStyles, out result: DateTime): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParse(s: ReadOnlySpan<string>, provider: IFormatProvider, styles: DateTimeStyles, out result: DateTime): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParseExact(s: string, format: string, provider: IFormatProvider, style: DateTimeStyles, out result: DateTime): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParseExact(s: ReadOnlySpan<string>, format: ReadOnlySpan<string>, provider: IFormatProvider, style: DateTimeStyles, out result: DateTime): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParseExact(s: string, formats: string[], provider: IFormatProvider, style: DateTimeStyles, out result: DateTime): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParseExact(s: ReadOnlySpan<string>, formats: string[], provider: IFormatProvider, style: DateTimeStyles, out result: DateTime): boolean {
            throw new Error("not yet implemented");
        }
        public Deconstruct(out date: DateOnly, out time: TimeOnly) {
            throw new Error("not yet implemented");
        }
        public Deconstruct(out year: number, out month: number, out day: number) {
            throw new Error("not yet implemented");
        }
        public GetDateTimeFormats(): string[] {
            throw new Error("not yet implemented");
        }
        public GetDateTimeFormats(provider: IFormatProvider): string[] {
            throw new Error("not yet implemented");
        }
        public GetDateTimeFormats(format: string): string[] {
            throw new Error("not yet implemented");
        }
        public GetDateTimeFormats(format: string, provider: IFormatProvider): string[] {
            throw new Error("not yet implemented");
        }
        public GetTypeCode(): TypeCode {
            throw new Error("not yet implemented");
        }
        private __explicit__IConvertible_ToBoolean(provider: IFormatProvider): boolean {
            throw new Error("not yet implemented");
        }
        public ToBoolean(provider: IFormatProvider): boolean {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__IConvertible_ToChar(provider: IFormatProvider): string {
            throw new Error("not yet implemented");
        }
        public ToChar(provider: IFormatProvider): string {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__IConvertible_ToSByte(provider: IFormatProvider): number {
            throw new Error("not yet implemented");
        }
        public ToSByte(provider: IFormatProvider): number {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__IConvertible_ToByte(provider: IFormatProvider): number {
            throw new Error("not yet implemented");
        }
        public ToByte(provider: IFormatProvider): number {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__IConvertible_ToInt16(provider: IFormatProvider): number {
            throw new Error("not yet implemented");
        }
        public ToInt16(provider: IFormatProvider): number {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__IConvertible_ToUInt16(provider: IFormatProvider): number {
            throw new Error("not yet implemented");
        }
        public ToUInt16(provider: IFormatProvider): number {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__IConvertible_ToInt32(provider: IFormatProvider): number {
            throw new Error("not yet implemented");
        }
        public ToInt32(provider: IFormatProvider): number {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__IConvertible_ToUInt32(provider: IFormatProvider): number {
            throw new Error("not yet implemented");
        }
        public ToUInt32(provider: IFormatProvider): number {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__IConvertible_ToInt64(provider: IFormatProvider): number {
            throw new Error("not yet implemented");
        }
        public ToInt64(provider: IFormatProvider): number {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__IConvertible_ToUInt64(provider: IFormatProvider): number {
            throw new Error("not yet implemented");
        }
        public ToUInt64(provider: IFormatProvider): number {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__IConvertible_ToSingle(provider: IFormatProvider): number {
            throw new Error("not yet implemented");
        }
        public ToSingle(provider: IFormatProvider): number {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__IConvertible_ToDouble(provider: IFormatProvider): number {
            throw new Error("not yet implemented");
        }
        public ToDouble(provider: IFormatProvider): number {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__IConvertible_ToDecimal(provider: IFormatProvider): number {
            throw new Error("not yet implemented");
        }
        public ToDecimal(provider: IFormatProvider): number {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private static InvalidCast(to: string): InvalidCastException {
            throw new Error("not yet implemented");
        }
        private __explicit__IConvertible_ToDateTime(provider: IFormatProvider): DateTime {
            throw new Error("not yet implemented");
        }
        public ToDateTime(provider: IFormatProvider): DateTime {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__IConvertible_ToType(type: Type, provider: IFormatProvider): any {
            throw new Error("not yet implemented");
        }
        public ToType(type: Type, provider: IFormatProvider): any {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private static TryCreate(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, out result: DateTime): boolean {
            throw new Error("not yet implemented");
        }
        public static TryParse(s: string, provider: IFormatProvider, out result: DateTime): boolean {
            throw new Error("not yet implemented");
        }
        public static Parse(s: ReadOnlySpan<string>, provider: IFormatProvider): DateTime {
            throw new Error("not yet implemented");
        }
        public static TryParse(s: ReadOnlySpan<string>, provider: IFormatProvider, out result: DateTime): boolean {
            throw new Error("not yet implemented");
        }
        private static IsValidTimeWithLeapSeconds(year: number, month: number, day: number, hour: number, minute: number, kind: DateTimeKind): boolean {
            throw new Error("not yet implemented");
        }
        private static FromFileTimeLeapSecondsAware(fileTime: number): DateTime {
            throw new Error("not yet implemented");
        }
        private static ToFileTimeLeapSecondsAware(ticks: number): number {
            throw new Error("not yet implemented");
        }
        private static CreateDateTimeFromSystemTime(ref time: SYSTEMTIME, hundredNanoSecond: number): DateTime {
            throw new Error("not yet implemented");
        }
        private static GetSystemSupportsLeapSeconds(): boolean {
            throw new Error("not yet implemented");
        }
        private static GetGetSystemTimeAsFileTimeFnPtr(): _ {
            throw new Error("not yet implemented");
        }
        private static UpdateLeapSecondCacheAndReturnUtcNow(): DateTime {
            throw new Error("not yet implemented");
        }
        private static __UpdateLeapSecondCacheAndReturnUtcNow__g__LowGranularityNonCachedFallback_248_0(): DateTime {
            throw new Error("not yet implemented");
        }
    }
    export namespace DateTime {
        export class LeapSecondCache {
            private static s_leapSecondCache: LeapSecondCache;
            private static readonly s_systemSupportsLeapSeconds: boolean;
            private static readonly s_pfnGetSystemTimeAsFileTime: _;

            private OSFileTimeTicksAtStartOfValidityWindow: number;
            private DotnetDateDataAtStartOfValidityWindow: number;

            public constructor() {
                throw new Error("not yet implemented");
            }
            private static staticctor_initialize = (() => {
                throw new Error("not yet implemented");
            })();
            private constructor() { }

        }
    }
    export interface IConvertible {
        GetTypeCode(): TypeCode;
        ToBoolean(provider: IFormatProvider): boolean;
        ToChar(provider: IFormatProvider): string;
        ToSByte(provider: IFormatProvider): number;
        ToByte(provider: IFormatProvider): number;
        ToInt16(provider: IFormatProvider): number;
        ToUInt16(provider: IFormatProvider): number;
        ToInt32(provider: IFormatProvider): number;
        ToUInt32(provider: IFormatProvider): number;
        ToInt64(provider: IFormatProvider): number;
        ToUInt64(provider: IFormatProvider): number;
        ToSingle(provider: IFormatProvider): number;
        ToDouble(provider: IFormatProvider): number;
        ToDecimal(provider: IFormatProvider): number;
        ToDateTime(provider: IFormatProvider): DateTime;
        ToString(provider: IFormatProvider): string;
        ToType(conversionType: Type, provider: IFormatProvider): any;
    }
    export class ArgumentException extends SystemException implements ISerializable {
        private _paramName: string;

        public get Message(): string {
            throw new Error("not yet implemented");
        }
        public get ParamName(): string {
            throw new Error("not yet implemented");
        }

        public constructor() {
            throw new Error("not yet implemented");
        }
        public constructor(message: string) {
            throw new Error("not yet implemented");
        }
        public constructor(message: string, innerException: Exception) {
            throw new Error("not yet implemented");
        }
        public constructor(message: string, paramName: string, innerException: Exception) {
            throw new Error("not yet implemented");
        }
        public constructor(message: string, paramName: string) {
            throw new Error("not yet implemented");
        }
        protected constructor(info: SerializationInfo, context: StreamingContext) {
            throw new Error("not yet implemented");
        }

        public GetObjectData(info: SerializationInfo, context: StreamingContext) {
            throw new Error("not yet implemented");
        }
        private SetMessageField() {
            throw new Error("not yet implemented");
        }
        public static ThrowIfNullOrEmpty(argument: string, paramName: string) {
            throw new Error("not yet implemented");
        }
        public static ThrowIfNullOrWhiteSpace(argument: string, paramName: string) {
            throw new Error("not yet implemented");
        }
        private static ThrowNullOrEmptyException(argument: string, paramName: string) {
            throw new Error("not yet implemented");
        }
        private static ThrowNullOrWhiteSpaceException(argument: string, paramName: string) {
            throw new Error("not yet implemented");
        }
    }
    export abstract class Type extends MemberInfo implements ICustomAttributeProvider, IReflect {
        private static s_defaultBinder: Binder;
        public static readonly Delimiter: string;
        public static readonly EmptyTypes: Type[];
        public static readonly Missing: any;
        public static readonly FilterAttribute: MemberFilter;
        public static readonly FilterName: MemberFilter;
        public static readonly FilterNameIgnoreCase: MemberFilter;

        public static get DefaultBinder(): Binder {
            throw new Error("not yet implemented");
        }

        public get IsInterface(): boolean {
            throw new Error("not yet implemented");
        }
        public get MemberType(): MemberTypes {
            throw new Error("not yet implemented");
        }
        public get Namespace(): string;
        public get AssemblyQualifiedName(): string;
        public get FullName(): string;
        public get Assembly(): Assembly;
        public get Module(): Module;
        public get IsNested(): boolean {
            throw new Error("not yet implemented");
        }
        public get DeclaringType(): Type {
            throw new Error("not yet implemented");
        }
        public get DeclaringMethod(): MethodBase {
            throw new Error("not yet implemented");
        }
        public get ReflectedType(): Type {
            throw new Error("not yet implemented");
        }
        public get UnderlyingSystemType(): Type;
        public get IsTypeDefinition(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsArray(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsByRef(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsPointer(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsConstructedGenericType(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsGenericParameter(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsGenericTypeParameter(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsGenericMethodParameter(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsGenericType(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsGenericTypeDefinition(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsSZArray(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsVariableBoundArray(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsByRefLike(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsFunctionPointer(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsUnmanagedFunctionPointer(): boolean {
            throw new Error("not yet implemented");
        }
        public get HasElementType(): boolean {
            throw new Error("not yet implemented");
        }
        public get GenericTypeArguments(): Type[] {
            throw new Error("not yet implemented");
        }
        public get GenericParameterPosition(): number {
            throw new Error("not yet implemented");
        }
        public get GenericParameterAttributes(): GenericParameterAttributes {
            throw new Error("not yet implemented");
        }
        public get Attributes(): TypeAttributes {
            throw new Error("not yet implemented");
        }
        public get IsAbstract(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsImport(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsSealed(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsSpecialName(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsClass(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsNestedAssembly(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsNestedFamANDAssem(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsNestedFamily(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsNestedFamORAssem(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsNestedPrivate(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsNestedPublic(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsNotPublic(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsPublic(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsAutoLayout(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsExplicitLayout(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsLayoutSequential(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsAnsiClass(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsAutoClass(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsUnicodeClass(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsCOMObject(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsContextful(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsEnum(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsMarshalByRef(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsPrimitive(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsValueType(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsSignatureType(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsSecurityCritical(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsSecuritySafeCritical(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsSecurityTransparent(): boolean {
            throw new Error("not yet implemented");
        }
        public get StructLayoutAttribute(): StructLayoutAttribute {
            throw new Error("not yet implemented");
        }
        public get TypeInitializer(): ConstructorInfo {
            throw new Error("not yet implemented");
        }
        public get TypeHandle(): RuntimeTypeHandle {
            throw new Error("not yet implemented");
        }
        public get GUID(): Guid;
        public get BaseType(): Type;
        public get IsSerializable(): boolean {
            throw new Error("not yet implemented");
        }
        public get ContainsGenericParameters(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsVisible(): boolean {
            throw new Error("not yet implemented");
        }

        protected constructor() {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

        public static GetType(typeName: string, throwOnError: boolean, ignoreCase: boolean): Type {
            throw new Error("not yet implemented");
        }
        public static GetType(typeName: string, throwOnError: boolean): Type {
            throw new Error("not yet implemented");
        }
        public static GetType(typeName: string): Type {
            throw new Error("not yet implemented");
        }
        public static GetType(typeName: string, assemblyResolver: Func<AssemblyName, Assembly>, typeResolver: Func<Assembly, string, boolean, Type>): Type {
            throw new Error("not yet implemented");
        }
        public static GetType(typeName: string, assemblyResolver: Func<AssemblyName, Assembly>, typeResolver: Func<Assembly, string, boolean, Type>, throwOnError: boolean): Type {
            throw new Error("not yet implemented");
        }
        public static GetType(typeName: string, assemblyResolver: Func<AssemblyName, Assembly>, typeResolver: Func<Assembly, string, boolean, Type>, throwOnError: boolean, ignoreCase: boolean): Type {
            throw new Error("not yet implemented");
        }
        private static GetTypeFromHandleUnsafe(handle: number): RuntimeType {
            throw new Error("not yet implemented");
        }
        public static GetTypeFromHandle(handle: RuntimeTypeHandle): Type {
            throw new Error("not yet implemented");
        }
        public GetType(): Type {
            throw new Error("not yet implemented");
        }
        private IsArrayImpl(): boolean;
        private IsByRefImpl(): boolean;
        private IsPointerImpl(): boolean;
        private HasElementTypeImpl(): boolean;
        public GetElementType(): Type;
        public GetArrayRank(): number {
            throw new Error("not yet implemented");
        }
        public GetGenericTypeDefinition(): Type {
            throw new Error("not yet implemented");
        }
        public GetGenericArguments(): Type[] {
            throw new Error("not yet implemented");
        }
        public GetOptionalCustomModifiers(): Type[] {
            throw new Error("not yet implemented");
        }
        public GetRequiredCustomModifiers(): Type[] {
            throw new Error("not yet implemented");
        }
        public GetGenericParameterConstraints(): Type[] {
            throw new Error("not yet implemented");
        }
        private GetAttributeFlagsImpl(): TypeAttributes;
        private IsCOMObjectImpl(): boolean;
        private IsContextfulImpl(): boolean {
            throw new Error("not yet implemented");
        }
        private IsMarshalByRefImpl(): boolean {
            throw new Error("not yet implemented");
        }
        private IsPrimitiveImpl(): boolean;
        private IsValueTypeImpl(): boolean {
            throw new Error("not yet implemented");
        }
        public IsAssignableTo(targetType: Type): boolean {
            throw new Error("not yet implemented");
        }
        public GetConstructor(types: Type[]): ConstructorInfo {
            throw new Error("not yet implemented");
        }
        public GetConstructor(bindingAttr: BindingFlags, types: Type[]): ConstructorInfo {
            throw new Error("not yet implemented");
        }
        public GetConstructor(bindingAttr: BindingFlags, binder: Binder, types: Type[], modifiers: ParameterModifier[]): ConstructorInfo {
            throw new Error("not yet implemented");
        }
        public GetConstructor(bindingAttr: BindingFlags, binder: Binder, callConvention: CallingConventions, types: Type[], modifiers: ParameterModifier[]): ConstructorInfo {
            throw new Error("not yet implemented");
        }
        private GetConstructorImpl(bindingAttr: BindingFlags, binder: Binder, callConvention: CallingConventions, types: Type[], modifiers: ParameterModifier[]): ConstructorInfo;
        public GetConstructors(): ConstructorInfo[] {
            throw new Error("not yet implemented");
        }
        public GetConstructors(bindingAttr: BindingFlags): ConstructorInfo[];
        public GetEvent(name: string): EventInfo {
            throw new Error("not yet implemented");
        }
        public GetEvent(name: string, bindingAttr: BindingFlags): EventInfo;
        public GetEvents(): EventInfo[] {
            throw new Error("not yet implemented");
        }
        public GetEvents(bindingAttr: BindingFlags): EventInfo[];
        public GetField(name: string): FieldInfo {
            throw new Error("not yet implemented");
        }
        public GetField(name: string, bindingAttr: BindingFlags): FieldInfo;
        public GetFields(): FieldInfo[] {
            throw new Error("not yet implemented");
        }
        public GetFields(bindingAttr: BindingFlags): FieldInfo[];
        public GetFunctionPointerCallingConventions(): Type[] {
            throw new Error("not yet implemented");
        }
        public GetFunctionPointerReturnType(): Type {
            throw new Error("not yet implemented");
        }
        public GetFunctionPointerParameterTypes(): Type[] {
            throw new Error("not yet implemented");
        }
        public GetMember(name: string): MemberInfo[] {
            throw new Error("not yet implemented");
        }
        public GetMember(name: string, bindingAttr: BindingFlags): MemberInfo[] {
            throw new Error("not yet implemented");
        }
        public GetMember(name: string, type: MemberTypes, bindingAttr: BindingFlags): MemberInfo[] {
            throw new Error("not yet implemented");
        }
        public GetMembers(): MemberInfo[] {
            throw new Error("not yet implemented");
        }
        public GetMemberWithSameMetadataDefinitionAs(member: MemberInfo): MemberInfo {
            throw new Error("not yet implemented");
        }
        private static CreateGetMemberWithSameMetadataDefinitionAsNotFoundException(member: MemberInfo): ArgumentException {
            throw new Error("not yet implemented");
        }
        public GetMembers(bindingAttr: BindingFlags): MemberInfo[];
        public GetMethod(name: string): MethodInfo {
            throw new Error("not yet implemented");
        }
        public GetMethod(name: string, bindingAttr: BindingFlags): MethodInfo {
            throw new Error("not yet implemented");
        }
        public GetMethod(name: string, bindingAttr: BindingFlags, types: Type[]): MethodInfo {
            throw new Error("not yet implemented");
        }
        public GetMethod(name: string, types: Type[]): MethodInfo {
            throw new Error("not yet implemented");
        }
        public GetMethod(name: string, types: Type[], modifiers: ParameterModifier[]): MethodInfo {
            throw new Error("not yet implemented");
        }
        public GetMethod(name: string, bindingAttr: BindingFlags, binder: Binder, types: Type[], modifiers: ParameterModifier[]): MethodInfo {
            throw new Error("not yet implemented");
        }
        public GetMethod(name: string, bindingAttr: BindingFlags, binder: Binder, callConvention: CallingConventions, types: Type[], modifiers: ParameterModifier[]): MethodInfo {
            throw new Error("not yet implemented");
        }
        private GetMethodImpl(name: string, bindingAttr: BindingFlags, binder: Binder, callConvention: CallingConventions, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
        public GetMethod(name: string, genericParameterCount: number, types: Type[]): MethodInfo {
            throw new Error("not yet implemented");
        }
        public GetMethod(name: string, genericParameterCount: number, types: Type[], modifiers: ParameterModifier[]): MethodInfo {
            throw new Error("not yet implemented");
        }
        public GetMethod(name: string, genericParameterCount: number, bindingAttr: BindingFlags, binder: Binder, types: Type[], modifiers: ParameterModifier[]): MethodInfo {
            throw new Error("not yet implemented");
        }
        public GetMethod(name: string, genericParameterCount: number, bindingAttr: BindingFlags, binder: Binder, callConvention: CallingConventions, types: Type[], modifiers: ParameterModifier[]): MethodInfo {
            throw new Error("not yet implemented");
        }
        private GetMethodImpl(name: string, genericParameterCount: number, bindingAttr: BindingFlags, binder: Binder, callConvention: CallingConventions, types: Type[], modifiers: ParameterModifier[]): MethodInfo {
            throw new Error("not yet implemented");
        }
        public GetMethods(): MethodInfo[] {
            throw new Error("not yet implemented");
        }
        public GetMethods(bindingAttr: BindingFlags): MethodInfo[];
        public GetNestedType(name: string): Type {
            throw new Error("not yet implemented");
        }
        public GetNestedType(name: string, bindingAttr: BindingFlags): Type;
        public GetNestedTypes(): Type[] {
            throw new Error("not yet implemented");
        }
        public GetNestedTypes(bindingAttr: BindingFlags): Type[];
        public GetProperty(name: string): PropertyInfo {
            throw new Error("not yet implemented");
        }
        public GetProperty(name: string, bindingAttr: BindingFlags): PropertyInfo {
            throw new Error("not yet implemented");
        }
        public GetProperty(name: string, returnType: Type): PropertyInfo {
            throw new Error("not yet implemented");
        }
        public GetProperty(name: string, types: Type[]): PropertyInfo {
            throw new Error("not yet implemented");
        }
        public GetProperty(name: string, returnType: Type, types: Type[]): PropertyInfo {
            throw new Error("not yet implemented");
        }
        public GetProperty(name: string, returnType: Type, types: Type[], modifiers: ParameterModifier[]): PropertyInfo {
            throw new Error("not yet implemented");
        }
        public GetProperty(name: string, bindingAttr: BindingFlags, binder: Binder, returnType: Type, types: Type[], modifiers: ParameterModifier[]): PropertyInfo {
            throw new Error("not yet implemented");
        }
        private GetPropertyImpl(name: string, bindingAttr: BindingFlags, binder: Binder, returnType: Type, types: Type[], modifiers: ParameterModifier[]): PropertyInfo;
        public GetProperties(): PropertyInfo[] {
            throw new Error("not yet implemented");
        }
        public GetProperties(bindingAttr: BindingFlags): PropertyInfo[];
        public GetDefaultMembers(): MemberInfo[] {
            throw new Error("not yet implemented");
        }
        public static GetTypeHandle(o: any): RuntimeTypeHandle {
            throw new Error("not yet implemented");
        }
        public static GetTypeArray(args: any[]): Type[] {
            throw new Error("not yet implemented");
        }
        public static GetTypeCode(type: Type): TypeCode {
            throw new Error("not yet implemented");
        }
        private static GetRuntimeTypeCode(type: RuntimeType): TypeCode {
            throw new Error("not yet implemented");
        }
        private GetTypeCodeImpl(): TypeCode {
            throw new Error("not yet implemented");
        }
        public static GetTypeFromCLSID(clsid: Guid): Type {
            throw new Error("not yet implemented");
        }
        public static GetTypeFromCLSID(clsid: Guid, throwOnError: boolean): Type {
            throw new Error("not yet implemented");
        }
        public static GetTypeFromCLSID(clsid: Guid, server: string): Type {
            throw new Error("not yet implemented");
        }
        public static GetTypeFromCLSID(clsid: Guid, server: string, throwOnError: boolean): Type {
            throw new Error("not yet implemented");
        }
        public static GetTypeFromProgID(progID: string): Type {
            throw new Error("not yet implemented");
        }
        public static GetTypeFromProgID(progID: string, throwOnError: boolean): Type {
            throw new Error("not yet implemented");
        }
        public static GetTypeFromProgID(progID: string, server: string): Type {
            throw new Error("not yet implemented");
        }
        public static GetTypeFromProgID(progID: string, server: string, throwOnError: boolean): Type {
            throw new Error("not yet implemented");
        }
        public InvokeMember(name: string, invokeAttr: BindingFlags, binder: Binder, target: any, args: any[]): any {
            throw new Error("not yet implemented");
        }
        public InvokeMember(name: string, invokeAttr: BindingFlags, binder: Binder, target: any, args: any[], culture: CultureInfo): any {
            throw new Error("not yet implemented");
        }
        public InvokeMember(name: string, invokeAttr: BindingFlags, binder: Binder, target: any, args: any[], modifiers: ParameterModifier[], culture: CultureInfo, namedParameters: string[]): any;
        public GetInterface(name: string): Type {
            throw new Error("not yet implemented");
        }
        public GetInterface(name: string, ignoreCase: boolean): Type;
        public GetInterfaces(): Type[];
        public GetInterfaceMap(interfaceType: Type): InterfaceMapping {
            throw new Error("not yet implemented");
        }
        public IsInstanceOfType(o: any): boolean {
            throw new Error("not yet implemented");
        }
        public IsEquivalentTo(other: Type): boolean {
            throw new Error("not yet implemented");
        }
        public GetEnumUnderlyingType(): Type {
            throw new Error("not yet implemented");
        }
        public GetEnumValues(): Array {
            throw new Error("not yet implemented");
        }
        public GetEnumValuesAsUnderlyingType(): Array {
            throw new Error("not yet implemented");
        }
        public MakeArrayType(): Type {
            throw new Error("not yet implemented");
        }
        public MakeArrayType(rank: number): Type {
            throw new Error("not yet implemented");
        }
        public MakeByRefType(): Type {
            throw new Error("not yet implemented");
        }
        public MakeGenericType(typeArguments: Type[]): Type {
            throw new Error("not yet implemented");
        }
        public MakePointerType(): Type {
            throw new Error("not yet implemented");
        }
        public static MakeGenericSignatureType(genericTypeDefinition: Type, typeArguments: Type[]): Type {
            throw new Error("not yet implemented");
        }
        public static MakeGenericMethodParameter(position: number): Type {
            throw new Error("not yet implemented");
        }
        private FormatTypeName(): string {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
        public Equals(o: any): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public Equals(o: Type): boolean {
            throw new Error("not yet implemented");
        }
        public static ReflectionOnlyGetType(typeName: string, throwIfNotFound: boolean, ignoreCase: boolean): Type {
            throw new Error("not yet implemented");
        }
        public IsEnumDefined(value: any): boolean {
            throw new Error("not yet implemented");
        }
        public GetEnumName(value: any): string {
            throw new Error("not yet implemented");
        }
        public GetEnumNames(): string[] {
            throw new Error("not yet implemented");
        }
        private GetEnumRawConstantValues(): Array {
            throw new Error("not yet implemented");
        }
        private GetEnumData(out enumNames: string[], out enumValues: Array) {
            throw new Error("not yet implemented");
        }
        private static BinarySearch(array: Array, value: any): number {
            throw new Error("not yet implemented");
        }
        private static IsIntegerType(t: Type): boolean {
            throw new Error("not yet implemented");
        }
        private GetRootElementType(): Type {
            throw new Error("not yet implemented");
        }
        public FindInterfaces(filter: TypeFilter, filterCriteria: any): Type[] {
            throw new Error("not yet implemented");
        }
        public FindMembers(memberType: MemberTypes, bindingAttr: BindingFlags, filter: MemberFilter, filterCriteria: any): MemberInfo[] {
            throw new Error("not yet implemented");
        }
        public IsSubclassOf(c: Type): boolean {
            throw new Error("not yet implemented");
        }
        public IsAssignableFrom(c: Type): boolean {
            throw new Error("not yet implemented");
        }
        private ImplementInterface(ifaceType: Type): boolean {
            throw new Error("not yet implemented");
        }
        private static FilterAttributeImpl(m: MemberInfo, filterCriteria: any): boolean {
            throw new Error("not yet implemented");
        }
        private static FilterNameImpl(m: MemberInfo, filterCriteria: any, comparison: StringComparison): boolean {
            throw new Error("not yet implemented");
        }
    }
    export namespace Type {
        export class ____c {
            public static readonly ____9: ____c;

            private static staticctor_initialize = (() => {
                throw new Error("not yet implemented");
            })();
            private constructor() { }
            public constructor() {
                throw new Error("not yet implemented");
            }

            private ___cctor__b__287_0(m: MemberInfo, c: any): boolean {
                throw new Error("not yet implemented");
            }
            private ___cctor__b__287_1(m: MemberInfo, c: any): boolean {
                throw new Error("not yet implemented");
            }
        }
    }
    export interface IFormatProvider {
        GetFormat(formatType: Type): any;
    }
    export interface IFormattable {
        ToString(format: string, formatProvider: IFormatProvider): string;
    }
    export interface ISpanFormattable implements IFormattable {
        TryFormat(destination: Span<string>, out charsWritten: number, format: ReadOnlySpan<string>, provider: IFormatProvider): boolean;
    }
}
export namespace System.Buffers {
    export class SearchValues<T> {
        private get DebuggerDisplay(): string {
            throw new Error("not yet implemented");
        }

        protected constructor() {
            throw new Error("not yet implemented");
        }

        private GetValues(): T[] {
            throw new Error("not yet implemented");
        }
        public Contains(value: T): boolean {
            throw new Error("not yet implemented");
        }
        private ContainsCore(value: T): boolean {
            throw new Error("not yet implemented");
        }
        private IndexOfAny(span: ReadOnlySpan<T>): number {
            throw new Error("not yet implemented");
        }
        private IndexOfAnyExcept(span: ReadOnlySpan<T>): number {
            throw new Error("not yet implemented");
        }
        private LastIndexOfAny(span: ReadOnlySpan<T>): number {
            throw new Error("not yet implemented");
        }
        private LastIndexOfAnyExcept(span: ReadOnlySpan<T>): number {
            throw new Error("not yet implemented");
        }
        private static IndexOfAny(span: ReadOnlySpan<T>, values: SearchValues<T>): number {
            throw new Error("not yet implemented");
        }
        private static IndexOfAnyExcept(span: ReadOnlySpan<T>, values: SearchValues<T>): number {
            throw new Error("not yet implemented");
        }
        private static LastIndexOfAny(span: ReadOnlySpan<T>, values: SearchValues<T>): number {
            throw new Error("not yet implemented");
        }
        private static LastIndexOfAnyExcept(span: ReadOnlySpan<T>, values: SearchValues<T>): number {
            throw new Error("not yet implemented");
        }
    }
    export interface IMemoryOwner<T> implements IDisposable {
        get Memory(): Memory<T>;

    }
    export class MemoryHandle extends ValueType implements IDisposable {
        private _pointer: void*;
        private _handle: GCHandle;
        private _pinnable: IPinnable;

        public get Pointer(): void* {
            throw new Error("not yet implemented");
        }

        public constructor(pointer: void*, handle: GCHandle, pinnable: IPinnable) {
            throw new Error("not yet implemented");
        }

        public Dispose() {
            throw new Error("not yet implemented");
        }
    }
    export interface IPinnable {
        Pin(elementIndex: number): MemoryHandle;
        Unpin(): void;
    }
    export abstract class MemoryManager<T> implements IMemoryOwner<T>, IDisposable, IPinnable {
        public get Memory(): Memory<T> {
            throw new Error("not yet implemented");
        }

        protected constructor() {
            throw new Error("not yet implemented");
        }

        public GetSpan(): Span<T>;
        public Pin(elementIndex: number): MemoryHandle;
        public Unpin(): void;
        private CreateMemory(length: number): Memory<T> {
            throw new Error("not yet implemented");
        }
        private CreateMemory(start: number, length: number): Memory<T> {
            throw new Error("not yet implemented");
        }
        private TryGetArray(out segment: ArraySegment<T>): boolean {
            throw new Error("not yet implemented");
        }
        private __explicit__IDisposable_Dispose() {
            throw new Error("not yet implemented");
        }
        private Dispose(disposing: boolean): void;
    }
    export enum OperationStatus {
        Done = 0,
        DestinationTooSmall = 1,
        NeedMoreData = 2,
        InvalidData = 3,
    }
}
export namespace System.Collections {
    export interface IEnumerator {
        get Current(): any;

        MoveNext(): boolean;
        Reset(): void;
    }
    export interface IEnumerable {
        GetEnumerator(): IEnumerator;
    }
    export interface IList implements ICollection, IEnumerable {
        get Item(): any;
        set Item(index: number);
        get IsReadOnly(): boolean;
        get IsFixedSize(): boolean;

        Add(value: any): number;
        Contains(value: any): boolean;
        Clear(): void;
        IndexOf(value: any): number;
        Insert(index: number, value: any): void;
        Remove(value: any): void;
        RemoveAt(index: number): void;
    }
    export interface IComparer {
        Compare(x: any, y: any): number;
    }
    export interface IStructuralComparable {
        CompareTo(other: any, comparer: IComparer): number;
    }
    export interface IEqualityComparer {
        Equals(x: any, y: any): boolean;
        GetHashCode(obj: any): number;
    }
    export interface IStructuralEquatable {
        Equals(other: any, comparer: IEqualityComparer): boolean;
        GetHashCode(comparer: IEqualityComparer): number;
    }
    export class ArrayList implements IList, ICollection, IEnumerable, ICloneable {
        private _items: any[];
        private _size: number;
        private _version: number;

        public get Capacity(): number {
            throw new Error("not yet implemented");
        }
        public set Capacity(value: number) {
            throw new Error("not yet implemented");
        }
        public get Count(): number {
            throw new Error("not yet implemented");
        }
        public get IsFixedSize(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsReadOnly(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsSynchronized(): boolean {
            throw new Error("not yet implemented");
        }
        public get SyncRoot(): any {
            throw new Error("not yet implemented");
        }
        public get Item(): any {
            throw new Error("not yet implemented");
        }
        public set Item(index: number) {
            throw new Error("not yet implemented");
        }

        public constructor() {
            throw new Error("not yet implemented");
        }
        public constructor(capacity: number) {
            throw new Error("not yet implemented");
        }
        public constructor(c: ICollection) {
            throw new Error("not yet implemented");
        }

        public static Adapter(list: IList): ArrayList {
            throw new Error("not yet implemented");
        }
        public Add(value: any): number {
            throw new Error("not yet implemented");
        }
        public AddRange(c: ICollection) {
            throw new Error("not yet implemented");
        }
        public BinarySearch(index: number, count: number, value: any, comparer: IComparer): number {
            throw new Error("not yet implemented");
        }
        public BinarySearch(value: any): number {
            throw new Error("not yet implemented");
        }
        public BinarySearch(value: any, comparer: IComparer): number {
            throw new Error("not yet implemented");
        }
        public Clear() {
            throw new Error("not yet implemented");
        }
        public Clone(): any {
            throw new Error("not yet implemented");
        }
        public Contains(item: any): boolean {
            throw new Error("not yet implemented");
        }
        public CopyTo(array: Array) {
            throw new Error("not yet implemented");
        }
        public CopyTo(array: Array, arrayIndex: number) {
            throw new Error("not yet implemented");
        }
        public CopyTo(index: number, array: Array, arrayIndex: number, count: number) {
            throw new Error("not yet implemented");
        }
        private EnsureCapacity(min: number) {
            throw new Error("not yet implemented");
        }
        public static FixedSize(list: IList): IList {
            throw new Error("not yet implemented");
        }
        public static FixedSize(list: ArrayList): ArrayList {
            throw new Error("not yet implemented");
        }
        public GetEnumerator(): IEnumerator {
            throw new Error("not yet implemented");
        }
        public GetEnumerator(index: number, count: number): IEnumerator {
            throw new Error("not yet implemented");
        }
        public IndexOf(value: any): number {
            throw new Error("not yet implemented");
        }
        public IndexOf(value: any, startIndex: number): number {
            throw new Error("not yet implemented");
        }
        public IndexOf(value: any, startIndex: number, count: number): number {
            throw new Error("not yet implemented");
        }
        public Insert(index: number, value: any) {
            throw new Error("not yet implemented");
        }
        public InsertRange(index: number, c: ICollection) {
            throw new Error("not yet implemented");
        }
        public LastIndexOf(value: any): number {
            throw new Error("not yet implemented");
        }
        public LastIndexOf(value: any, startIndex: number): number {
            throw new Error("not yet implemented");
        }
        public LastIndexOf(value: any, startIndex: number, count: number): number {
            throw new Error("not yet implemented");
        }
        public static ReadOnly(list: IList): IList {
            throw new Error("not yet implemented");
        }
        public static ReadOnly(list: ArrayList): ArrayList {
            throw new Error("not yet implemented");
        }
        public Remove(obj: any) {
            throw new Error("not yet implemented");
        }
        public RemoveAt(index: number) {
            throw new Error("not yet implemented");
        }
        public RemoveRange(index: number, count: number) {
            throw new Error("not yet implemented");
        }
        public static Repeat(value: any, count: number): ArrayList {
            throw new Error("not yet implemented");
        }
        public Reverse() {
            throw new Error("not yet implemented");
        }
        public Reverse(index: number, count: number) {
            throw new Error("not yet implemented");
        }
        public SetRange(index: number, c: ICollection) {
            throw new Error("not yet implemented");
        }
        public GetRange(index: number, count: number): ArrayList {
            throw new Error("not yet implemented");
        }
        public Sort() {
            throw new Error("not yet implemented");
        }
        public Sort(comparer: IComparer) {
            throw new Error("not yet implemented");
        }
        public Sort(index: number, count: number, comparer: IComparer) {
            throw new Error("not yet implemented");
        }
        public static Synchronized(list: IList): IList {
            throw new Error("not yet implemented");
        }
        public static Synchronized(list: ArrayList): ArrayList {
            throw new Error("not yet implemented");
        }
        public ToArray(): any[] {
            throw new Error("not yet implemented");
        }
        public ToArray(type: Type): Array {
            throw new Error("not yet implemented");
        }
        public TrimToSize() {
            throw new Error("not yet implemented");
        }
    }
    export namespace ArrayList {
        export class IListWrapper extends ArrayList implements IList, ICollection, IEnumerable, ICloneable {
            private _list: IList;

            public get Capacity(): number {
                throw new Error("not yet implemented");
            }
            public set Capacity(value: number) {
                throw new Error("not yet implemented");
            }
            public get Count(): number {
                throw new Error("not yet implemented");
            }
            public get IsReadOnly(): boolean {
                throw new Error("not yet implemented");
            }
            public get IsFixedSize(): boolean {
                throw new Error("not yet implemented");
            }
            public get IsSynchronized(): boolean {
                throw new Error("not yet implemented");
            }
            public get Item(): any {
                throw new Error("not yet implemented");
            }
            public set Item(index: number) {
                throw new Error("not yet implemented");
            }
            public get SyncRoot(): any {
                throw new Error("not yet implemented");
            }

            protected constructor(list: IList) {
                throw new Error("not yet implemented");
            }

            public Add(obj: any): number {
                throw new Error("not yet implemented");
            }
            public AddRange(c: ICollection) {
                throw new Error("not yet implemented");
            }
            public BinarySearch(index: number, count: number, value: any, comparer: IComparer): number {
                throw new Error("not yet implemented");
            }
            public Clear() {
                throw new Error("not yet implemented");
            }
            public Clone(): any {
                throw new Error("not yet implemented");
            }
            public Contains(obj: any): boolean {
                throw new Error("not yet implemented");
            }
            public CopyTo(array: Array, index: number) {
                throw new Error("not yet implemented");
            }
            public CopyTo(index: number, array: Array, arrayIndex: number, count: number) {
                throw new Error("not yet implemented");
            }
            public GetEnumerator(): IEnumerator {
                throw new Error("not yet implemented");
            }
            public GetEnumerator(index: number, count: number): IEnumerator {
                throw new Error("not yet implemented");
            }
            public IndexOf(value: any): number {
                throw new Error("not yet implemented");
            }
            public IndexOf(value: any, startIndex: number): number {
                throw new Error("not yet implemented");
            }
            public IndexOf(value: any, startIndex: number, count: number): number {
                throw new Error("not yet implemented");
            }
            public Insert(index: number, obj: any) {
                throw new Error("not yet implemented");
            }
            public InsertRange(index: number, c: ICollection) {
                throw new Error("not yet implemented");
            }
            public LastIndexOf(value: any): number {
                throw new Error("not yet implemented");
            }
            public LastIndexOf(value: any, startIndex: number): number {
                throw new Error("not yet implemented");
            }
            public LastIndexOf(value: any, startIndex: number, count: number): number {
                throw new Error("not yet implemented");
            }
            public Remove(value: any) {
                throw new Error("not yet implemented");
            }
            public RemoveAt(index: number) {
                throw new Error("not yet implemented");
            }
            public RemoveRange(index: number, count: number) {
                throw new Error("not yet implemented");
            }
            public Reverse(index: number, count: number) {
                throw new Error("not yet implemented");
            }
            public SetRange(index: number, c: ICollection) {
                throw new Error("not yet implemented");
            }
            public GetRange(index: number, count: number): ArrayList {
                throw new Error("not yet implemented");
            }
            public Sort(index: number, count: number, comparer: IComparer) {
                throw new Error("not yet implemented");
            }
            public ToArray(): any[] {
                throw new Error("not yet implemented");
            }
            public ToArray(type: Type): Array {
                throw new Error("not yet implemented");
            }
            public TrimToSize() {
                throw new Error("not yet implemented");
            }
        }
        export namespace IListWrapper {
            export class IListWrapperEnumWrapper implements IEnumerator, ICloneable {
                private _en: IEnumerator;
                private _remaining: number;
                private _initialStartIndex: number;
                private _initialCount: number;
                private _firstCall: boolean;

                public get Current(): any {
                    throw new Error("not yet implemented");
                }

                protected constructor(listWrapper: IListWrapper, startIndex: number, count: number) {
                    throw new Error("not yet implemented");
                }
                private constructor() {
                    throw new Error("not yet implemented");
                }

                public Clone(): any {
                    throw new Error("not yet implemented");
                }
                public MoveNext(): boolean {
                    throw new Error("not yet implemented");
                }
                public Reset() {
                    throw new Error("not yet implemented");
                }
            }
        }

        export class SyncArrayList extends ArrayList implements IList, ICollection, IEnumerable, ICloneable {
            private _list: ArrayList;
            private _root: any;

            public get Capacity(): number {
                throw new Error("not yet implemented");
            }
            public set Capacity(value: number) {
                throw new Error("not yet implemented");
            }
            public get Count(): number {
                throw new Error("not yet implemented");
            }
            public get IsReadOnly(): boolean {
                throw new Error("not yet implemented");
            }
            public get IsFixedSize(): boolean {
                throw new Error("not yet implemented");
            }
            public get IsSynchronized(): boolean {
                throw new Error("not yet implemented");
            }
            public get Item(): any {
                throw new Error("not yet implemented");
            }
            public set Item(index: number) {
                throw new Error("not yet implemented");
            }
            public get SyncRoot(): any {
                throw new Error("not yet implemented");
            }

            protected constructor(list: ArrayList) {
                throw new Error("not yet implemented");
            }

            public Add(value: any): number {
                throw new Error("not yet implemented");
            }
            public AddRange(c: ICollection) {
                throw new Error("not yet implemented");
            }
            public BinarySearch(value: any): number {
                throw new Error("not yet implemented");
            }
            public BinarySearch(value: any, comparer: IComparer): number {
                throw new Error("not yet implemented");
            }
            public BinarySearch(index: number, count: number, value: any, comparer: IComparer): number {
                throw new Error("not yet implemented");
            }
            public Clear() {
                throw new Error("not yet implemented");
            }
            public Clone(): any {
                throw new Error("not yet implemented");
            }
            public Contains(item: any): boolean {
                throw new Error("not yet implemented");
            }
            public CopyTo(array: Array) {
                throw new Error("not yet implemented");
            }
            public CopyTo(array: Array, index: number) {
                throw new Error("not yet implemented");
            }
            public CopyTo(index: number, array: Array, arrayIndex: number, count: number) {
                throw new Error("not yet implemented");
            }
            public GetEnumerator(): IEnumerator {
                throw new Error("not yet implemented");
            }
            public GetEnumerator(index: number, count: number): IEnumerator {
                throw new Error("not yet implemented");
            }
            public IndexOf(value: any): number {
                throw new Error("not yet implemented");
            }
            public IndexOf(value: any, startIndex: number): number {
                throw new Error("not yet implemented");
            }
            public IndexOf(value: any, startIndex: number, count: number): number {
                throw new Error("not yet implemented");
            }
            public Insert(index: number, value: any) {
                throw new Error("not yet implemented");
            }
            public InsertRange(index: number, c: ICollection) {
                throw new Error("not yet implemented");
            }
            public LastIndexOf(value: any): number {
                throw new Error("not yet implemented");
            }
            public LastIndexOf(value: any, startIndex: number): number {
                throw new Error("not yet implemented");
            }
            public LastIndexOf(value: any, startIndex: number, count: number): number {
                throw new Error("not yet implemented");
            }
            public Remove(value: any) {
                throw new Error("not yet implemented");
            }
            public RemoveAt(index: number) {
                throw new Error("not yet implemented");
            }
            public RemoveRange(index: number, count: number) {
                throw new Error("not yet implemented");
            }
            public Reverse(index: number, count: number) {
                throw new Error("not yet implemented");
            }
            public SetRange(index: number, c: ICollection) {
                throw new Error("not yet implemented");
            }
            public GetRange(index: number, count: number): ArrayList {
                throw new Error("not yet implemented");
            }
            public Sort() {
                throw new Error("not yet implemented");
            }
            public Sort(comparer: IComparer) {
                throw new Error("not yet implemented");
            }
            public Sort(index: number, count: number, comparer: IComparer) {
                throw new Error("not yet implemented");
            }
            public ToArray(): any[] {
                throw new Error("not yet implemented");
            }
            public ToArray(type: Type): Array {
                throw new Error("not yet implemented");
            }
            public TrimToSize() {
                throw new Error("not yet implemented");
            }
        }

        export class SyncIList implements IList, ICollection, IEnumerable {
            private _list: IList;
            private _root: any;

            public get Count(): number {
                throw new Error("not yet implemented");
            }
            public get IsReadOnly(): boolean {
                throw new Error("not yet implemented");
            }
            public get IsFixedSize(): boolean {
                throw new Error("not yet implemented");
            }
            public get IsSynchronized(): boolean {
                throw new Error("not yet implemented");
            }
            public get Item(): any {
                throw new Error("not yet implemented");
            }
            public set Item(index: number) {
                throw new Error("not yet implemented");
            }
            public get SyncRoot(): any {
                throw new Error("not yet implemented");
            }

            protected constructor(list: IList) {
                throw new Error("not yet implemented");
            }

            public Add(value: any): number {
                throw new Error("not yet implemented");
            }
            public Clear() {
                throw new Error("not yet implemented");
            }
            public Contains(item: any): boolean {
                throw new Error("not yet implemented");
            }
            public CopyTo(array: Array, index: number) {
                throw new Error("not yet implemented");
            }
            public GetEnumerator(): IEnumerator {
                throw new Error("not yet implemented");
            }
            public IndexOf(value: any): number {
                throw new Error("not yet implemented");
            }
            public Insert(index: number, value: any) {
                throw new Error("not yet implemented");
            }
            public Remove(value: any) {
                throw new Error("not yet implemented");
            }
            public RemoveAt(index: number) {
                throw new Error("not yet implemented");
            }
        }

        export class FixedSizeList implements IList, ICollection, IEnumerable {
            private _list: IList;

            public get Count(): number {
                throw new Error("not yet implemented");
            }
            public get IsReadOnly(): boolean {
                throw new Error("not yet implemented");
            }
            public get IsFixedSize(): boolean {
                throw new Error("not yet implemented");
            }
            public get IsSynchronized(): boolean {
                throw new Error("not yet implemented");
            }
            public get Item(): any {
                throw new Error("not yet implemented");
            }
            public set Item(index: number) {
                throw new Error("not yet implemented");
            }
            public get SyncRoot(): any {
                throw new Error("not yet implemented");
            }

            protected constructor(l: IList) {
                throw new Error("not yet implemented");
            }

            public Add(obj: any): number {
                throw new Error("not yet implemented");
            }
            public Clear() {
                throw new Error("not yet implemented");
            }
            public Contains(obj: any): boolean {
                throw new Error("not yet implemented");
            }
            public CopyTo(array: Array, index: number) {
                throw new Error("not yet implemented");
            }
            public GetEnumerator(): IEnumerator {
                throw new Error("not yet implemented");
            }
            public IndexOf(value: any): number {
                throw new Error("not yet implemented");
            }
            public Insert(index: number, obj: any) {
                throw new Error("not yet implemented");
            }
            public Remove(value: any) {
                throw new Error("not yet implemented");
            }
            public RemoveAt(index: number) {
                throw new Error("not yet implemented");
            }
        }

        export class FixedSizeArrayList extends ArrayList implements IList, ICollection, IEnumerable, ICloneable {
            private _list: ArrayList;

            public get Count(): number {
                throw new Error("not yet implemented");
            }
            public get IsReadOnly(): boolean {
                throw new Error("not yet implemented");
            }
            public get IsFixedSize(): boolean {
                throw new Error("not yet implemented");
            }
            public get IsSynchronized(): boolean {
                throw new Error("not yet implemented");
            }
            public get Item(): any {
                throw new Error("not yet implemented");
            }
            public set Item(index: number) {
                throw new Error("not yet implemented");
            }
            public get SyncRoot(): any {
                throw new Error("not yet implemented");
            }
            public get Capacity(): number {
                throw new Error("not yet implemented");
            }
            public set Capacity(value: number) {
                throw new Error("not yet implemented");
            }

            protected constructor(l: ArrayList) {
                throw new Error("not yet implemented");
            }

            public Add(obj: any): number {
                throw new Error("not yet implemented");
            }
            public AddRange(c: ICollection) {
                throw new Error("not yet implemented");
            }
            public BinarySearch(index: number, count: number, value: any, comparer: IComparer): number {
                throw new Error("not yet implemented");
            }
            public Clear() {
                throw new Error("not yet implemented");
            }
            public Clone(): any {
                throw new Error("not yet implemented");
            }
            public Contains(obj: any): boolean {
                throw new Error("not yet implemented");
            }
            public CopyTo(array: Array, index: number) {
                throw new Error("not yet implemented");
            }
            public CopyTo(index: number, array: Array, arrayIndex: number, count: number) {
                throw new Error("not yet implemented");
            }
            public GetEnumerator(): IEnumerator {
                throw new Error("not yet implemented");
            }
            public GetEnumerator(index: number, count: number): IEnumerator {
                throw new Error("not yet implemented");
            }
            public IndexOf(value: any): number {
                throw new Error("not yet implemented");
            }
            public IndexOf(value: any, startIndex: number): number {
                throw new Error("not yet implemented");
            }
            public IndexOf(value: any, startIndex: number, count: number): number {
                throw new Error("not yet implemented");
            }
            public Insert(index: number, obj: any) {
                throw new Error("not yet implemented");
            }
            public InsertRange(index: number, c: ICollection) {
                throw new Error("not yet implemented");
            }
            public LastIndexOf(value: any): number {
                throw new Error("not yet implemented");
            }
            public LastIndexOf(value: any, startIndex: number): number {
                throw new Error("not yet implemented");
            }
            public LastIndexOf(value: any, startIndex: number, count: number): number {
                throw new Error("not yet implemented");
            }
            public Remove(value: any) {
                throw new Error("not yet implemented");
            }
            public RemoveAt(index: number) {
                throw new Error("not yet implemented");
            }
            public RemoveRange(index: number, count: number) {
                throw new Error("not yet implemented");
            }
            public SetRange(index: number, c: ICollection) {
                throw new Error("not yet implemented");
            }
            public GetRange(index: number, count: number): ArrayList {
                throw new Error("not yet implemented");
            }
            public Reverse(index: number, count: number) {
                throw new Error("not yet implemented");
            }
            public Sort(index: number, count: number, comparer: IComparer) {
                throw new Error("not yet implemented");
            }
            public ToArray(): any[] {
                throw new Error("not yet implemented");
            }
            public ToArray(type: Type): Array {
                throw new Error("not yet implemented");
            }
            public TrimToSize() {
                throw new Error("not yet implemented");
            }
        }

        export class ReadOnlyList implements IList, ICollection, IEnumerable {
            private _list: IList;

            public get Count(): number {
                throw new Error("not yet implemented");
            }
            public get IsReadOnly(): boolean {
                throw new Error("not yet implemented");
            }
            public get IsFixedSize(): boolean {
                throw new Error("not yet implemented");
            }
            public get IsSynchronized(): boolean {
                throw new Error("not yet implemented");
            }
            public get Item(): any {
                throw new Error("not yet implemented");
            }
            public set Item(index: number) {
                throw new Error("not yet implemented");
            }
            public get SyncRoot(): any {
                throw new Error("not yet implemented");
            }

            protected constructor(l: IList) {
                throw new Error("not yet implemented");
            }

            public Add(obj: any): number {
                throw new Error("not yet implemented");
            }
            public Clear() {
                throw new Error("not yet implemented");
            }
            public Contains(obj: any): boolean {
                throw new Error("not yet implemented");
            }
            public CopyTo(array: Array, index: number) {
                throw new Error("not yet implemented");
            }
            public GetEnumerator(): IEnumerator {
                throw new Error("not yet implemented");
            }
            public IndexOf(value: any): number {
                throw new Error("not yet implemented");
            }
            public Insert(index: number, obj: any) {
                throw new Error("not yet implemented");
            }
            public Remove(value: any) {
                throw new Error("not yet implemented");
            }
            public RemoveAt(index: number) {
                throw new Error("not yet implemented");
            }
        }

        export class ReadOnlyArrayList extends ArrayList implements IList, ICollection, IEnumerable, ICloneable {
            private _list: ArrayList;

            public get Count(): number {
                throw new Error("not yet implemented");
            }
            public get IsReadOnly(): boolean {
                throw new Error("not yet implemented");
            }
            public get IsFixedSize(): boolean {
                throw new Error("not yet implemented");
            }
            public get IsSynchronized(): boolean {
                throw new Error("not yet implemented");
            }
            public get Item(): any {
                throw new Error("not yet implemented");
            }
            public set Item(index: number) {
                throw new Error("not yet implemented");
            }
            public get SyncRoot(): any {
                throw new Error("not yet implemented");
            }
            public get Capacity(): number {
                throw new Error("not yet implemented");
            }
            public set Capacity(value: number) {
                throw new Error("not yet implemented");
            }

            protected constructor(l: ArrayList) {
                throw new Error("not yet implemented");
            }

            public Add(obj: any): number {
                throw new Error("not yet implemented");
            }
            public AddRange(c: ICollection) {
                throw new Error("not yet implemented");
            }
            public BinarySearch(index: number, count: number, value: any, comparer: IComparer): number {
                throw new Error("not yet implemented");
            }
            public Clear() {
                throw new Error("not yet implemented");
            }
            public Clone(): any {
                throw new Error("not yet implemented");
            }
            public Contains(obj: any): boolean {
                throw new Error("not yet implemented");
            }
            public CopyTo(array: Array, index: number) {
                throw new Error("not yet implemented");
            }
            public CopyTo(index: number, array: Array, arrayIndex: number, count: number) {
                throw new Error("not yet implemented");
            }
            public GetEnumerator(): IEnumerator {
                throw new Error("not yet implemented");
            }
            public GetEnumerator(index: number, count: number): IEnumerator {
                throw new Error("not yet implemented");
            }
            public IndexOf(value: any): number {
                throw new Error("not yet implemented");
            }
            public IndexOf(value: any, startIndex: number): number {
                throw new Error("not yet implemented");
            }
            public IndexOf(value: any, startIndex: number, count: number): number {
                throw new Error("not yet implemented");
            }
            public Insert(index: number, obj: any) {
                throw new Error("not yet implemented");
            }
            public InsertRange(index: number, c: ICollection) {
                throw new Error("not yet implemented");
            }
            public LastIndexOf(value: any): number {
                throw new Error("not yet implemented");
            }
            public LastIndexOf(value: any, startIndex: number): number {
                throw new Error("not yet implemented");
            }
            public LastIndexOf(value: any, startIndex: number, count: number): number {
                throw new Error("not yet implemented");
            }
            public Remove(value: any) {
                throw new Error("not yet implemented");
            }
            public RemoveAt(index: number) {
                throw new Error("not yet implemented");
            }
            public RemoveRange(index: number, count: number) {
                throw new Error("not yet implemented");
            }
            public SetRange(index: number, c: ICollection) {
                throw new Error("not yet implemented");
            }
            public GetRange(index: number, count: number): ArrayList {
                throw new Error("not yet implemented");
            }
            public Reverse(index: number, count: number) {
                throw new Error("not yet implemented");
            }
            public Sort(index: number, count: number, comparer: IComparer) {
                throw new Error("not yet implemented");
            }
            public ToArray(): any[] {
                throw new Error("not yet implemented");
            }
            public ToArray(type: Type): Array {
                throw new Error("not yet implemented");
            }
            public TrimToSize() {
                throw new Error("not yet implemented");
            }
        }

        export class ArrayListEnumerator implements IEnumerator, ICloneable {
            private _list: ArrayList;
            private _index: number;
            private _endIndex: number;
            private _version: number;
            private _currentElement: any;
            private _startIndex: number;

            public get Current(): any {
                throw new Error("not yet implemented");
            }

            protected constructor(list: ArrayList, index: number, count: number) {
                throw new Error("not yet implemented");
            }

            public Clone(): any {
                throw new Error("not yet implemented");
            }
            public MoveNext(): boolean {
                throw new Error("not yet implemented");
            }
            public Reset() {
                throw new Error("not yet implemented");
            }
        }

        export class Range extends ArrayList implements IList, ICollection, IEnumerable, ICloneable {
            private _baseList: ArrayList;
            private _baseIndex: number;
            private _baseSize: number;
            private _baseVersion: number;

            public get Capacity(): number {
                throw new Error("not yet implemented");
            }
            public set Capacity(value: number) {
                throw new Error("not yet implemented");
            }
            public get Count(): number {
                throw new Error("not yet implemented");
            }
            public get IsReadOnly(): boolean {
                throw new Error("not yet implemented");
            }
            public get IsFixedSize(): boolean {
                throw new Error("not yet implemented");
            }
            public get IsSynchronized(): boolean {
                throw new Error("not yet implemented");
            }
            public get SyncRoot(): any {
                throw new Error("not yet implemented");
            }
            public get Item(): any {
                throw new Error("not yet implemented");
            }
            public set Item(index: number) {
                throw new Error("not yet implemented");
            }

            protected constructor(list: ArrayList, index: number, count: number) {
                throw new Error("not yet implemented");
            }

            private InternalUpdateRange() {
                throw new Error("not yet implemented");
            }
            private InternalUpdateVersion() {
                throw new Error("not yet implemented");
            }
            public Add(value: any): number {
                throw new Error("not yet implemented");
            }
            public AddRange(c: ICollection) {
                throw new Error("not yet implemented");
            }
            public BinarySearch(index: number, count: number, value: any, comparer: IComparer): number {
                throw new Error("not yet implemented");
            }
            public Clear() {
                throw new Error("not yet implemented");
            }
            public Clone(): any {
                throw new Error("not yet implemented");
            }
            public Contains(item: any): boolean {
                throw new Error("not yet implemented");
            }
            public CopyTo(array: Array, index: number) {
                throw new Error("not yet implemented");
            }
            public CopyTo(index: number, array: Array, arrayIndex: number, count: number) {
                throw new Error("not yet implemented");
            }
            public GetEnumerator(): IEnumerator {
                throw new Error("not yet implemented");
            }
            public GetEnumerator(index: number, count: number): IEnumerator {
                throw new Error("not yet implemented");
            }
            public GetRange(index: number, count: number): ArrayList {
                throw new Error("not yet implemented");
            }
            public IndexOf(value: any): number {
                throw new Error("not yet implemented");
            }
            public IndexOf(value: any, startIndex: number): number {
                throw new Error("not yet implemented");
            }
            public IndexOf(value: any, startIndex: number, count: number): number {
                throw new Error("not yet implemented");
            }
            public Insert(index: number, value: any) {
                throw new Error("not yet implemented");
            }
            public InsertRange(index: number, c: ICollection) {
                throw new Error("not yet implemented");
            }
            public LastIndexOf(value: any): number {
                throw new Error("not yet implemented");
            }
            public LastIndexOf(value: any, startIndex: number): number {
                throw new Error("not yet implemented");
            }
            public LastIndexOf(value: any, startIndex: number, count: number): number {
                throw new Error("not yet implemented");
            }
            public RemoveAt(index: number) {
                throw new Error("not yet implemented");
            }
            public RemoveRange(index: number, count: number) {
                throw new Error("not yet implemented");
            }
            public Reverse(index: number, count: number) {
                throw new Error("not yet implemented");
            }
            public SetRange(index: number, c: ICollection) {
                throw new Error("not yet implemented");
            }
            public Sort(index: number, count: number, comparer: IComparer) {
                throw new Error("not yet implemented");
            }
            public ToArray(): any[] {
                throw new Error("not yet implemented");
            }
            public ToArray(type: Type): Array {
                throw new Error("not yet implemented");
            }
            public TrimToSize() {
                throw new Error("not yet implemented");
            }
        }

        export class ArrayListEnumeratorSimple implements IEnumerator, ICloneable {
            private static readonly s_dummyObject: any;

            private _list: ArrayList;
            private _index: number;
            private _version: number;
            private _currentElement: any;
            private _isArrayList: boolean;

            public get Current(): any {
                throw new Error("not yet implemented");
            }

            protected constructor(list: ArrayList) {
                throw new Error("not yet implemented");
            }
            private static staticctor_initialize = (() => {
                throw new Error("not yet implemented");
            })();
            private constructor() { }

            public Clone(): any {
                throw new Error("not yet implemented");
            }
            public MoveNext(): boolean {
                throw new Error("not yet implemented");
            }
            public Reset() {
                throw new Error("not yet implemented");
            }
        }

        export class ArrayListDebugView {
            private _arrayList: ArrayList;

            public get Items(): any[] {
                throw new Error("not yet implemented");
            }

            public constructor(arrayList: ArrayList) {
                throw new Error("not yet implemented");
            }

        }
    }
    export class Bucket extends ValueType {
        public key: any;
        public val: any;
        public hash_coll: number;

    }
    export interface IHashCodeProvider {
        GetHashCode(obj: any): number;
    }
    export class KeyValuePairs {
        private _key: any;
        private _value: any;

        public constructor(key: any, value: any) {
            throw new Error("not yet implemented");
        }

    }
    export class DictionaryEntry extends ValueType {
        private _key: any;
        private _value: any;

        public get Key(): any {
            throw new Error("not yet implemented");
        }
        public set Key(value: any) {
            throw new Error("not yet implemented");
        }
        public get Value(): any {
            throw new Error("not yet implemented");
        }
        public set Value(value: any) {
            throw new Error("not yet implemented");
        }

        public constructor(key: any, value: any) {
            throw new Error("not yet implemented");
        }

        public Deconstruct(out key: any, out value: any) {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
    }
    export interface IDictionaryEnumerator implements IEnumerator {
        get Key(): any;
        get Value(): any;
        get Entry(): DictionaryEntry;

    }
    export class Hashtable implements IDictionary, ICollection, IEnumerable, ISerializable, IDeserializationCallback, ICloneable {
        private _buckets: Bucket[];
        private _count: number;
        private _occupancy: number;
        private _loadsize: number;
        private _loadFactor: number;
        private _version: number;
        private _isWriterInProgress: boolean;
        private _keys: ICollection;
        private _values: ICollection;
        private _keycomparer: IEqualityComparer;

        private get hcp(): IHashCodeProvider {
            throw new Error("not yet implemented");
        }
        private set hcp(value: IHashCodeProvider) {
            throw new Error("not yet implemented");
        }
        private get comparer(): IComparer {
            throw new Error("not yet implemented");
        }
        private set comparer(value: IComparer) {
            throw new Error("not yet implemented");
        }
        private get EqualityComparer(): IEqualityComparer {
            throw new Error("not yet implemented");
        }
        public get Item(): any {
            throw new Error("not yet implemented");
        }
        public set Item(key: any) {
            throw new Error("not yet implemented");
        }
        public get IsReadOnly(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsFixedSize(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsSynchronized(): boolean {
            throw new Error("not yet implemented");
        }
        public get Keys(): ICollection {
            throw new Error("not yet implemented");
        }
        public get Values(): ICollection {
            throw new Error("not yet implemented");
        }
        public get SyncRoot(): any {
            throw new Error("not yet implemented");
        }
        public get Count(): number {
            throw new Error("not yet implemented");
        }

        protected constructor(_: boolean) {
            throw new Error("not yet implemented");
        }
        public constructor() {
            throw new Error("not yet implemented");
        }
        public constructor(capacity: number) {
            throw new Error("not yet implemented");
        }
        public constructor(capacity: number, loadFactor: number) {
            throw new Error("not yet implemented");
        }
        public constructor(capacity: number, loadFactor: number, equalityComparer: IEqualityComparer) {
            throw new Error("not yet implemented");
        }
        public constructor(hcp: IHashCodeProvider, comparer: IComparer) {
            throw new Error("not yet implemented");
        }
        public constructor(equalityComparer: IEqualityComparer) {
            throw new Error("not yet implemented");
        }
        public constructor(capacity: number, hcp: IHashCodeProvider, comparer: IComparer) {
            throw new Error("not yet implemented");
        }
        public constructor(capacity: number, equalityComparer: IEqualityComparer) {
            throw new Error("not yet implemented");
        }
        public constructor(d: IDictionary) {
            throw new Error("not yet implemented");
        }
        public constructor(d: IDictionary, loadFactor: number) {
            throw new Error("not yet implemented");
        }
        public constructor(d: IDictionary, hcp: IHashCodeProvider, comparer: IComparer) {
            throw new Error("not yet implemented");
        }
        public constructor(d: IDictionary, equalityComparer: IEqualityComparer) {
            throw new Error("not yet implemented");
        }
        public constructor(capacity: number, loadFactor: number, hcp: IHashCodeProvider, comparer: IComparer) {
            throw new Error("not yet implemented");
        }
        public constructor(d: IDictionary, loadFactor: number, hcp: IHashCodeProvider, comparer: IComparer) {
            throw new Error("not yet implemented");
        }
        public constructor(d: IDictionary, loadFactor: number, equalityComparer: IEqualityComparer) {
            throw new Error("not yet implemented");
        }
        protected constructor(info: SerializationInfo, context: StreamingContext) {
            throw new Error("not yet implemented");
        }

        private InitHash(key: any, hashsize: number, out seed: number, out incr: number): number {
            throw new Error("not yet implemented");
        }
        public Add(key: any, value: any) {
            throw new Error("not yet implemented");
        }
        public Clear() {
            throw new Error("not yet implemented");
        }
        public Clone(): any {
            throw new Error("not yet implemented");
        }
        public Contains(key: any): boolean {
            throw new Error("not yet implemented");
        }
        public ContainsKey(key: any): boolean {
            throw new Error("not yet implemented");
        }
        public ContainsValue(value: any): boolean {
            throw new Error("not yet implemented");
        }
        private CopyKeys(array: Array, arrayIndex: number) {
            throw new Error("not yet implemented");
        }
        private CopyEntries(array: Array, arrayIndex: number) {
            throw new Error("not yet implemented");
        }
        public CopyTo(array: Array, arrayIndex: number) {
            throw new Error("not yet implemented");
        }
        private ToKeyValuePairsArray(): KeyValuePairs[] {
            throw new Error("not yet implemented");
        }
        private CopyValues(array: Array, arrayIndex: number) {
            throw new Error("not yet implemented");
        }
        private expand() {
            throw new Error("not yet implemented");
        }
        private rehash() {
            throw new Error("not yet implemented");
        }
        private UpdateVersion() {
            throw new Error("not yet implemented");
        }
        private rehash(newsize: number) {
            throw new Error("not yet implemented");
        }
        private __explicit__IEnumerable_GetEnumerator(): IEnumerator {
            throw new Error("not yet implemented");
        }
        public GetEnumerator(): IDictionaryEnumerator {
            throw new Error("not yet implemented");
        }
        private GetHash(key: any): number {
            throw new Error("not yet implemented");
        }
        private KeyEquals(item: any, key: any): boolean {
            throw new Error("not yet implemented");
        }
        private Insert(key: any, nvalue: any, add: boolean) {
            throw new Error("not yet implemented");
        }
        private putEntry(newBuckets: Bucket[], key: any, nvalue: any, hashcode: number) {
            throw new Error("not yet implemented");
        }
        public Remove(key: any) {
            throw new Error("not yet implemented");
        }
        public static Synchronized(table: Hashtable): Hashtable {
            throw new Error("not yet implemented");
        }
        public GetObjectData(info: SerializationInfo, context: StreamingContext) {
            throw new Error("not yet implemented");
        }
        public OnDeserialization(sender: any) {
            throw new Error("not yet implemented");
        }
    }
    export namespace Hashtable {
        export class Bucket extends ValueType {
            public key: any;
            public val: any;
            public hash_coll: number;

        }

        export class KeyCollection implements ICollection, IEnumerable {
            private _hashtable: Hashtable;

            public get IsSynchronized(): boolean {
                throw new Error("not yet implemented");
            }
            public get SyncRoot(): any {
                throw new Error("not yet implemented");
            }
            public get Count(): number {
                throw new Error("not yet implemented");
            }

            protected constructor(hashtable: Hashtable) {
                throw new Error("not yet implemented");
            }

            public CopyTo(array: Array, arrayIndex: number) {
                throw new Error("not yet implemented");
            }
            public GetEnumerator(): IEnumerator {
                throw new Error("not yet implemented");
            }
        }

        export class ValueCollection implements ICollection, IEnumerable {
            private _hashtable: Hashtable;

            public get IsSynchronized(): boolean {
                throw new Error("not yet implemented");
            }
            public get SyncRoot(): any {
                throw new Error("not yet implemented");
            }
            public get Count(): number {
                throw new Error("not yet implemented");
            }

            protected constructor(hashtable: Hashtable) {
                throw new Error("not yet implemented");
            }

            public CopyTo(array: Array, arrayIndex: number) {
                throw new Error("not yet implemented");
            }
            public GetEnumerator(): IEnumerator {
                throw new Error("not yet implemented");
            }
        }

        export class SyncHashtable extends Hashtable implements IDictionary, ICollection, IEnumerable, ISerializable, IDeserializationCallback, ICloneable {
            private _table: Hashtable;

            public get Count(): number {
                throw new Error("not yet implemented");
            }
            public get IsReadOnly(): boolean {
                throw new Error("not yet implemented");
            }
            public get IsFixedSize(): boolean {
                throw new Error("not yet implemented");
            }
            public get IsSynchronized(): boolean {
                throw new Error("not yet implemented");
            }
            public get Item(): any {
                throw new Error("not yet implemented");
            }
            public set Item(key: any) {
                throw new Error("not yet implemented");
            }
            public get SyncRoot(): any {
                throw new Error("not yet implemented");
            }
            public get Keys(): ICollection {
                throw new Error("not yet implemented");
            }
            public get Values(): ICollection {
                throw new Error("not yet implemented");
            }

            protected constructor(table: Hashtable) {
                throw new Error("not yet implemented");
            }

            public GetObjectData(info: SerializationInfo, context: StreamingContext) {
                throw new Error("not yet implemented");
            }
            public Add(key: any, value: any) {
                throw new Error("not yet implemented");
            }
            public Clear() {
                throw new Error("not yet implemented");
            }
            public Contains(key: any): boolean {
                throw new Error("not yet implemented");
            }
            public ContainsKey(key: any): boolean {
                throw new Error("not yet implemented");
            }
            public ContainsValue(key: any): boolean {
                throw new Error("not yet implemented");
            }
            public CopyTo(array: Array, arrayIndex: number) {
                throw new Error("not yet implemented");
            }
            public Clone(): any {
                throw new Error("not yet implemented");
            }
            private __explicit__IEnumerable_GetEnumerator(): IEnumerator {
                throw new Error("not yet implemented");
            }
            public GetEnumerator(): IDictionaryEnumerator {
                throw new Error("not yet implemented");
            }
            public Remove(key: any) {
                throw new Error("not yet implemented");
            }
            public OnDeserialization(sender: any) {
                throw new Error("not yet implemented");
            }
            private ToKeyValuePairsArray(): KeyValuePairs[] {
                throw new Error("not yet implemented");
            }
        }

        export class HashtableEnumerator implements IDictionaryEnumerator, IEnumerator, ICloneable {
            private _hashtable: Hashtable;
            private _bucket: number;
            private _version: number;
            private _current: boolean;
            private _getObjectRetType: number;
            private _currentKey: any;
            private _currentValue: any;

            public get Key(): any {
                throw new Error("not yet implemented");
            }
            public get Entry(): DictionaryEntry {
                throw new Error("not yet implemented");
            }
            public get Current(): any {
                throw new Error("not yet implemented");
            }
            public get Value(): any {
                throw new Error("not yet implemented");
            }

            protected constructor(hashtable: Hashtable, getObjRetType: number) {
                throw new Error("not yet implemented");
            }

            public Clone(): any {
                throw new Error("not yet implemented");
            }
            public MoveNext(): boolean {
                throw new Error("not yet implemented");
            }
            public Reset() {
                throw new Error("not yet implemented");
            }
        }

        export class HashtableDebugView {
            private _hashtable: Hashtable;

            public get Items(): KeyValuePairs[] {
                throw new Error("not yet implemented");
            }

            public constructor(hashtable: Hashtable) {
                throw new Error("not yet implemented");
            }

        }
    }
    export interface ICollection implements IEnumerable {
        get Count(): number;
        get SyncRoot(): any;
        get IsSynchronized(): boolean;

        CopyTo(array: Array, index: number): void;
    }
    export interface IDictionary implements ICollection, IEnumerable {
        get Item(): any;
        set Item(key: any);
        get Keys(): ICollection;
        get Values(): ICollection;
        get IsReadOnly(): boolean;
        get IsFixedSize(): boolean;

        Contains(key: any): boolean;
        Add(key: any, value: any): void;
        Clear(): void;
        GetEnumerator(): IDictionaryEnumerator;
        Remove(key: any): void;
    }
}
export namespace System.Collections.Generic {
    export interface IEnumerator<T> implements IDisposable, IEnumerator {
        get Current(): T;

    }
    export interface IEnumerable<T> implements IEnumerable {
        GetEnumerator(): IEnumerator<T>;
    }
    export interface ICollection<T> implements IEnumerable<T>, IEnumerable {
        get Count(): number;
        get IsReadOnly(): boolean;

        Add(item: T): void;
        Clear(): void;
        Contains(item: T): boolean;
        CopyTo(array: T[], arrayIndex: number): void;
        Remove(item: T): boolean;
    }
    export interface IDictionary<TKey, TValue> implements ICollection<KeyValuePair<TKey, TValue>>, IEnumerable<KeyValuePair<TKey, TValue>>, IEnumerable {
        get Item(): TValue;
        set Item(key: TKey);
        get Keys(): ICollection<TKey>;
        get Values(): ICollection<TValue>;

        ContainsKey(key: TKey): boolean;
        Add(key: TKey, value: TValue): void;
        Remove(key: TKey): boolean;
        TryGetValue(key: TKey, out value: TValue): boolean;
    }
    export interface IList<T> implements ICollection<T>, IEnumerable<T>, IEnumerable {
        get Item(): T;
        set Item(index: number);

        IndexOf(item: T): number;
        Insert(index: number, item: T): void;
        RemoveAt(index: number): void;
    }
    export interface IReadOnlyCollection<T> implements IEnumerable<T>, IEnumerable {
        get Count(): number;

    }
    export interface IReadOnlyList<T> implements IReadOnlyCollection<T>, IEnumerable<T>, IEnumerable {
        get Item(): T;

    }
    export interface IComparer<T> {
        Compare(x: T, y: T): number;
    }
    export class List<T> implements IList<T>, ICollection<T>, IEnumerable<T>, IEnumerable, IList, ICollection, IReadOnlyList<T>, IReadOnlyCollection<T> {
        private static readonly s_emptyArray: T[];

        private _items: T[];
        private _size: number;
        private _version: number;

        public get Capacity(): number {
            throw new Error("not yet implemented");
        }
        public set Capacity(value: number) {
            throw new Error("not yet implemented");
        }
        public get Count(): number {
            throw new Error("not yet implemented");
        }
        private get __explicit__IList_IsFixedSize(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsFixedSize(): boolean {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private get __explicit__ICollection__T___IsReadOnly(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsReadOnly(): boolean {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private get __explicit__IList_IsReadOnly(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsReadOnly(): boolean {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private get __explicit__ICollection_IsSynchronized(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsSynchronized(): boolean {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private get __explicit__ICollection_SyncRoot(): any {
            throw new Error("not yet implemented");
        }
        public get SyncRoot(): any {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        public get Item(): T {
            throw new Error("not yet implemented");
        }
        public set Item(index: number) {
            throw new Error("not yet implemented");
        }
        private get __explicit__IList_Item(): any {
            throw new Error("not yet implemented");
        }
        private set __explicit__IList_Item(index: number) {
            throw new Error("not yet implemented");
        }

        public constructor() {
            throw new Error("not yet implemented");
        }
        public constructor(capacity: number) {
            throw new Error("not yet implemented");
        }
        public constructor(collection: IEnumerable<T>) {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

        private static IsCompatibleObject(value: any): boolean {
            throw new Error("not yet implemented");
        }
        public Add(item: T) {
            throw new Error("not yet implemented");
        }
        private AddWithResize(item: T) {
            throw new Error("not yet implemented");
        }
        private __explicit__IList_Add(item: any): number {
            throw new Error("not yet implemented");
        }
        public AddRange(collection: IEnumerable<T>) {
            throw new Error("not yet implemented");
        }
        public AsReadOnly(): ReadOnlyCollection<T> {
            throw new Error("not yet implemented");
        }
        public BinarySearch(index: number, count: number, item: T, comparer: IComparer<T>): number {
            throw new Error("not yet implemented");
        }
        public BinarySearch(item: T): number {
            throw new Error("not yet implemented");
        }
        public BinarySearch(item: T, comparer: IComparer<T>): number {
            throw new Error("not yet implemented");
        }
        public Clear() {
            throw new Error("not yet implemented");
        }
        public Contains(item: T): boolean {
            throw new Error("not yet implemented");
        }
        private __explicit__IList_Contains(item: any): boolean {
            throw new Error("not yet implemented");
        }
        public ConvertAll(converter: Converter<T, TOutput>): List<TOutput> {
            throw new Error("not yet implemented");
        }
        public CopyTo(array: T[]) {
            throw new Error("not yet implemented");
        }
        private __explicit__ICollection_CopyTo(array: Array, arrayIndex: number) {
            throw new Error("not yet implemented");
        }
        public CopyTo(index: number, array: T[], arrayIndex: number, count: number) {
            throw new Error("not yet implemented");
        }
        public CopyTo(array: T[], arrayIndex: number) {
            throw new Error("not yet implemented");
        }
        public EnsureCapacity(capacity: number): number {
            throw new Error("not yet implemented");
        }
        private Grow(capacity: number) {
            throw new Error("not yet implemented");
        }
        public Exists(match: Predicate<T>): boolean {
            throw new Error("not yet implemented");
        }
        public Find(match: Predicate<T>): T {
            throw new Error("not yet implemented");
        }
        public FindAll(match: Predicate<T>): List<T> {
            throw new Error("not yet implemented");
        }
        public FindIndex(match: Predicate<T>): number {
            throw new Error("not yet implemented");
        }
        public FindIndex(startIndex: number, match: Predicate<T>): number {
            throw new Error("not yet implemented");
        }
        public FindIndex(startIndex: number, count: number, match: Predicate<T>): number {
            throw new Error("not yet implemented");
        }
        public FindLast(match: Predicate<T>): T {
            throw new Error("not yet implemented");
        }
        public FindLastIndex(match: Predicate<T>): number {
            throw new Error("not yet implemented");
        }
        public FindLastIndex(startIndex: number, match: Predicate<T>): number {
            throw new Error("not yet implemented");
        }
        public FindLastIndex(startIndex: number, count: number, match: Predicate<T>): number {
            throw new Error("not yet implemented");
        }
        public ForEach(action: Action<T>) {
            throw new Error("not yet implemented");
        }
        public GetEnumerator(): Enumerator {
            throw new Error("not yet implemented");
        }
        private __explicit__IEnumerable__T___GetEnumerator(): IEnumerator<T> {
            throw new Error("not yet implemented");
        }
        private __explicit__IEnumerable_GetEnumerator(): IEnumerator {
            throw new Error("not yet implemented");
        }
        public GetRange(index: number, count: number): List<T> {
            throw new Error("not yet implemented");
        }
        public Slice(start: number, length: number): List<T> {
            throw new Error("not yet implemented");
        }
        public IndexOf(item: T): number {
            throw new Error("not yet implemented");
        }
        private __explicit__IList_IndexOf(item: any): number {
            throw new Error("not yet implemented");
        }
        public IndexOf(item: T, index: number): number {
            throw new Error("not yet implemented");
        }
        public IndexOf(item: T, index: number, count: number): number {
            throw new Error("not yet implemented");
        }
        public Insert(index: number, item: T) {
            throw new Error("not yet implemented");
        }
        private __explicit__IList_Insert(index: number, item: any) {
            throw new Error("not yet implemented");
        }
        public InsertRange(index: number, collection: IEnumerable<T>) {
            throw new Error("not yet implemented");
        }
        public LastIndexOf(item: T): number {
            throw new Error("not yet implemented");
        }
        public LastIndexOf(item: T, index: number): number {
            throw new Error("not yet implemented");
        }
        public LastIndexOf(item: T, index: number, count: number): number {
            throw new Error("not yet implemented");
        }
        public Remove(item: T): boolean {
            throw new Error("not yet implemented");
        }
        private __explicit__IList_Remove(item: any) {
            throw new Error("not yet implemented");
        }
        public RemoveAll(match: Predicate<T>): number {
            throw new Error("not yet implemented");
        }
        public RemoveAt(index: number) {
            throw new Error("not yet implemented");
        }
        public RemoveRange(index: number, count: number) {
            throw new Error("not yet implemented");
        }
        public Reverse() {
            throw new Error("not yet implemented");
        }
        public Reverse(index: number, count: number) {
            throw new Error("not yet implemented");
        }
        public Sort() {
            throw new Error("not yet implemented");
        }
        public Sort(comparer: IComparer<T>) {
            throw new Error("not yet implemented");
        }
        public Sort(index: number, count: number, comparer: IComparer<T>) {
            throw new Error("not yet implemented");
        }
        public Sort(comparison: Comparison<T>) {
            throw new Error("not yet implemented");
        }
        public ToArray(): T[] {
            throw new Error("not yet implemented");
        }
        public TrimExcess() {
            throw new Error("not yet implemented");
        }
        public TrueForAll(match: Predicate<T>): boolean {
            throw new Error("not yet implemented");
        }

        public readonly ExplicitAsIList__T__: IList<T> = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'IsFixedSize') {
                    return target.__explicit__IList_IsFixedSize;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__ICollection__T___IsReadOnly;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__IList_IsReadOnly;
                }
                if (prop === 'IsSynchronized') {
                    return target.__explicit__ICollection_IsSynchronized;
                }
                if (prop === 'SyncRoot') {
                    return target.__explicit__ICollection_SyncRoot;
                }
                if (prop === 'Item') {
                    return target.__explicit__IList_Item;
                }
        
                if (prop === 'Add') {
                    return target.__explicit__IList_Add.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__IList_Contains.bind(target);
                }
                if (prop === 'CopyTo') {
                    return target.__explicit__ICollection_CopyTo.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable__T___GetEnumerator.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                }
                if (prop === 'IndexOf') {
                    return target.__explicit__IList_IndexOf.bind(target);
                }
                if (prop === 'Insert') {
                    return target.__explicit__IList_Insert.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__IList_Remove.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsICollection__T__: ICollection<T> = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'IsFixedSize') {
                    return target.__explicit__IList_IsFixedSize;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__ICollection__T___IsReadOnly;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__IList_IsReadOnly;
                }
                if (prop === 'IsSynchronized') {
                    return target.__explicit__ICollection_IsSynchronized;
                }
                if (prop === 'SyncRoot') {
                    return target.__explicit__ICollection_SyncRoot;
                }
                if (prop === 'Item') {
                    return target.__explicit__IList_Item;
                }
        
                if (prop === 'Add') {
                    return target.__explicit__IList_Add.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__IList_Contains.bind(target);
                }
                if (prop === 'CopyTo') {
                    return target.__explicit__ICollection_CopyTo.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable__T___GetEnumerator.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                }
                if (prop === 'IndexOf') {
                    return target.__explicit__IList_IndexOf.bind(target);
                }
                if (prop === 'Insert') {
                    return target.__explicit__IList_Insert.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__IList_Remove.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIEnumerable__T__: IEnumerable<T> = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'IsFixedSize') {
                    return target.__explicit__IList_IsFixedSize;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__ICollection__T___IsReadOnly;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__IList_IsReadOnly;
                }
                if (prop === 'IsSynchronized') {
                    return target.__explicit__ICollection_IsSynchronized;
                }
                if (prop === 'SyncRoot') {
                    return target.__explicit__ICollection_SyncRoot;
                }
                if (prop === 'Item') {
                    return target.__explicit__IList_Item;
                }
        
                if (prop === 'Add') {
                    return target.__explicit__IList_Add.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__IList_Contains.bind(target);
                }
                if (prop === 'CopyTo') {
                    return target.__explicit__ICollection_CopyTo.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable__T___GetEnumerator.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                }
                if (prop === 'IndexOf') {
                    return target.__explicit__IList_IndexOf.bind(target);
                }
                if (prop === 'Insert') {
                    return target.__explicit__IList_Insert.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__IList_Remove.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIEnumerable: IEnumerable = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'IsFixedSize') {
                    return target.__explicit__IList_IsFixedSize;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__ICollection__T___IsReadOnly;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__IList_IsReadOnly;
                }
                if (prop === 'IsSynchronized') {
                    return target.__explicit__ICollection_IsSynchronized;
                }
                if (prop === 'SyncRoot') {
                    return target.__explicit__ICollection_SyncRoot;
                }
                if (prop === 'Item') {
                    return target.__explicit__IList_Item;
                }
        
                if (prop === 'Add') {
                    return target.__explicit__IList_Add.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__IList_Contains.bind(target);
                }
                if (prop === 'CopyTo') {
                    return target.__explicit__ICollection_CopyTo.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable__T___GetEnumerator.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                }
                if (prop === 'IndexOf') {
                    return target.__explicit__IList_IndexOf.bind(target);
                }
                if (prop === 'Insert') {
                    return target.__explicit__IList_Insert.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__IList_Remove.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIList: IList = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'IsFixedSize') {
                    return target.__explicit__IList_IsFixedSize;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__ICollection__T___IsReadOnly;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__IList_IsReadOnly;
                }
                if (prop === 'IsSynchronized') {
                    return target.__explicit__ICollection_IsSynchronized;
                }
                if (prop === 'SyncRoot') {
                    return target.__explicit__ICollection_SyncRoot;
                }
                if (prop === 'Item') {
                    return target.__explicit__IList_Item;
                }
        
                if (prop === 'Add') {
                    return target.__explicit__IList_Add.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__IList_Contains.bind(target);
                }
                if (prop === 'CopyTo') {
                    return target.__explicit__ICollection_CopyTo.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable__T___GetEnumerator.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                }
                if (prop === 'IndexOf') {
                    return target.__explicit__IList_IndexOf.bind(target);
                }
                if (prop === 'Insert') {
                    return target.__explicit__IList_Insert.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__IList_Remove.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsICollection: ICollection = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'IsFixedSize') {
                    return target.__explicit__IList_IsFixedSize;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__ICollection__T___IsReadOnly;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__IList_IsReadOnly;
                }
                if (prop === 'IsSynchronized') {
                    return target.__explicit__ICollection_IsSynchronized;
                }
                if (prop === 'SyncRoot') {
                    return target.__explicit__ICollection_SyncRoot;
                }
                if (prop === 'Item') {
                    return target.__explicit__IList_Item;
                }
        
                if (prop === 'Add') {
                    return target.__explicit__IList_Add.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__IList_Contains.bind(target);
                }
                if (prop === 'CopyTo') {
                    return target.__explicit__ICollection_CopyTo.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable__T___GetEnumerator.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                }
                if (prop === 'IndexOf') {
                    return target.__explicit__IList_IndexOf.bind(target);
                }
                if (prop === 'Insert') {
                    return target.__explicit__IList_Insert.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__IList_Remove.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIReadOnlyList__T__: IReadOnlyList<T> = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'IsFixedSize') {
                    return target.__explicit__IList_IsFixedSize;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__ICollection__T___IsReadOnly;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__IList_IsReadOnly;
                }
                if (prop === 'IsSynchronized') {
                    return target.__explicit__ICollection_IsSynchronized;
                }
                if (prop === 'SyncRoot') {
                    return target.__explicit__ICollection_SyncRoot;
                }
                if (prop === 'Item') {
                    return target.__explicit__IList_Item;
                }
        
                if (prop === 'Add') {
                    return target.__explicit__IList_Add.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__IList_Contains.bind(target);
                }
                if (prop === 'CopyTo') {
                    return target.__explicit__ICollection_CopyTo.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable__T___GetEnumerator.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                }
                if (prop === 'IndexOf') {
                    return target.__explicit__IList_IndexOf.bind(target);
                }
                if (prop === 'Insert') {
                    return target.__explicit__IList_Insert.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__IList_Remove.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIReadOnlyCollection__T__: IReadOnlyCollection<T> = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'IsFixedSize') {
                    return target.__explicit__IList_IsFixedSize;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__ICollection__T___IsReadOnly;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__IList_IsReadOnly;
                }
                if (prop === 'IsSynchronized') {
                    return target.__explicit__ICollection_IsSynchronized;
                }
                if (prop === 'SyncRoot') {
                    return target.__explicit__ICollection_SyncRoot;
                }
                if (prop === 'Item') {
                    return target.__explicit__IList_Item;
                }
        
                if (prop === 'Add') {
                    return target.__explicit__IList_Add.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__IList_Contains.bind(target);
                }
                if (prop === 'CopyTo') {
                    return target.__explicit__ICollection_CopyTo.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable__T___GetEnumerator.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                }
                if (prop === 'IndexOf') {
                    return target.__explicit__IList_IndexOf.bind(target);
                }
                if (prop === 'Insert') {
                    return target.__explicit__IList_Insert.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__IList_Remove.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
    }
    export namespace List {
        export class Enumerator extends ValueType implements IEnumerator<T>, IDisposable, IEnumerator {
            private _list: List<T>;
            private _index: number;
            private _version: number;
            private _current: T;

            public get Current(): T {
                throw new Error("not yet implemented");
            }
            private get __explicit__IEnumerator_Current(): any {
                throw new Error("not yet implemented");
            }

            protected constructor(list: List<T>) {
                throw new Error("not yet implemented");
            }

            public Dispose() {
                throw new Error("not yet implemented");
            }
            public MoveNext(): boolean {
                throw new Error("not yet implemented");
            }
            private MoveNextRare(): boolean {
                throw new Error("not yet implemented");
            }
            private __explicit__IEnumerator_Reset() {
                throw new Error("not yet implemented");
            }
            public Reset() {
                throw new Error("Invalid call (use ExplicitAs property)");
            }

            public readonly ExplicitAsIEnumerator__T__: IEnumerator<T> = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'Current') {
                        return target.__explicit__IEnumerator_Current;
                    }
            
                    if (prop === 'Reset') {
                        return target.__explicit__IEnumerator_Reset.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
            public readonly ExplicitAsIDisposable: IDisposable = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'Current') {
                        return target.__explicit__IEnumerator_Current;
                    }
            
                    if (prop === 'Reset') {
                        return target.__explicit__IEnumerator_Reset.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
            public readonly ExplicitAsIEnumerator: IEnumerator = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'Current') {
                        return target.__explicit__IEnumerator_Current;
                    }
            
                    if (prop === 'Reset') {
                        return target.__explicit__IEnumerator_Reset.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
        }
    }
    export interface IReadOnlyDictionary<TKey, TValue> implements IReadOnlyCollection<KeyValuePair<TKey, TValue>>, IEnumerable<KeyValuePair<TKey, TValue>>, IEnumerable {
        get Item(): TValue;
        get Keys(): IEnumerable<TKey>;
        get Values(): IEnumerable<TValue>;

        ContainsKey(key: TKey): boolean;
        TryGetValue(key: TKey, out value: TValue): boolean;
    }
    export interface IEqualityComparer<T> {
        Equals(x: T, y: T): boolean;
        GetHashCode(obj: T): number;
    }
    export class KeyCollection implements ICollection<TKey>, IEnumerable<TKey>, IEnumerable, ICollection, IReadOnlyCollection<TKey> {
        private _dictionary: Dictionary<TKey, TValue>;

        public get Count(): number {
            throw new Error("not yet implemented");
        }
        private get __explicit__ICollection__TKey___IsReadOnly(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsReadOnly(): boolean {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private get __explicit__ICollection_IsSynchronized(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsSynchronized(): boolean {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private get __explicit__ICollection_SyncRoot(): any {
            throw new Error("not yet implemented");
        }
        public get SyncRoot(): any {
            throw new Error("Invalid call (use ExplicitAs property)");
        }

        public constructor(dictionary: Dictionary<TKey, TValue>) {
            throw new Error("not yet implemented");
        }

        public GetEnumerator(): Enumerator {
            throw new Error("not yet implemented");
        }
        public CopyTo(array: TKey[], index: number) {
            throw new Error("not yet implemented");
        }
        private __explicit__ICollection__TKey___Add(item: TKey) {
            throw new Error("not yet implemented");
        }
        public Add(item: TKey) {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__ICollection__TKey___Clear() {
            throw new Error("not yet implemented");
        }
        public Clear() {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        public Contains(item: TKey): boolean {
            throw new Error("not yet implemented");
        }
        private __explicit__ICollection__TKey___Remove(item: TKey): boolean {
            throw new Error("not yet implemented");
        }
        public Remove(item: TKey): boolean {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__IEnumerable__TKey___GetEnumerator(): IEnumerator<TKey> {
            throw new Error("not yet implemented");
        }
        private __explicit__IEnumerable_GetEnumerator(): IEnumerator {
            throw new Error("not yet implemented");
        }
        private __explicit__ICollection_CopyTo(array: Array, index: number) {
            throw new Error("not yet implemented");
        }

        public readonly ExplicitAsICollection__TKey__: ICollection<TKey> = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'IsReadOnly') {
                    return target.__explicit__ICollection__TKey___IsReadOnly;
                }
                if (prop === 'IsSynchronized') {
                    return target.__explicit__ICollection_IsSynchronized;
                }
                if (prop === 'SyncRoot') {
                    return target.__explicit__ICollection_SyncRoot;
                }
        
                if (prop === 'Add') {
                    return target.__explicit__ICollection__TKey___Add.bind(target);
                }
                if (prop === 'Clear') {
                    return target.__explicit__ICollection__TKey___Clear.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__ICollection__TKey___Remove.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable__TKey___GetEnumerator.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                }
                if (prop === 'CopyTo') {
                    return target.__explicit__ICollection_CopyTo.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIEnumerable__TKey__: IEnumerable<TKey> = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'IsReadOnly') {
                    return target.__explicit__ICollection__TKey___IsReadOnly;
                }
                if (prop === 'IsSynchronized') {
                    return target.__explicit__ICollection_IsSynchronized;
                }
                if (prop === 'SyncRoot') {
                    return target.__explicit__ICollection_SyncRoot;
                }
        
                if (prop === 'Add') {
                    return target.__explicit__ICollection__TKey___Add.bind(target);
                }
                if (prop === 'Clear') {
                    return target.__explicit__ICollection__TKey___Clear.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__ICollection__TKey___Remove.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable__TKey___GetEnumerator.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                }
                if (prop === 'CopyTo') {
                    return target.__explicit__ICollection_CopyTo.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIEnumerable: IEnumerable = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'IsReadOnly') {
                    return target.__explicit__ICollection__TKey___IsReadOnly;
                }
                if (prop === 'IsSynchronized') {
                    return target.__explicit__ICollection_IsSynchronized;
                }
                if (prop === 'SyncRoot') {
                    return target.__explicit__ICollection_SyncRoot;
                }
        
                if (prop === 'Add') {
                    return target.__explicit__ICollection__TKey___Add.bind(target);
                }
                if (prop === 'Clear') {
                    return target.__explicit__ICollection__TKey___Clear.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__ICollection__TKey___Remove.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable__TKey___GetEnumerator.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                }
                if (prop === 'CopyTo') {
                    return target.__explicit__ICollection_CopyTo.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsICollection: ICollection = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'IsReadOnly') {
                    return target.__explicit__ICollection__TKey___IsReadOnly;
                }
                if (prop === 'IsSynchronized') {
                    return target.__explicit__ICollection_IsSynchronized;
                }
                if (prop === 'SyncRoot') {
                    return target.__explicit__ICollection_SyncRoot;
                }
        
                if (prop === 'Add') {
                    return target.__explicit__ICollection__TKey___Add.bind(target);
                }
                if (prop === 'Clear') {
                    return target.__explicit__ICollection__TKey___Clear.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__ICollection__TKey___Remove.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable__TKey___GetEnumerator.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                }
                if (prop === 'CopyTo') {
                    return target.__explicit__ICollection_CopyTo.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIReadOnlyCollection__TKey__: IReadOnlyCollection<TKey> = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'IsReadOnly') {
                    return target.__explicit__ICollection__TKey___IsReadOnly;
                }
                if (prop === 'IsSynchronized') {
                    return target.__explicit__ICollection_IsSynchronized;
                }
                if (prop === 'SyncRoot') {
                    return target.__explicit__ICollection_SyncRoot;
                }
        
                if (prop === 'Add') {
                    return target.__explicit__ICollection__TKey___Add.bind(target);
                }
                if (prop === 'Clear') {
                    return target.__explicit__ICollection__TKey___Clear.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__ICollection__TKey___Remove.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable__TKey___GetEnumerator.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                }
                if (prop === 'CopyTo') {
                    return target.__explicit__ICollection_CopyTo.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
    }
    export namespace KeyCollection {
        export class Enumerator extends ValueType implements IEnumerator<TKey>, IDisposable, IEnumerator {
            private _dictionary: Dictionary<TKey, TValue>;
            private _index: number;
            private _version: number;
            private _currentKey: TKey;

            public get Current(): TKey {
                throw new Error("not yet implemented");
            }
            private get __explicit__IEnumerator_Current(): any {
                throw new Error("not yet implemented");
            }

            protected constructor(dictionary: Dictionary<TKey, TValue>) {
                throw new Error("not yet implemented");
            }

            public Dispose() {
                throw new Error("not yet implemented");
            }
            public MoveNext(): boolean {
                throw new Error("not yet implemented");
            }
            private __explicit__IEnumerator_Reset() {
                throw new Error("not yet implemented");
            }
            public Reset() {
                throw new Error("Invalid call (use ExplicitAs property)");
            }

            public readonly ExplicitAsIEnumerator__TKey__: IEnumerator<TKey> = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'Current') {
                        return target.__explicit__IEnumerator_Current;
                    }
            
                    if (prop === 'Reset') {
                        return target.__explicit__IEnumerator_Reset.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
            public readonly ExplicitAsIDisposable: IDisposable = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'Current') {
                        return target.__explicit__IEnumerator_Current;
                    }
            
                    if (prop === 'Reset') {
                        return target.__explicit__IEnumerator_Reset.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
            public readonly ExplicitAsIEnumerator: IEnumerator = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'Current') {
                        return target.__explicit__IEnumerator_Current;
                    }
            
                    if (prop === 'Reset') {
                        return target.__explicit__IEnumerator_Reset.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
        }
    }
    export class ValueCollection implements ICollection<TValue>, IEnumerable<TValue>, IEnumerable, ICollection, IReadOnlyCollection<TValue> {
        private _dictionary: Dictionary<TKey, TValue>;

        public get Count(): number {
            throw new Error("not yet implemented");
        }
        private get __explicit__ICollection__TValue___IsReadOnly(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsReadOnly(): boolean {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private get __explicit__ICollection_IsSynchronized(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsSynchronized(): boolean {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private get __explicit__ICollection_SyncRoot(): any {
            throw new Error("not yet implemented");
        }
        public get SyncRoot(): any {
            throw new Error("Invalid call (use ExplicitAs property)");
        }

        public constructor(dictionary: Dictionary<TKey, TValue>) {
            throw new Error("not yet implemented");
        }

        public GetEnumerator(): Enumerator {
            throw new Error("not yet implemented");
        }
        public CopyTo(array: TValue[], index: number) {
            throw new Error("not yet implemented");
        }
        private __explicit__ICollection__TValue___Add(item: TValue) {
            throw new Error("not yet implemented");
        }
        public Add(item: TValue) {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__ICollection__TValue___Remove(item: TValue): boolean {
            throw new Error("not yet implemented");
        }
        public Remove(item: TValue): boolean {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__ICollection__TValue___Clear() {
            throw new Error("not yet implemented");
        }
        public Clear() {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__ICollection__TValue___Contains(item: TValue): boolean {
            throw new Error("not yet implemented");
        }
        public Contains(item: TValue): boolean {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__IEnumerable__TValue___GetEnumerator(): IEnumerator<TValue> {
            throw new Error("not yet implemented");
        }
        private __explicit__IEnumerable_GetEnumerator(): IEnumerator {
            throw new Error("not yet implemented");
        }
        private __explicit__ICollection_CopyTo(array: Array, index: number) {
            throw new Error("not yet implemented");
        }

        public readonly ExplicitAsICollection__TValue__: ICollection<TValue> = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'IsReadOnly') {
                    return target.__explicit__ICollection__TValue___IsReadOnly;
                }
                if (prop === 'IsSynchronized') {
                    return target.__explicit__ICollection_IsSynchronized;
                }
                if (prop === 'SyncRoot') {
                    return target.__explicit__ICollection_SyncRoot;
                }
        
                if (prop === 'Add') {
                    return target.__explicit__ICollection__TValue___Add.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__ICollection__TValue___Remove.bind(target);
                }
                if (prop === 'Clear') {
                    return target.__explicit__ICollection__TValue___Clear.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__ICollection__TValue___Contains.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable__TValue___GetEnumerator.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                }
                if (prop === 'CopyTo') {
                    return target.__explicit__ICollection_CopyTo.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIEnumerable__TValue__: IEnumerable<TValue> = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'IsReadOnly') {
                    return target.__explicit__ICollection__TValue___IsReadOnly;
                }
                if (prop === 'IsSynchronized') {
                    return target.__explicit__ICollection_IsSynchronized;
                }
                if (prop === 'SyncRoot') {
                    return target.__explicit__ICollection_SyncRoot;
                }
        
                if (prop === 'Add') {
                    return target.__explicit__ICollection__TValue___Add.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__ICollection__TValue___Remove.bind(target);
                }
                if (prop === 'Clear') {
                    return target.__explicit__ICollection__TValue___Clear.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__ICollection__TValue___Contains.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable__TValue___GetEnumerator.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                }
                if (prop === 'CopyTo') {
                    return target.__explicit__ICollection_CopyTo.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIEnumerable: IEnumerable = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'IsReadOnly') {
                    return target.__explicit__ICollection__TValue___IsReadOnly;
                }
                if (prop === 'IsSynchronized') {
                    return target.__explicit__ICollection_IsSynchronized;
                }
                if (prop === 'SyncRoot') {
                    return target.__explicit__ICollection_SyncRoot;
                }
        
                if (prop === 'Add') {
                    return target.__explicit__ICollection__TValue___Add.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__ICollection__TValue___Remove.bind(target);
                }
                if (prop === 'Clear') {
                    return target.__explicit__ICollection__TValue___Clear.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__ICollection__TValue___Contains.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable__TValue___GetEnumerator.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                }
                if (prop === 'CopyTo') {
                    return target.__explicit__ICollection_CopyTo.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsICollection: ICollection = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'IsReadOnly') {
                    return target.__explicit__ICollection__TValue___IsReadOnly;
                }
                if (prop === 'IsSynchronized') {
                    return target.__explicit__ICollection_IsSynchronized;
                }
                if (prop === 'SyncRoot') {
                    return target.__explicit__ICollection_SyncRoot;
                }
        
                if (prop === 'Add') {
                    return target.__explicit__ICollection__TValue___Add.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__ICollection__TValue___Remove.bind(target);
                }
                if (prop === 'Clear') {
                    return target.__explicit__ICollection__TValue___Clear.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__ICollection__TValue___Contains.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable__TValue___GetEnumerator.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                }
                if (prop === 'CopyTo') {
                    return target.__explicit__ICollection_CopyTo.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIReadOnlyCollection__TValue__: IReadOnlyCollection<TValue> = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'IsReadOnly') {
                    return target.__explicit__ICollection__TValue___IsReadOnly;
                }
                if (prop === 'IsSynchronized') {
                    return target.__explicit__ICollection_IsSynchronized;
                }
                if (prop === 'SyncRoot') {
                    return target.__explicit__ICollection_SyncRoot;
                }
        
                if (prop === 'Add') {
                    return target.__explicit__ICollection__TValue___Add.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__ICollection__TValue___Remove.bind(target);
                }
                if (prop === 'Clear') {
                    return target.__explicit__ICollection__TValue___Clear.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__ICollection__TValue___Contains.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable__TValue___GetEnumerator.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                }
                if (prop === 'CopyTo') {
                    return target.__explicit__ICollection_CopyTo.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
    }
    export namespace ValueCollection {
        export class Enumerator extends ValueType implements IEnumerator<TValue>, IDisposable, IEnumerator {
            private _dictionary: Dictionary<TKey, TValue>;
            private _index: number;
            private _version: number;
            private _currentValue: TValue;

            public get Current(): TValue {
                throw new Error("not yet implemented");
            }
            private get __explicit__IEnumerator_Current(): any {
                throw new Error("not yet implemented");
            }

            protected constructor(dictionary: Dictionary<TKey, TValue>) {
                throw new Error("not yet implemented");
            }

            public Dispose() {
                throw new Error("not yet implemented");
            }
            public MoveNext(): boolean {
                throw new Error("not yet implemented");
            }
            private __explicit__IEnumerator_Reset() {
                throw new Error("not yet implemented");
            }
            public Reset() {
                throw new Error("Invalid call (use ExplicitAs property)");
            }

            public readonly ExplicitAsIEnumerator__TValue__: IEnumerator<TValue> = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'Current') {
                        return target.__explicit__IEnumerator_Current;
                    }
            
                    if (prop === 'Reset') {
                        return target.__explicit__IEnumerator_Reset.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
            public readonly ExplicitAsIDisposable: IDisposable = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'Current') {
                        return target.__explicit__IEnumerator_Current;
                    }
            
                    if (prop === 'Reset') {
                        return target.__explicit__IEnumerator_Reset.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
            public readonly ExplicitAsIEnumerator: IEnumerator = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'Current') {
                        return target.__explicit__IEnumerator_Current;
                    }
            
                    if (prop === 'Reset') {
                        return target.__explicit__IEnumerator_Reset.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
        }
    }
    export class KeyValuePair<TKey, TValue> extends ValueType {
        private key: TKey;
        private value: TValue;

        public get Key(): TKey {
            throw new Error("not yet implemented");
        }
        public get Value(): TValue {
            throw new Error("not yet implemented");
        }

        public constructor(key: TKey, value: TValue) {
            throw new Error("not yet implemented");
        }

        public ToString(): string {
            throw new Error("not yet implemented");
        }
        public Deconstruct(out key: TKey, out value: TValue) {
            throw new Error("not yet implemented");
        }
    }
    export enum InsertionBehavior {
        None = 0,
        OverwriteExisting = 1,
        ThrowOnExisting = 2,
    }
    export class Dictionary<TKey, TValue> implements IDictionary<TKey, TValue>, ICollection<KeyValuePair<TKey, TValue>>, IEnumerable<KeyValuePair<TKey, TValue>>, IEnumerable, IDictionary, ICollection, IReadOnlyDictionary<TKey, TValue>, IReadOnlyCollection<KeyValuePair<TKey, TValue>>, ISerializable, IDeserializationCallback {
        private _buckets: number[];
        private _entries: Entry[];
        private _fastModMultiplier: number;
        private _count: number;
        private _freeList: number;
        private _freeCount: number;
        private _version: number;
        private _comparer: IEqualityComparer<TKey>;
        private _keys: KeyCollection;
        private _values: ValueCollection;

        public get Comparer(): IEqualityComparer<TKey> {
            throw new Error("not yet implemented");
        }
        public get Count(): number {
            throw new Error("not yet implemented");
        }
        public get Keys(): KeyCollection {
            throw new Error("not yet implemented");
        }
        private get __explicit__IDictionary__TKey_TValue___Keys(): ICollection<TKey> {
            throw new Error("not yet implemented");
        }
        private get __explicit__IReadOnlyDictionary__TKey_TValue___Keys(): IEnumerable<TKey> {
            throw new Error("not yet implemented");
        }
        public get Values(): ValueCollection {
            throw new Error("not yet implemented");
        }
        private get __explicit__IDictionary__TKey_TValue___Values(): ICollection<TValue> {
            throw new Error("not yet implemented");
        }
        private get __explicit__IReadOnlyDictionary__TKey_TValue___Values(): IEnumerable<TValue> {
            throw new Error("not yet implemented");
        }
        public get Item(): TValue {
            throw new Error("not yet implemented");
        }
        public set Item(key: TKey) {
            throw new Error("not yet implemented");
        }
        private get __explicit__KeyValuePair__TKey_TValue_____IsReadOnly(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsReadOnly(): boolean {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private get __explicit__ICollection_IsSynchronized(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsSynchronized(): boolean {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private get __explicit__ICollection_SyncRoot(): any {
            throw new Error("not yet implemented");
        }
        public get SyncRoot(): any {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private get __explicit__IDictionary_IsFixedSize(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsFixedSize(): boolean {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private get __explicit__IDictionary_IsReadOnly(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsReadOnly(): boolean {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private get __explicit__IDictionary_Keys(): ICollection {
            throw new Error("not yet implemented");
        }
        private get __explicit__IDictionary_Values(): ICollection {
            throw new Error("not yet implemented");
        }
        private get __explicit__IDictionary_Item(): any {
            throw new Error("not yet implemented");
        }
        private set __explicit__IDictionary_Item(key: any) {
            throw new Error("not yet implemented");
        }

        public constructor() {
            throw new Error("not yet implemented");
        }
        public constructor(capacity: number) {
            throw new Error("not yet implemented");
        }
        public constructor(comparer: IEqualityComparer<TKey>) {
            throw new Error("not yet implemented");
        }
        public constructor(capacity: number, comparer: IEqualityComparer<TKey>) {
            throw new Error("not yet implemented");
        }
        public constructor(dictionary: IDictionary<TKey, TValue>) {
            throw new Error("not yet implemented");
        }
        public constructor(dictionary: IDictionary<TKey, TValue>, comparer: IEqualityComparer<TKey>) {
            throw new Error("not yet implemented");
        }
        public constructor(collection: IEnumerable<KeyValuePair<TKey, TValue>>) {
            throw new Error("not yet implemented");
        }
        public constructor(collection: IEnumerable<KeyValuePair<TKey, TValue>>, comparer: IEqualityComparer<TKey>) {
            throw new Error("not yet implemented");
        }
        protected constructor(info: SerializationInfo, context: StreamingContext) {
            throw new Error("not yet implemented");
        }

        private AddRange(enumerable: IEnumerable<KeyValuePair<TKey, TValue>>) {
            throw new Error("not yet implemented");
        }
        public Add(key: TKey, value: TValue) {
            throw new Error("not yet implemented");
        }
        private __explicit__KeyValuePair__TKey_TValue_____Add(keyValuePair: KeyValuePair<TKey, TValue>) {
            throw new Error("not yet implemented");
        }
        private __explicit__KeyValuePair__TKey_TValue_____Contains(keyValuePair: KeyValuePair<TKey, TValue>): boolean {
            throw new Error("not yet implemented");
        }
        public Contains(keyValuePair: KeyValuePair<TKey, TValue>): boolean {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__KeyValuePair__TKey_TValue_____Remove(keyValuePair: KeyValuePair<TKey, TValue>): boolean {
            throw new Error("not yet implemented");
        }
        public Clear() {
            throw new Error("not yet implemented");
        }
        public ContainsKey(key: TKey): boolean {
            throw new Error("not yet implemented");
        }
        public ContainsValue(value: TValue): boolean {
            throw new Error("not yet implemented");
        }
        private CopyTo(array: KeyValuePair<TKey, TValue>[], index: number) {
            throw new Error("not yet implemented");
        }
        public GetEnumerator(): Enumerator {
            throw new Error("not yet implemented");
        }
        private __explicit__KeyValuePair__TKey_TValue_____GetEnumerator(): IEnumerator<KeyValuePair<TKey, TValue>> {
            throw new Error("not yet implemented");
        }
        public GetObjectData(info: SerializationInfo, context: StreamingContext) {
            throw new Error("not yet implemented");
        }
        private FindValue(key: TKey): TValue {
            throw new Error("not yet implemented");
        }
        private Initialize(capacity: number): number {
            throw new Error("not yet implemented");
        }
        private TryInsert(key: TKey, value: TValue, behavior: InsertionBehavior): boolean {
            throw new Error("not yet implemented");
        }
        public OnDeserialization(sender: any) {
            throw new Error("not yet implemented");
        }
        private Resize() {
            throw new Error("not yet implemented");
        }
        private Resize(newSize: number, forceNewHashCodes: boolean) {
            throw new Error("not yet implemented");
        }
        public Remove(key: TKey): boolean {
            throw new Error("not yet implemented");
        }
        public Remove(key: TKey, out value: TValue): boolean {
            throw new Error("not yet implemented");
        }
        public TryGetValue(key: TKey, out value: TValue): boolean {
            throw new Error("not yet implemented");
        }
        public TryAdd(key: TKey, value: TValue): boolean {
            throw new Error("not yet implemented");
        }
        private __explicit__KeyValuePair__TKey_TValue_____CopyTo(array: KeyValuePair<TKey, TValue>[], index: number) {
            throw new Error("not yet implemented");
        }
        private __explicit__ICollection_CopyTo(array: Array, index: number) {
            throw new Error("not yet implemented");
        }
        private __explicit__IEnumerable_GetEnumerator(): IEnumerator {
            throw new Error("not yet implemented");
        }
        public EnsureCapacity(capacity: number): number {
            throw new Error("not yet implemented");
        }
        public TrimExcess() {
            throw new Error("not yet implemented");
        }
        public TrimExcess(capacity: number) {
            throw new Error("not yet implemented");
        }
        private CopyEntries(entries: Entry[], count: number) {
            throw new Error("not yet implemented");
        }
        private static IsCompatibleKey(key: any): boolean {
            throw new Error("not yet implemented");
        }
        private __explicit__IDictionary_Add(key: any, value: any) {
            throw new Error("not yet implemented");
        }
        private __explicit__IDictionary_Contains(key: any): boolean {
            throw new Error("not yet implemented");
        }
        public Contains(key: any): boolean {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__IDictionary_GetEnumerator(): IDictionaryEnumerator {
            throw new Error("not yet implemented");
        }
        private __explicit__IDictionary_Remove(key: any) {
            throw new Error("not yet implemented");
        }
        private GetBucket(hashCode: number): number {
            throw new Error("not yet implemented");
        }

        public readonly ExplicitAsIDictionary__TKey__TValue__: IDictionary<TKey, TValue> = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Keys') {
                    return target.__explicit__IDictionary__TKey_TValue___Keys;
                }
                if (prop === 'Keys') {
                    return target.__explicit__IReadOnlyDictionary__TKey_TValue___Keys;
                }
                if (prop === 'Values') {
                    return target.__explicit__IDictionary__TKey_TValue___Values;
                }
                if (prop === 'Values') {
                    return target.__explicit__IReadOnlyDictionary__TKey_TValue___Values;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____IsReadOnly;
                }
                if (prop === 'IsSynchronized') {
                    return target.__explicit__ICollection_IsSynchronized;
                }
                if (prop === 'SyncRoot') {
                    return target.__explicit__ICollection_SyncRoot;
                }
                if (prop === 'IsFixedSize') {
                    return target.__explicit__IDictionary_IsFixedSize;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__IDictionary_IsReadOnly;
                }
                if (prop === 'Keys') {
                    return target.__explicit__IDictionary_Keys;
                }
                if (prop === 'Values') {
                    return target.__explicit__IDictionary_Values;
                }
                if (prop === 'Item') {
                    return target.__explicit__IDictionary_Item;
                }
        
                if (prop === 'Add') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____Add.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____Contains.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____Remove.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____GetEnumerator.bind(target);
                }
                if (prop === 'CopyTo') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____CopyTo.bind(target);
                }
                if (prop === 'CopyTo') {
                    return target.__explicit__ICollection_CopyTo.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                }
                if (prop === 'Add') {
                    return target.__explicit__IDictionary_Add.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__IDictionary_Contains.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IDictionary_GetEnumerator.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__IDictionary_Remove.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsICollection__KeyValuePair__TKey__TValue____: ICollection<KeyValuePair<TKey, TValue>> = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Keys') {
                    return target.__explicit__IDictionary__TKey_TValue___Keys;
                }
                if (prop === 'Keys') {
                    return target.__explicit__IReadOnlyDictionary__TKey_TValue___Keys;
                }
                if (prop === 'Values') {
                    return target.__explicit__IDictionary__TKey_TValue___Values;
                }
                if (prop === 'Values') {
                    return target.__explicit__IReadOnlyDictionary__TKey_TValue___Values;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____IsReadOnly;
                }
                if (prop === 'IsSynchronized') {
                    return target.__explicit__ICollection_IsSynchronized;
                }
                if (prop === 'SyncRoot') {
                    return target.__explicit__ICollection_SyncRoot;
                }
                if (prop === 'IsFixedSize') {
                    return target.__explicit__IDictionary_IsFixedSize;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__IDictionary_IsReadOnly;
                }
                if (prop === 'Keys') {
                    return target.__explicit__IDictionary_Keys;
                }
                if (prop === 'Values') {
                    return target.__explicit__IDictionary_Values;
                }
                if (prop === 'Item') {
                    return target.__explicit__IDictionary_Item;
                }
        
                if (prop === 'Add') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____Add.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____Contains.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____Remove.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____GetEnumerator.bind(target);
                }
                if (prop === 'CopyTo') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____CopyTo.bind(target);
                }
                if (prop === 'CopyTo') {
                    return target.__explicit__ICollection_CopyTo.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                }
                if (prop === 'Add') {
                    return target.__explicit__IDictionary_Add.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__IDictionary_Contains.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IDictionary_GetEnumerator.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__IDictionary_Remove.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIEnumerable__KeyValuePair__TKey__TValue____: IEnumerable<KeyValuePair<TKey, TValue>> = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Keys') {
                    return target.__explicit__IDictionary__TKey_TValue___Keys;
                }
                if (prop === 'Keys') {
                    return target.__explicit__IReadOnlyDictionary__TKey_TValue___Keys;
                }
                if (prop === 'Values') {
                    return target.__explicit__IDictionary__TKey_TValue___Values;
                }
                if (prop === 'Values') {
                    return target.__explicit__IReadOnlyDictionary__TKey_TValue___Values;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____IsReadOnly;
                }
                if (prop === 'IsSynchronized') {
                    return target.__explicit__ICollection_IsSynchronized;
                }
                if (prop === 'SyncRoot') {
                    return target.__explicit__ICollection_SyncRoot;
                }
                if (prop === 'IsFixedSize') {
                    return target.__explicit__IDictionary_IsFixedSize;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__IDictionary_IsReadOnly;
                }
                if (prop === 'Keys') {
                    return target.__explicit__IDictionary_Keys;
                }
                if (prop === 'Values') {
                    return target.__explicit__IDictionary_Values;
                }
                if (prop === 'Item') {
                    return target.__explicit__IDictionary_Item;
                }
        
                if (prop === 'Add') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____Add.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____Contains.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____Remove.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____GetEnumerator.bind(target);
                }
                if (prop === 'CopyTo') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____CopyTo.bind(target);
                }
                if (prop === 'CopyTo') {
                    return target.__explicit__ICollection_CopyTo.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                }
                if (prop === 'Add') {
                    return target.__explicit__IDictionary_Add.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__IDictionary_Contains.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IDictionary_GetEnumerator.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__IDictionary_Remove.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIEnumerable: IEnumerable = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Keys') {
                    return target.__explicit__IDictionary__TKey_TValue___Keys;
                }
                if (prop === 'Keys') {
                    return target.__explicit__IReadOnlyDictionary__TKey_TValue___Keys;
                }
                if (prop === 'Values') {
                    return target.__explicit__IDictionary__TKey_TValue___Values;
                }
                if (prop === 'Values') {
                    return target.__explicit__IReadOnlyDictionary__TKey_TValue___Values;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____IsReadOnly;
                }
                if (prop === 'IsSynchronized') {
                    return target.__explicit__ICollection_IsSynchronized;
                }
                if (prop === 'SyncRoot') {
                    return target.__explicit__ICollection_SyncRoot;
                }
                if (prop === 'IsFixedSize') {
                    return target.__explicit__IDictionary_IsFixedSize;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__IDictionary_IsReadOnly;
                }
                if (prop === 'Keys') {
                    return target.__explicit__IDictionary_Keys;
                }
                if (prop === 'Values') {
                    return target.__explicit__IDictionary_Values;
                }
                if (prop === 'Item') {
                    return target.__explicit__IDictionary_Item;
                }
        
                if (prop === 'Add') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____Add.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____Contains.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____Remove.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____GetEnumerator.bind(target);
                }
                if (prop === 'CopyTo') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____CopyTo.bind(target);
                }
                if (prop === 'CopyTo') {
                    return target.__explicit__ICollection_CopyTo.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                }
                if (prop === 'Add') {
                    return target.__explicit__IDictionary_Add.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__IDictionary_Contains.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IDictionary_GetEnumerator.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__IDictionary_Remove.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIDictionary: IDictionary = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Keys') {
                    return target.__explicit__IDictionary__TKey_TValue___Keys;
                }
                if (prop === 'Keys') {
                    return target.__explicit__IReadOnlyDictionary__TKey_TValue___Keys;
                }
                if (prop === 'Values') {
                    return target.__explicit__IDictionary__TKey_TValue___Values;
                }
                if (prop === 'Values') {
                    return target.__explicit__IReadOnlyDictionary__TKey_TValue___Values;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____IsReadOnly;
                }
                if (prop === 'IsSynchronized') {
                    return target.__explicit__ICollection_IsSynchronized;
                }
                if (prop === 'SyncRoot') {
                    return target.__explicit__ICollection_SyncRoot;
                }
                if (prop === 'IsFixedSize') {
                    return target.__explicit__IDictionary_IsFixedSize;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__IDictionary_IsReadOnly;
                }
                if (prop === 'Keys') {
                    return target.__explicit__IDictionary_Keys;
                }
                if (prop === 'Values') {
                    return target.__explicit__IDictionary_Values;
                }
                if (prop === 'Item') {
                    return target.__explicit__IDictionary_Item;
                }
        
                if (prop === 'Add') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____Add.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____Contains.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____Remove.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____GetEnumerator.bind(target);
                }
                if (prop === 'CopyTo') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____CopyTo.bind(target);
                }
                if (prop === 'CopyTo') {
                    return target.__explicit__ICollection_CopyTo.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                }
                if (prop === 'Add') {
                    return target.__explicit__IDictionary_Add.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__IDictionary_Contains.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IDictionary_GetEnumerator.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__IDictionary_Remove.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsICollection: ICollection = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Keys') {
                    return target.__explicit__IDictionary__TKey_TValue___Keys;
                }
                if (prop === 'Keys') {
                    return target.__explicit__IReadOnlyDictionary__TKey_TValue___Keys;
                }
                if (prop === 'Values') {
                    return target.__explicit__IDictionary__TKey_TValue___Values;
                }
                if (prop === 'Values') {
                    return target.__explicit__IReadOnlyDictionary__TKey_TValue___Values;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____IsReadOnly;
                }
                if (prop === 'IsSynchronized') {
                    return target.__explicit__ICollection_IsSynchronized;
                }
                if (prop === 'SyncRoot') {
                    return target.__explicit__ICollection_SyncRoot;
                }
                if (prop === 'IsFixedSize') {
                    return target.__explicit__IDictionary_IsFixedSize;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__IDictionary_IsReadOnly;
                }
                if (prop === 'Keys') {
                    return target.__explicit__IDictionary_Keys;
                }
                if (prop === 'Values') {
                    return target.__explicit__IDictionary_Values;
                }
                if (prop === 'Item') {
                    return target.__explicit__IDictionary_Item;
                }
        
                if (prop === 'Add') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____Add.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____Contains.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____Remove.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____GetEnumerator.bind(target);
                }
                if (prop === 'CopyTo') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____CopyTo.bind(target);
                }
                if (prop === 'CopyTo') {
                    return target.__explicit__ICollection_CopyTo.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                }
                if (prop === 'Add') {
                    return target.__explicit__IDictionary_Add.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__IDictionary_Contains.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IDictionary_GetEnumerator.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__IDictionary_Remove.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIReadOnlyDictionary__TKey__TValue__: IReadOnlyDictionary<TKey, TValue> = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Keys') {
                    return target.__explicit__IDictionary__TKey_TValue___Keys;
                }
                if (prop === 'Keys') {
                    return target.__explicit__IReadOnlyDictionary__TKey_TValue___Keys;
                }
                if (prop === 'Values') {
                    return target.__explicit__IDictionary__TKey_TValue___Values;
                }
                if (prop === 'Values') {
                    return target.__explicit__IReadOnlyDictionary__TKey_TValue___Values;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____IsReadOnly;
                }
                if (prop === 'IsSynchronized') {
                    return target.__explicit__ICollection_IsSynchronized;
                }
                if (prop === 'SyncRoot') {
                    return target.__explicit__ICollection_SyncRoot;
                }
                if (prop === 'IsFixedSize') {
                    return target.__explicit__IDictionary_IsFixedSize;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__IDictionary_IsReadOnly;
                }
                if (prop === 'Keys') {
                    return target.__explicit__IDictionary_Keys;
                }
                if (prop === 'Values') {
                    return target.__explicit__IDictionary_Values;
                }
                if (prop === 'Item') {
                    return target.__explicit__IDictionary_Item;
                }
        
                if (prop === 'Add') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____Add.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____Contains.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____Remove.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____GetEnumerator.bind(target);
                }
                if (prop === 'CopyTo') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____CopyTo.bind(target);
                }
                if (prop === 'CopyTo') {
                    return target.__explicit__ICollection_CopyTo.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                }
                if (prop === 'Add') {
                    return target.__explicit__IDictionary_Add.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__IDictionary_Contains.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IDictionary_GetEnumerator.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__IDictionary_Remove.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIReadOnlyCollection__KeyValuePair__TKey__TValue____: IReadOnlyCollection<KeyValuePair<TKey, TValue>> = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Keys') {
                    return target.__explicit__IDictionary__TKey_TValue___Keys;
                }
                if (prop === 'Keys') {
                    return target.__explicit__IReadOnlyDictionary__TKey_TValue___Keys;
                }
                if (prop === 'Values') {
                    return target.__explicit__IDictionary__TKey_TValue___Values;
                }
                if (prop === 'Values') {
                    return target.__explicit__IReadOnlyDictionary__TKey_TValue___Values;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____IsReadOnly;
                }
                if (prop === 'IsSynchronized') {
                    return target.__explicit__ICollection_IsSynchronized;
                }
                if (prop === 'SyncRoot') {
                    return target.__explicit__ICollection_SyncRoot;
                }
                if (prop === 'IsFixedSize') {
                    return target.__explicit__IDictionary_IsFixedSize;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__IDictionary_IsReadOnly;
                }
                if (prop === 'Keys') {
                    return target.__explicit__IDictionary_Keys;
                }
                if (prop === 'Values') {
                    return target.__explicit__IDictionary_Values;
                }
                if (prop === 'Item') {
                    return target.__explicit__IDictionary_Item;
                }
        
                if (prop === 'Add') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____Add.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____Contains.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____Remove.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____GetEnumerator.bind(target);
                }
                if (prop === 'CopyTo') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____CopyTo.bind(target);
                }
                if (prop === 'CopyTo') {
                    return target.__explicit__ICollection_CopyTo.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                }
                if (prop === 'Add') {
                    return target.__explicit__IDictionary_Add.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__IDictionary_Contains.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IDictionary_GetEnumerator.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__IDictionary_Remove.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsISerializable: ISerializable = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Keys') {
                    return target.__explicit__IDictionary__TKey_TValue___Keys;
                }
                if (prop === 'Keys') {
                    return target.__explicit__IReadOnlyDictionary__TKey_TValue___Keys;
                }
                if (prop === 'Values') {
                    return target.__explicit__IDictionary__TKey_TValue___Values;
                }
                if (prop === 'Values') {
                    return target.__explicit__IReadOnlyDictionary__TKey_TValue___Values;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____IsReadOnly;
                }
                if (prop === 'IsSynchronized') {
                    return target.__explicit__ICollection_IsSynchronized;
                }
                if (prop === 'SyncRoot') {
                    return target.__explicit__ICollection_SyncRoot;
                }
                if (prop === 'IsFixedSize') {
                    return target.__explicit__IDictionary_IsFixedSize;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__IDictionary_IsReadOnly;
                }
                if (prop === 'Keys') {
                    return target.__explicit__IDictionary_Keys;
                }
                if (prop === 'Values') {
                    return target.__explicit__IDictionary_Values;
                }
                if (prop === 'Item') {
                    return target.__explicit__IDictionary_Item;
                }
        
                if (prop === 'Add') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____Add.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____Contains.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____Remove.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____GetEnumerator.bind(target);
                }
                if (prop === 'CopyTo') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____CopyTo.bind(target);
                }
                if (prop === 'CopyTo') {
                    return target.__explicit__ICollection_CopyTo.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                }
                if (prop === 'Add') {
                    return target.__explicit__IDictionary_Add.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__IDictionary_Contains.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IDictionary_GetEnumerator.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__IDictionary_Remove.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIDeserializationCallback: IDeserializationCallback = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Keys') {
                    return target.__explicit__IDictionary__TKey_TValue___Keys;
                }
                if (prop === 'Keys') {
                    return target.__explicit__IReadOnlyDictionary__TKey_TValue___Keys;
                }
                if (prop === 'Values') {
                    return target.__explicit__IDictionary__TKey_TValue___Values;
                }
                if (prop === 'Values') {
                    return target.__explicit__IReadOnlyDictionary__TKey_TValue___Values;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____IsReadOnly;
                }
                if (prop === 'IsSynchronized') {
                    return target.__explicit__ICollection_IsSynchronized;
                }
                if (prop === 'SyncRoot') {
                    return target.__explicit__ICollection_SyncRoot;
                }
                if (prop === 'IsFixedSize') {
                    return target.__explicit__IDictionary_IsFixedSize;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__IDictionary_IsReadOnly;
                }
                if (prop === 'Keys') {
                    return target.__explicit__IDictionary_Keys;
                }
                if (prop === 'Values') {
                    return target.__explicit__IDictionary_Values;
                }
                if (prop === 'Item') {
                    return target.__explicit__IDictionary_Item;
                }
        
                if (prop === 'Add') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____Add.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____Contains.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____Remove.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____GetEnumerator.bind(target);
                }
                if (prop === 'CopyTo') {
                    return target.__explicit__KeyValuePair__TKey_TValue_____CopyTo.bind(target);
                }
                if (prop === 'CopyTo') {
                    return target.__explicit__ICollection_CopyTo.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                }
                if (prop === 'Add') {
                    return target.__explicit__IDictionary_Add.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__IDictionary_Contains.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IDictionary_GetEnumerator.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__IDictionary_Remove.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
    }
    export namespace Dictionary {
        export class CollectionsMarshalHelper {
            public static GetValueRefOrAddDefault(dictionary: Dictionary<TKey, TValue>, key: TKey, out exists: boolean): TValue {
                throw new Error("not yet implemented");
            }
        }

        export class Entry extends ValueType {
            public hashCode: number;
            public next: number;
            public key: TKey;
            public value: TValue;

        }

        export class Enumerator extends ValueType implements IEnumerator<KeyValuePair<TKey, TValue>>, IDisposable, IEnumerator, IDictionaryEnumerator {
            private _dictionary: Dictionary<TKey, TValue>;
            private _version: number;
            private _index: number;
            private _current: KeyValuePair<TKey, TValue>;
            private _getEnumeratorRetType: number;

            public get Current(): KeyValuePair<TKey, TValue> {
                throw new Error("not yet implemented");
            }
            private get __explicit__IEnumerator_Current(): any {
                throw new Error("not yet implemented");
            }
            private get __explicit__IDictionaryEnumerator_Entry(): DictionaryEntry {
                throw new Error("not yet implemented");
            }
            public get Entry(): DictionaryEntry {
                throw new Error("Invalid call (use ExplicitAs property)");
            }
            private get __explicit__IDictionaryEnumerator_Key(): any {
                throw new Error("not yet implemented");
            }
            public get Key(): any {
                throw new Error("Invalid call (use ExplicitAs property)");
            }
            private get __explicit__IDictionaryEnumerator_Value(): any {
                throw new Error("not yet implemented");
            }
            public get Value(): any {
                throw new Error("Invalid call (use ExplicitAs property)");
            }

            protected constructor(dictionary: Dictionary<TKey, TValue>, getEnumeratorRetType: number) {
                throw new Error("not yet implemented");
            }

            public MoveNext(): boolean {
                throw new Error("not yet implemented");
            }
            public Dispose() {
                throw new Error("not yet implemented");
            }
            private __explicit__IEnumerator_Reset() {
                throw new Error("not yet implemented");
            }
            public Reset() {
                throw new Error("Invalid call (use ExplicitAs property)");
            }

            public readonly ExplicitAsIEnumerator__KeyValuePair__TKey__TValue____: IEnumerator<KeyValuePair<TKey, TValue>> = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'Current') {
                        return target.__explicit__IEnumerator_Current;
                    }
                    if (prop === 'Entry') {
                        return target.__explicit__IDictionaryEnumerator_Entry;
                    }
                    if (prop === 'Key') {
                        return target.__explicit__IDictionaryEnumerator_Key;
                    }
                    if (prop === 'Value') {
                        return target.__explicit__IDictionaryEnumerator_Value;
                    }
            
                    if (prop === 'Reset') {
                        return target.__explicit__IEnumerator_Reset.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
            public readonly ExplicitAsIDisposable: IDisposable = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'Current') {
                        return target.__explicit__IEnumerator_Current;
                    }
                    if (prop === 'Entry') {
                        return target.__explicit__IDictionaryEnumerator_Entry;
                    }
                    if (prop === 'Key') {
                        return target.__explicit__IDictionaryEnumerator_Key;
                    }
                    if (prop === 'Value') {
                        return target.__explicit__IDictionaryEnumerator_Value;
                    }
            
                    if (prop === 'Reset') {
                        return target.__explicit__IEnumerator_Reset.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
            public readonly ExplicitAsIEnumerator: IEnumerator = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'Current') {
                        return target.__explicit__IEnumerator_Current;
                    }
                    if (prop === 'Entry') {
                        return target.__explicit__IDictionaryEnumerator_Entry;
                    }
                    if (prop === 'Key') {
                        return target.__explicit__IDictionaryEnumerator_Key;
                    }
                    if (prop === 'Value') {
                        return target.__explicit__IDictionaryEnumerator_Value;
                    }
            
                    if (prop === 'Reset') {
                        return target.__explicit__IEnumerator_Reset.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
            public readonly ExplicitAsIDictionaryEnumerator: IDictionaryEnumerator = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'Current') {
                        return target.__explicit__IEnumerator_Current;
                    }
                    if (prop === 'Entry') {
                        return target.__explicit__IDictionaryEnumerator_Entry;
                    }
                    if (prop === 'Key') {
                        return target.__explicit__IDictionaryEnumerator_Key;
                    }
                    if (prop === 'Value') {
                        return target.__explicit__IDictionaryEnumerator_Value;
                    }
            
                    if (prop === 'Reset') {
                        return target.__explicit__IEnumerator_Reset.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
        }

        export class KeyCollection implements ICollection<TKey>, IEnumerable<TKey>, IEnumerable, ICollection, IReadOnlyCollection<TKey> {
            private _dictionary: Dictionary<TKey, TValue>;

            public get Count(): number {
                throw new Error("not yet implemented");
            }
            private get __explicit__ICollection__TKey___IsReadOnly(): boolean {
                throw new Error("not yet implemented");
            }
            public get IsReadOnly(): boolean {
                throw new Error("Invalid call (use ExplicitAs property)");
            }
            private get __explicit__ICollection_IsSynchronized(): boolean {
                throw new Error("not yet implemented");
            }
            public get IsSynchronized(): boolean {
                throw new Error("Invalid call (use ExplicitAs property)");
            }
            private get __explicit__ICollection_SyncRoot(): any {
                throw new Error("not yet implemented");
            }
            public get SyncRoot(): any {
                throw new Error("Invalid call (use ExplicitAs property)");
            }

            public constructor(dictionary: Dictionary<TKey, TValue>) {
                throw new Error("not yet implemented");
            }

            public GetEnumerator(): Enumerator {
                throw new Error("not yet implemented");
            }
            public CopyTo(array: TKey[], index: number) {
                throw new Error("not yet implemented");
            }
            private __explicit__ICollection__TKey___Add(item: TKey) {
                throw new Error("not yet implemented");
            }
            public Add(item: TKey) {
                throw new Error("Invalid call (use ExplicitAs property)");
            }
            private __explicit__ICollection__TKey___Clear() {
                throw new Error("not yet implemented");
            }
            public Clear() {
                throw new Error("Invalid call (use ExplicitAs property)");
            }
            public Contains(item: TKey): boolean {
                throw new Error("not yet implemented");
            }
            private __explicit__ICollection__TKey___Remove(item: TKey): boolean {
                throw new Error("not yet implemented");
            }
            public Remove(item: TKey): boolean {
                throw new Error("Invalid call (use ExplicitAs property)");
            }
            private __explicit__IEnumerable__TKey___GetEnumerator(): IEnumerator<TKey> {
                throw new Error("not yet implemented");
            }
            private __explicit__IEnumerable_GetEnumerator(): IEnumerator {
                throw new Error("not yet implemented");
            }
            private __explicit__ICollection_CopyTo(array: Array, index: number) {
                throw new Error("not yet implemented");
            }

            public readonly ExplicitAsICollection__TKey__: ICollection<TKey> = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'IsReadOnly') {
                        return target.__explicit__ICollection__TKey___IsReadOnly;
                    }
                    if (prop === 'IsSynchronized') {
                        return target.__explicit__ICollection_IsSynchronized;
                    }
                    if (prop === 'SyncRoot') {
                        return target.__explicit__ICollection_SyncRoot;
                    }
            
                    if (prop === 'Add') {
                        return target.__explicit__ICollection__TKey___Add.bind(target);
                    }
                    if (prop === 'Clear') {
                        return target.__explicit__ICollection__TKey___Clear.bind(target);
                    }
                    if (prop === 'Remove') {
                        return target.__explicit__ICollection__TKey___Remove.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__IEnumerable__TKey___GetEnumerator.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                    }
                    if (prop === 'CopyTo') {
                        return target.__explicit__ICollection_CopyTo.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
            public readonly ExplicitAsIEnumerable__TKey__: IEnumerable<TKey> = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'IsReadOnly') {
                        return target.__explicit__ICollection__TKey___IsReadOnly;
                    }
                    if (prop === 'IsSynchronized') {
                        return target.__explicit__ICollection_IsSynchronized;
                    }
                    if (prop === 'SyncRoot') {
                        return target.__explicit__ICollection_SyncRoot;
                    }
            
                    if (prop === 'Add') {
                        return target.__explicit__ICollection__TKey___Add.bind(target);
                    }
                    if (prop === 'Clear') {
                        return target.__explicit__ICollection__TKey___Clear.bind(target);
                    }
                    if (prop === 'Remove') {
                        return target.__explicit__ICollection__TKey___Remove.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__IEnumerable__TKey___GetEnumerator.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                    }
                    if (prop === 'CopyTo') {
                        return target.__explicit__ICollection_CopyTo.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
            public readonly ExplicitAsIEnumerable: IEnumerable = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'IsReadOnly') {
                        return target.__explicit__ICollection__TKey___IsReadOnly;
                    }
                    if (prop === 'IsSynchronized') {
                        return target.__explicit__ICollection_IsSynchronized;
                    }
                    if (prop === 'SyncRoot') {
                        return target.__explicit__ICollection_SyncRoot;
                    }
            
                    if (prop === 'Add') {
                        return target.__explicit__ICollection__TKey___Add.bind(target);
                    }
                    if (prop === 'Clear') {
                        return target.__explicit__ICollection__TKey___Clear.bind(target);
                    }
                    if (prop === 'Remove') {
                        return target.__explicit__ICollection__TKey___Remove.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__IEnumerable__TKey___GetEnumerator.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                    }
                    if (prop === 'CopyTo') {
                        return target.__explicit__ICollection_CopyTo.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
            public readonly ExplicitAsICollection: ICollection = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'IsReadOnly') {
                        return target.__explicit__ICollection__TKey___IsReadOnly;
                    }
                    if (prop === 'IsSynchronized') {
                        return target.__explicit__ICollection_IsSynchronized;
                    }
                    if (prop === 'SyncRoot') {
                        return target.__explicit__ICollection_SyncRoot;
                    }
            
                    if (prop === 'Add') {
                        return target.__explicit__ICollection__TKey___Add.bind(target);
                    }
                    if (prop === 'Clear') {
                        return target.__explicit__ICollection__TKey___Clear.bind(target);
                    }
                    if (prop === 'Remove') {
                        return target.__explicit__ICollection__TKey___Remove.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__IEnumerable__TKey___GetEnumerator.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                    }
                    if (prop === 'CopyTo') {
                        return target.__explicit__ICollection_CopyTo.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
            public readonly ExplicitAsIReadOnlyCollection__TKey__: IReadOnlyCollection<TKey> = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'IsReadOnly') {
                        return target.__explicit__ICollection__TKey___IsReadOnly;
                    }
                    if (prop === 'IsSynchronized') {
                        return target.__explicit__ICollection_IsSynchronized;
                    }
                    if (prop === 'SyncRoot') {
                        return target.__explicit__ICollection_SyncRoot;
                    }
            
                    if (prop === 'Add') {
                        return target.__explicit__ICollection__TKey___Add.bind(target);
                    }
                    if (prop === 'Clear') {
                        return target.__explicit__ICollection__TKey___Clear.bind(target);
                    }
                    if (prop === 'Remove') {
                        return target.__explicit__ICollection__TKey___Remove.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__IEnumerable__TKey___GetEnumerator.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                    }
                    if (prop === 'CopyTo') {
                        return target.__explicit__ICollection_CopyTo.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
        }
        export namespace KeyCollection {
            export class Enumerator extends ValueType implements IEnumerator<TKey>, IDisposable, IEnumerator {
                private _dictionary: Dictionary<TKey, TValue>;
                private _index: number;
                private _version: number;
                private _currentKey: TKey;

                public get Current(): TKey {
                    throw new Error("not yet implemented");
                }
                private get __explicit__IEnumerator_Current(): any {
                    throw new Error("not yet implemented");
                }

                protected constructor(dictionary: Dictionary<TKey, TValue>) {
                    throw new Error("not yet implemented");
                }

                public Dispose() {
                    throw new Error("not yet implemented");
                }
                public MoveNext(): boolean {
                    throw new Error("not yet implemented");
                }
                private __explicit__IEnumerator_Reset() {
                    throw new Error("not yet implemented");
                }
                public Reset() {
                    throw new Error("Invalid call (use ExplicitAs property)");
                }

                public readonly ExplicitAsIEnumerator__TKey__: IEnumerator<TKey> = new Proxy(this, {
                    get(target, prop, receiver) {
                        if (prop === 'Current') {
                            return target.__explicit__IEnumerator_Current;
                        }
                
                        if (prop === 'Reset') {
                            return target.__explicit__IEnumerator_Reset.bind(target);
                        }
                
                        return Reflect.get(target, prop, receiver);
                    }
                });
                public readonly ExplicitAsIDisposable: IDisposable = new Proxy(this, {
                    get(target, prop, receiver) {
                        if (prop === 'Current') {
                            return target.__explicit__IEnumerator_Current;
                        }
                
                        if (prop === 'Reset') {
                            return target.__explicit__IEnumerator_Reset.bind(target);
                        }
                
                        return Reflect.get(target, prop, receiver);
                    }
                });
                public readonly ExplicitAsIEnumerator: IEnumerator = new Proxy(this, {
                    get(target, prop, receiver) {
                        if (prop === 'Current') {
                            return target.__explicit__IEnumerator_Current;
                        }
                
                        if (prop === 'Reset') {
                            return target.__explicit__IEnumerator_Reset.bind(target);
                        }
                
                        return Reflect.get(target, prop, receiver);
                    }
                });
            }
        }

        export class ValueCollection implements ICollection<TValue>, IEnumerable<TValue>, IEnumerable, ICollection, IReadOnlyCollection<TValue> {
            private _dictionary: Dictionary<TKey, TValue>;

            public get Count(): number {
                throw new Error("not yet implemented");
            }
            private get __explicit__ICollection__TValue___IsReadOnly(): boolean {
                throw new Error("not yet implemented");
            }
            public get IsReadOnly(): boolean {
                throw new Error("Invalid call (use ExplicitAs property)");
            }
            private get __explicit__ICollection_IsSynchronized(): boolean {
                throw new Error("not yet implemented");
            }
            public get IsSynchronized(): boolean {
                throw new Error("Invalid call (use ExplicitAs property)");
            }
            private get __explicit__ICollection_SyncRoot(): any {
                throw new Error("not yet implemented");
            }
            public get SyncRoot(): any {
                throw new Error("Invalid call (use ExplicitAs property)");
            }

            public constructor(dictionary: Dictionary<TKey, TValue>) {
                throw new Error("not yet implemented");
            }

            public GetEnumerator(): Enumerator {
                throw new Error("not yet implemented");
            }
            public CopyTo(array: TValue[], index: number) {
                throw new Error("not yet implemented");
            }
            private __explicit__ICollection__TValue___Add(item: TValue) {
                throw new Error("not yet implemented");
            }
            public Add(item: TValue) {
                throw new Error("Invalid call (use ExplicitAs property)");
            }
            private __explicit__ICollection__TValue___Remove(item: TValue): boolean {
                throw new Error("not yet implemented");
            }
            public Remove(item: TValue): boolean {
                throw new Error("Invalid call (use ExplicitAs property)");
            }
            private __explicit__ICollection__TValue___Clear() {
                throw new Error("not yet implemented");
            }
            public Clear() {
                throw new Error("Invalid call (use ExplicitAs property)");
            }
            private __explicit__ICollection__TValue___Contains(item: TValue): boolean {
                throw new Error("not yet implemented");
            }
            public Contains(item: TValue): boolean {
                throw new Error("Invalid call (use ExplicitAs property)");
            }
            private __explicit__IEnumerable__TValue___GetEnumerator(): IEnumerator<TValue> {
                throw new Error("not yet implemented");
            }
            private __explicit__IEnumerable_GetEnumerator(): IEnumerator {
                throw new Error("not yet implemented");
            }
            private __explicit__ICollection_CopyTo(array: Array, index: number) {
                throw new Error("not yet implemented");
            }

            public readonly ExplicitAsICollection__TValue__: ICollection<TValue> = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'IsReadOnly') {
                        return target.__explicit__ICollection__TValue___IsReadOnly;
                    }
                    if (prop === 'IsSynchronized') {
                        return target.__explicit__ICollection_IsSynchronized;
                    }
                    if (prop === 'SyncRoot') {
                        return target.__explicit__ICollection_SyncRoot;
                    }
            
                    if (prop === 'Add') {
                        return target.__explicit__ICollection__TValue___Add.bind(target);
                    }
                    if (prop === 'Remove') {
                        return target.__explicit__ICollection__TValue___Remove.bind(target);
                    }
                    if (prop === 'Clear') {
                        return target.__explicit__ICollection__TValue___Clear.bind(target);
                    }
                    if (prop === 'Contains') {
                        return target.__explicit__ICollection__TValue___Contains.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__IEnumerable__TValue___GetEnumerator.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                    }
                    if (prop === 'CopyTo') {
                        return target.__explicit__ICollection_CopyTo.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
            public readonly ExplicitAsIEnumerable__TValue__: IEnumerable<TValue> = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'IsReadOnly') {
                        return target.__explicit__ICollection__TValue___IsReadOnly;
                    }
                    if (prop === 'IsSynchronized') {
                        return target.__explicit__ICollection_IsSynchronized;
                    }
                    if (prop === 'SyncRoot') {
                        return target.__explicit__ICollection_SyncRoot;
                    }
            
                    if (prop === 'Add') {
                        return target.__explicit__ICollection__TValue___Add.bind(target);
                    }
                    if (prop === 'Remove') {
                        return target.__explicit__ICollection__TValue___Remove.bind(target);
                    }
                    if (prop === 'Clear') {
                        return target.__explicit__ICollection__TValue___Clear.bind(target);
                    }
                    if (prop === 'Contains') {
                        return target.__explicit__ICollection__TValue___Contains.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__IEnumerable__TValue___GetEnumerator.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                    }
                    if (prop === 'CopyTo') {
                        return target.__explicit__ICollection_CopyTo.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
            public readonly ExplicitAsIEnumerable: IEnumerable = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'IsReadOnly') {
                        return target.__explicit__ICollection__TValue___IsReadOnly;
                    }
                    if (prop === 'IsSynchronized') {
                        return target.__explicit__ICollection_IsSynchronized;
                    }
                    if (prop === 'SyncRoot') {
                        return target.__explicit__ICollection_SyncRoot;
                    }
            
                    if (prop === 'Add') {
                        return target.__explicit__ICollection__TValue___Add.bind(target);
                    }
                    if (prop === 'Remove') {
                        return target.__explicit__ICollection__TValue___Remove.bind(target);
                    }
                    if (prop === 'Clear') {
                        return target.__explicit__ICollection__TValue___Clear.bind(target);
                    }
                    if (prop === 'Contains') {
                        return target.__explicit__ICollection__TValue___Contains.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__IEnumerable__TValue___GetEnumerator.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                    }
                    if (prop === 'CopyTo') {
                        return target.__explicit__ICollection_CopyTo.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
            public readonly ExplicitAsICollection: ICollection = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'IsReadOnly') {
                        return target.__explicit__ICollection__TValue___IsReadOnly;
                    }
                    if (prop === 'IsSynchronized') {
                        return target.__explicit__ICollection_IsSynchronized;
                    }
                    if (prop === 'SyncRoot') {
                        return target.__explicit__ICollection_SyncRoot;
                    }
            
                    if (prop === 'Add') {
                        return target.__explicit__ICollection__TValue___Add.bind(target);
                    }
                    if (prop === 'Remove') {
                        return target.__explicit__ICollection__TValue___Remove.bind(target);
                    }
                    if (prop === 'Clear') {
                        return target.__explicit__ICollection__TValue___Clear.bind(target);
                    }
                    if (prop === 'Contains') {
                        return target.__explicit__ICollection__TValue___Contains.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__IEnumerable__TValue___GetEnumerator.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                    }
                    if (prop === 'CopyTo') {
                        return target.__explicit__ICollection_CopyTo.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
            public readonly ExplicitAsIReadOnlyCollection__TValue__: IReadOnlyCollection<TValue> = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'IsReadOnly') {
                        return target.__explicit__ICollection__TValue___IsReadOnly;
                    }
                    if (prop === 'IsSynchronized') {
                        return target.__explicit__ICollection_IsSynchronized;
                    }
                    if (prop === 'SyncRoot') {
                        return target.__explicit__ICollection_SyncRoot;
                    }
            
                    if (prop === 'Add') {
                        return target.__explicit__ICollection__TValue___Add.bind(target);
                    }
                    if (prop === 'Remove') {
                        return target.__explicit__ICollection__TValue___Remove.bind(target);
                    }
                    if (prop === 'Clear') {
                        return target.__explicit__ICollection__TValue___Clear.bind(target);
                    }
                    if (prop === 'Contains') {
                        return target.__explicit__ICollection__TValue___Contains.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__IEnumerable__TValue___GetEnumerator.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                    }
                    if (prop === 'CopyTo') {
                        return target.__explicit__ICollection_CopyTo.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
        }
        export namespace ValueCollection {
            export class Enumerator extends ValueType implements IEnumerator<TValue>, IDisposable, IEnumerator {
                private _dictionary: Dictionary<TKey, TValue>;
                private _index: number;
                private _version: number;
                private _currentValue: TValue;

                public get Current(): TValue {
                    throw new Error("not yet implemented");
                }
                private get __explicit__IEnumerator_Current(): any {
                    throw new Error("not yet implemented");
                }

                protected constructor(dictionary: Dictionary<TKey, TValue>) {
                    throw new Error("not yet implemented");
                }

                public Dispose() {
                    throw new Error("not yet implemented");
                }
                public MoveNext(): boolean {
                    throw new Error("not yet implemented");
                }
                private __explicit__IEnumerator_Reset() {
                    throw new Error("not yet implemented");
                }
                public Reset() {
                    throw new Error("Invalid call (use ExplicitAs property)");
                }

                public readonly ExplicitAsIEnumerator__TValue__: IEnumerator<TValue> = new Proxy(this, {
                    get(target, prop, receiver) {
                        if (prop === 'Current') {
                            return target.__explicit__IEnumerator_Current;
                        }
                
                        if (prop === 'Reset') {
                            return target.__explicit__IEnumerator_Reset.bind(target);
                        }
                
                        return Reflect.get(target, prop, receiver);
                    }
                });
                public readonly ExplicitAsIDisposable: IDisposable = new Proxy(this, {
                    get(target, prop, receiver) {
                        if (prop === 'Current') {
                            return target.__explicit__IEnumerator_Current;
                        }
                
                        if (prop === 'Reset') {
                            return target.__explicit__IEnumerator_Reset.bind(target);
                        }
                
                        return Reflect.get(target, prop, receiver);
                    }
                });
                public readonly ExplicitAsIEnumerator: IEnumerator = new Proxy(this, {
                    get(target, prop, receiver) {
                        if (prop === 'Current') {
                            return target.__explicit__IEnumerator_Current;
                        }
                
                        if (prop === 'Reset') {
                            return target.__explicit__IEnumerator_Reset.bind(target);
                        }
                
                        return Reflect.get(target, prop, receiver);
                    }
                });
            }
        }
    }
}
export namespace System.Collections.ObjectModel {
    export class ReadOnlyCollection<T> implements IList<T>, ICollection<T>, IEnumerable<T>, IEnumerable, IList, ICollection, IReadOnlyList<T>, IReadOnlyCollection<T> {
        private static readonly __Empty__k__BackingField: ReadOnlyCollection<T>;

        public static get Empty(): ReadOnlyCollection<T> {
            throw new Error("not yet implemented");
        }

        private list: IList<T>;

        public get Count(): number {
            throw new Error("not yet implemented");
        }
        public get Item(): T {
            throw new Error("not yet implemented");
        }
        private get Items(): IList<T> {
            throw new Error("not yet implemented");
        }
        private get __explicit__ICollection__T___IsReadOnly(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsReadOnly(): boolean {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private get __explicit__IList__T___Item(): T {
            throw new Error("not yet implemented");
        }
        private set __explicit__IList__T___Item(index: number) {
            throw new Error("not yet implemented");
        }
        private get __explicit__ICollection_IsSynchronized(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsSynchronized(): boolean {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private get __explicit__ICollection_SyncRoot(): any {
            throw new Error("not yet implemented");
        }
        public get SyncRoot(): any {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private get __explicit__IList_IsFixedSize(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsFixedSize(): boolean {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private get __explicit__IList_IsReadOnly(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsReadOnly(): boolean {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private get __explicit__IList_Item(): any {
            throw new Error("not yet implemented");
        }
        private set __explicit__IList_Item(index: number) {
            throw new Error("not yet implemented");
        }

        public constructor(list: IList<T>) {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

        public Contains(value: T): boolean {
            throw new Error("not yet implemented");
        }
        public CopyTo(array: T[], index: number) {
            throw new Error("not yet implemented");
        }
        public GetEnumerator(): IEnumerator<T> {
            throw new Error("not yet implemented");
        }
        public IndexOf(value: T): number {
            throw new Error("not yet implemented");
        }
        private __explicit__ICollection__T___Add(value: T) {
            throw new Error("not yet implemented");
        }
        public Add(value: T) {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__ICollection__T___Clear() {
            throw new Error("not yet implemented");
        }
        public Clear() {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__IList__T___Insert(index: number, value: T) {
            throw new Error("not yet implemented");
        }
        public Insert(index: number, value: T) {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__ICollection__T___Remove(value: T): boolean {
            throw new Error("not yet implemented");
        }
        public Remove(value: T): boolean {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__IList__T___RemoveAt(index: number) {
            throw new Error("not yet implemented");
        }
        public RemoveAt(index: number) {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__IEnumerable_GetEnumerator(): IEnumerator {
            throw new Error("not yet implemented");
        }
        private __explicit__ICollection_CopyTo(array: Array, index: number) {
            throw new Error("not yet implemented");
        }
        private __explicit__IList_Add(value: any): number {
            throw new Error("not yet implemented");
        }
        public Add(value: any): number {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__IList_Clear() {
            throw new Error("not yet implemented");
        }
        public Clear() {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private static IsCompatibleObject(value: any): boolean {
            throw new Error("not yet implemented");
        }
        private __explicit__IList_Contains(value: any): boolean {
            throw new Error("not yet implemented");
        }
        private __explicit__IList_IndexOf(value: any): number {
            throw new Error("not yet implemented");
        }
        private __explicit__IList_Insert(index: number, value: any) {
            throw new Error("not yet implemented");
        }
        public Insert(index: number, value: any) {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__IList_Remove(value: any) {
            throw new Error("not yet implemented");
        }
        public Remove(value: any) {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__IList_RemoveAt(index: number) {
            throw new Error("not yet implemented");
        }
        public RemoveAt(index: number) {
            throw new Error("Invalid call (use ExplicitAs property)");
        }

        public readonly ExplicitAsIList__T__: IList<T> = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'IsReadOnly') {
                    return target.__explicit__ICollection__T___IsReadOnly;
                }
                if (prop === 'Item') {
                    return target.__explicit__IList__T___Item;
                }
                if (prop === 'IsSynchronized') {
                    return target.__explicit__ICollection_IsSynchronized;
                }
                if (prop === 'SyncRoot') {
                    return target.__explicit__ICollection_SyncRoot;
                }
                if (prop === 'IsFixedSize') {
                    return target.__explicit__IList_IsFixedSize;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__IList_IsReadOnly;
                }
                if (prop === 'Item') {
                    return target.__explicit__IList_Item;
                }
        
                if (prop === 'Add') {
                    return target.__explicit__ICollection__T___Add.bind(target);
                }
                if (prop === 'Clear') {
                    return target.__explicit__ICollection__T___Clear.bind(target);
                }
                if (prop === 'Insert') {
                    return target.__explicit__IList__T___Insert.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__ICollection__T___Remove.bind(target);
                }
                if (prop === 'RemoveAt') {
                    return target.__explicit__IList__T___RemoveAt.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                }
                if (prop === 'CopyTo') {
                    return target.__explicit__ICollection_CopyTo.bind(target);
                }
                if (prop === 'Add') {
                    return target.__explicit__IList_Add.bind(target);
                }
                if (prop === 'Clear') {
                    return target.__explicit__IList_Clear.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__IList_Contains.bind(target);
                }
                if (prop === 'IndexOf') {
                    return target.__explicit__IList_IndexOf.bind(target);
                }
                if (prop === 'Insert') {
                    return target.__explicit__IList_Insert.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__IList_Remove.bind(target);
                }
                if (prop === 'RemoveAt') {
                    return target.__explicit__IList_RemoveAt.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsICollection__T__: ICollection<T> = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'IsReadOnly') {
                    return target.__explicit__ICollection__T___IsReadOnly;
                }
                if (prop === 'Item') {
                    return target.__explicit__IList__T___Item;
                }
                if (prop === 'IsSynchronized') {
                    return target.__explicit__ICollection_IsSynchronized;
                }
                if (prop === 'SyncRoot') {
                    return target.__explicit__ICollection_SyncRoot;
                }
                if (prop === 'IsFixedSize') {
                    return target.__explicit__IList_IsFixedSize;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__IList_IsReadOnly;
                }
                if (prop === 'Item') {
                    return target.__explicit__IList_Item;
                }
        
                if (prop === 'Add') {
                    return target.__explicit__ICollection__T___Add.bind(target);
                }
                if (prop === 'Clear') {
                    return target.__explicit__ICollection__T___Clear.bind(target);
                }
                if (prop === 'Insert') {
                    return target.__explicit__IList__T___Insert.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__ICollection__T___Remove.bind(target);
                }
                if (prop === 'RemoveAt') {
                    return target.__explicit__IList__T___RemoveAt.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                }
                if (prop === 'CopyTo') {
                    return target.__explicit__ICollection_CopyTo.bind(target);
                }
                if (prop === 'Add') {
                    return target.__explicit__IList_Add.bind(target);
                }
                if (prop === 'Clear') {
                    return target.__explicit__IList_Clear.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__IList_Contains.bind(target);
                }
                if (prop === 'IndexOf') {
                    return target.__explicit__IList_IndexOf.bind(target);
                }
                if (prop === 'Insert') {
                    return target.__explicit__IList_Insert.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__IList_Remove.bind(target);
                }
                if (prop === 'RemoveAt') {
                    return target.__explicit__IList_RemoveAt.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIEnumerable__T__: IEnumerable<T> = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'IsReadOnly') {
                    return target.__explicit__ICollection__T___IsReadOnly;
                }
                if (prop === 'Item') {
                    return target.__explicit__IList__T___Item;
                }
                if (prop === 'IsSynchronized') {
                    return target.__explicit__ICollection_IsSynchronized;
                }
                if (prop === 'SyncRoot') {
                    return target.__explicit__ICollection_SyncRoot;
                }
                if (prop === 'IsFixedSize') {
                    return target.__explicit__IList_IsFixedSize;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__IList_IsReadOnly;
                }
                if (prop === 'Item') {
                    return target.__explicit__IList_Item;
                }
        
                if (prop === 'Add') {
                    return target.__explicit__ICollection__T___Add.bind(target);
                }
                if (prop === 'Clear') {
                    return target.__explicit__ICollection__T___Clear.bind(target);
                }
                if (prop === 'Insert') {
                    return target.__explicit__IList__T___Insert.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__ICollection__T___Remove.bind(target);
                }
                if (prop === 'RemoveAt') {
                    return target.__explicit__IList__T___RemoveAt.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                }
                if (prop === 'CopyTo') {
                    return target.__explicit__ICollection_CopyTo.bind(target);
                }
                if (prop === 'Add') {
                    return target.__explicit__IList_Add.bind(target);
                }
                if (prop === 'Clear') {
                    return target.__explicit__IList_Clear.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__IList_Contains.bind(target);
                }
                if (prop === 'IndexOf') {
                    return target.__explicit__IList_IndexOf.bind(target);
                }
                if (prop === 'Insert') {
                    return target.__explicit__IList_Insert.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__IList_Remove.bind(target);
                }
                if (prop === 'RemoveAt') {
                    return target.__explicit__IList_RemoveAt.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIEnumerable: IEnumerable = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'IsReadOnly') {
                    return target.__explicit__ICollection__T___IsReadOnly;
                }
                if (prop === 'Item') {
                    return target.__explicit__IList__T___Item;
                }
                if (prop === 'IsSynchronized') {
                    return target.__explicit__ICollection_IsSynchronized;
                }
                if (prop === 'SyncRoot') {
                    return target.__explicit__ICollection_SyncRoot;
                }
                if (prop === 'IsFixedSize') {
                    return target.__explicit__IList_IsFixedSize;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__IList_IsReadOnly;
                }
                if (prop === 'Item') {
                    return target.__explicit__IList_Item;
                }
        
                if (prop === 'Add') {
                    return target.__explicit__ICollection__T___Add.bind(target);
                }
                if (prop === 'Clear') {
                    return target.__explicit__ICollection__T___Clear.bind(target);
                }
                if (prop === 'Insert') {
                    return target.__explicit__IList__T___Insert.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__ICollection__T___Remove.bind(target);
                }
                if (prop === 'RemoveAt') {
                    return target.__explicit__IList__T___RemoveAt.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                }
                if (prop === 'CopyTo') {
                    return target.__explicit__ICollection_CopyTo.bind(target);
                }
                if (prop === 'Add') {
                    return target.__explicit__IList_Add.bind(target);
                }
                if (prop === 'Clear') {
                    return target.__explicit__IList_Clear.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__IList_Contains.bind(target);
                }
                if (prop === 'IndexOf') {
                    return target.__explicit__IList_IndexOf.bind(target);
                }
                if (prop === 'Insert') {
                    return target.__explicit__IList_Insert.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__IList_Remove.bind(target);
                }
                if (prop === 'RemoveAt') {
                    return target.__explicit__IList_RemoveAt.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIList: IList = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'IsReadOnly') {
                    return target.__explicit__ICollection__T___IsReadOnly;
                }
                if (prop === 'Item') {
                    return target.__explicit__IList__T___Item;
                }
                if (prop === 'IsSynchronized') {
                    return target.__explicit__ICollection_IsSynchronized;
                }
                if (prop === 'SyncRoot') {
                    return target.__explicit__ICollection_SyncRoot;
                }
                if (prop === 'IsFixedSize') {
                    return target.__explicit__IList_IsFixedSize;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__IList_IsReadOnly;
                }
                if (prop === 'Item') {
                    return target.__explicit__IList_Item;
                }
        
                if (prop === 'Add') {
                    return target.__explicit__ICollection__T___Add.bind(target);
                }
                if (prop === 'Clear') {
                    return target.__explicit__ICollection__T___Clear.bind(target);
                }
                if (prop === 'Insert') {
                    return target.__explicit__IList__T___Insert.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__ICollection__T___Remove.bind(target);
                }
                if (prop === 'RemoveAt') {
                    return target.__explicit__IList__T___RemoveAt.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                }
                if (prop === 'CopyTo') {
                    return target.__explicit__ICollection_CopyTo.bind(target);
                }
                if (prop === 'Add') {
                    return target.__explicit__IList_Add.bind(target);
                }
                if (prop === 'Clear') {
                    return target.__explicit__IList_Clear.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__IList_Contains.bind(target);
                }
                if (prop === 'IndexOf') {
                    return target.__explicit__IList_IndexOf.bind(target);
                }
                if (prop === 'Insert') {
                    return target.__explicit__IList_Insert.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__IList_Remove.bind(target);
                }
                if (prop === 'RemoveAt') {
                    return target.__explicit__IList_RemoveAt.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsICollection: ICollection = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'IsReadOnly') {
                    return target.__explicit__ICollection__T___IsReadOnly;
                }
                if (prop === 'Item') {
                    return target.__explicit__IList__T___Item;
                }
                if (prop === 'IsSynchronized') {
                    return target.__explicit__ICollection_IsSynchronized;
                }
                if (prop === 'SyncRoot') {
                    return target.__explicit__ICollection_SyncRoot;
                }
                if (prop === 'IsFixedSize') {
                    return target.__explicit__IList_IsFixedSize;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__IList_IsReadOnly;
                }
                if (prop === 'Item') {
                    return target.__explicit__IList_Item;
                }
        
                if (prop === 'Add') {
                    return target.__explicit__ICollection__T___Add.bind(target);
                }
                if (prop === 'Clear') {
                    return target.__explicit__ICollection__T___Clear.bind(target);
                }
                if (prop === 'Insert') {
                    return target.__explicit__IList__T___Insert.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__ICollection__T___Remove.bind(target);
                }
                if (prop === 'RemoveAt') {
                    return target.__explicit__IList__T___RemoveAt.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                }
                if (prop === 'CopyTo') {
                    return target.__explicit__ICollection_CopyTo.bind(target);
                }
                if (prop === 'Add') {
                    return target.__explicit__IList_Add.bind(target);
                }
                if (prop === 'Clear') {
                    return target.__explicit__IList_Clear.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__IList_Contains.bind(target);
                }
                if (prop === 'IndexOf') {
                    return target.__explicit__IList_IndexOf.bind(target);
                }
                if (prop === 'Insert') {
                    return target.__explicit__IList_Insert.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__IList_Remove.bind(target);
                }
                if (prop === 'RemoveAt') {
                    return target.__explicit__IList_RemoveAt.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIReadOnlyList__T__: IReadOnlyList<T> = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'IsReadOnly') {
                    return target.__explicit__ICollection__T___IsReadOnly;
                }
                if (prop === 'Item') {
                    return target.__explicit__IList__T___Item;
                }
                if (prop === 'IsSynchronized') {
                    return target.__explicit__ICollection_IsSynchronized;
                }
                if (prop === 'SyncRoot') {
                    return target.__explicit__ICollection_SyncRoot;
                }
                if (prop === 'IsFixedSize') {
                    return target.__explicit__IList_IsFixedSize;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__IList_IsReadOnly;
                }
                if (prop === 'Item') {
                    return target.__explicit__IList_Item;
                }
        
                if (prop === 'Add') {
                    return target.__explicit__ICollection__T___Add.bind(target);
                }
                if (prop === 'Clear') {
                    return target.__explicit__ICollection__T___Clear.bind(target);
                }
                if (prop === 'Insert') {
                    return target.__explicit__IList__T___Insert.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__ICollection__T___Remove.bind(target);
                }
                if (prop === 'RemoveAt') {
                    return target.__explicit__IList__T___RemoveAt.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                }
                if (prop === 'CopyTo') {
                    return target.__explicit__ICollection_CopyTo.bind(target);
                }
                if (prop === 'Add') {
                    return target.__explicit__IList_Add.bind(target);
                }
                if (prop === 'Clear') {
                    return target.__explicit__IList_Clear.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__IList_Contains.bind(target);
                }
                if (prop === 'IndexOf') {
                    return target.__explicit__IList_IndexOf.bind(target);
                }
                if (prop === 'Insert') {
                    return target.__explicit__IList_Insert.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__IList_Remove.bind(target);
                }
                if (prop === 'RemoveAt') {
                    return target.__explicit__IList_RemoveAt.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIReadOnlyCollection__T__: IReadOnlyCollection<T> = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'IsReadOnly') {
                    return target.__explicit__ICollection__T___IsReadOnly;
                }
                if (prop === 'Item') {
                    return target.__explicit__IList__T___Item;
                }
                if (prop === 'IsSynchronized') {
                    return target.__explicit__ICollection_IsSynchronized;
                }
                if (prop === 'SyncRoot') {
                    return target.__explicit__ICollection_SyncRoot;
                }
                if (prop === 'IsFixedSize') {
                    return target.__explicit__IList_IsFixedSize;
                }
                if (prop === 'IsReadOnly') {
                    return target.__explicit__IList_IsReadOnly;
                }
                if (prop === 'Item') {
                    return target.__explicit__IList_Item;
                }
        
                if (prop === 'Add') {
                    return target.__explicit__ICollection__T___Add.bind(target);
                }
                if (prop === 'Clear') {
                    return target.__explicit__ICollection__T___Clear.bind(target);
                }
                if (prop === 'Insert') {
                    return target.__explicit__IList__T___Insert.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__ICollection__T___Remove.bind(target);
                }
                if (prop === 'RemoveAt') {
                    return target.__explicit__IList__T___RemoveAt.bind(target);
                }
                if (prop === 'GetEnumerator') {
                    return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                }
                if (prop === 'CopyTo') {
                    return target.__explicit__ICollection_CopyTo.bind(target);
                }
                if (prop === 'Add') {
                    return target.__explicit__IList_Add.bind(target);
                }
                if (prop === 'Clear') {
                    return target.__explicit__IList_Clear.bind(target);
                }
                if (prop === 'Contains') {
                    return target.__explicit__IList_Contains.bind(target);
                }
                if (prop === 'IndexOf') {
                    return target.__explicit__IList_IndexOf.bind(target);
                }
                if (prop === 'Insert') {
                    return target.__explicit__IList_Insert.bind(target);
                }
                if (prop === 'Remove') {
                    return target.__explicit__IList_Remove.bind(target);
                }
                if (prop === 'RemoveAt') {
                    return target.__explicit__IList_RemoveAt.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
    }
}
export namespace System.Configuration.Assemblies {
    export enum AssemblyHashAlgorithm {
        None = 0,
        MD5 = 32771,
        SHA1 = 32772,
        SHA256 = 32780,
        SHA384 = 32781,
        SHA512 = 32782,
    }
    export enum AssemblyVersionCompatibility {
        SameMachine = 1,
        SameProcess = 2,
        SameDomain = 3,
    }
}
export namespace System.Globalization {
    export enum TimeSpanStyles {
        None = 0x0,
        AssumeNegative = 0x1,
    }
    export class SortVersion implements IEquatable<SortVersion> {
        private m_NlsVersion: number;
        private m_SortId: Guid;

        public get FullVersion(): number {
            throw new Error("not yet implemented");
        }
        public get SortId(): Guid {
            throw new Error("not yet implemented");
        }

        public constructor(fullVersion: number, sortId: Guid) {
            throw new Error("not yet implemented");
        }
        protected constructor(nlsVersion: number, effectiveId: number, customVersion: Guid) {
            throw new Error("not yet implemented");
        }

        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public Equals(other: SortVersion): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
    }
    export enum CalendarId {
        UNINITIALIZED_VALUE = 0,
        GREGORIAN = 1,
        GREGORIAN_US = 2,
        JAPAN = 3,
        TAIWAN = 4,
        KOREA = 5,
        HIJRI = 6,
        THAI = 7,
        HEBREW = 8,
        GREGORIAN_ME_FRENCH = 9,
        GREGORIAN_ARABIC = 10,
        GREGORIAN_XLIT_ENGLISH = 11,
        GREGORIAN_XLIT_FRENCH = 12,
        JULIAN = 13,
        JAPANESELUNISOLAR = 14,
        CHINESELUNISOLAR = 15,
        SAKA = 16,
        LUNAR_ETO_CHN = 17,
        LUNAR_ETO_KOR = 18,
        LUNAR_ETO_ROKUYOU = 19,
        KOREANLUNISOLAR = 20,
        TAIWANLUNISOLAR = 21,
        PERSIAN = 22,
        UMALQURA = 23,
        LAST_CALENDAR = 23,
    }
    export enum CalendarAlgorithmType {
        Unknown = 0,
        SolarCalendar = 1,
        LunarCalendar = 2,
        LunisolarCalendar = 3,
    }
    export enum CalendarWeekRule {
        FirstDay = 0,
        FirstFullWeek = 1,
        FirstFourDayWeek = 2,
    }
    export abstract class Calendar implements ICloneable {
        public static CurrentEra: number;

        private _currentEraValue: number;
        private _isReadOnly: boolean;
        private _twoDigitYearMax: number;

        public get MinSupportedDateTime(): DateTime {
            throw new Error("not yet implemented");
        }
        public get MaxSupportedDateTime(): DateTime {
            throw new Error("not yet implemented");
        }
        public get AlgorithmType(): CalendarAlgorithmType {
            throw new Error("not yet implemented");
        }
        private get ID(): CalendarId {
            throw new Error("not yet implemented");
        }
        private get BaseCalendarID(): CalendarId {
            throw new Error("not yet implemented");
        }
        public get IsReadOnly(): boolean {
            throw new Error("not yet implemented");
        }
        private get CurrentEraValue(): number {
            throw new Error("not yet implemented");
        }
        public get Eras(): number[];
        private get DaysInYearBeforeMinSupportedYear(): number {
            throw new Error("not yet implemented");
        }
        public get TwoDigitYearMax(): number {
            throw new Error("not yet implemented");
        }
        public set TwoDigitYearMax(value: number) {
            throw new Error("not yet implemented");
        }

        protected constructor() {
            throw new Error("not yet implemented");
        }

        public Clone(): any {
            throw new Error("not yet implemented");
        }
        public static ReadOnly(calendar: Calendar): Calendar {
            throw new Error("not yet implemented");
        }
        private VerifyWritable() {
            throw new Error("not yet implemented");
        }
        private SetReadOnlyState(readOnly: boolean) {
            throw new Error("not yet implemented");
        }
        private static CheckAddResult(ticks: number, minValue: DateTime, maxValue: DateTime) {
            throw new Error("not yet implemented");
        }
        private Add(time: DateTime, value: number, scale: number): DateTime {
            throw new Error("not yet implemented");
        }
        public AddMilliseconds(time: DateTime, milliseconds: number): DateTime {
            throw new Error("not yet implemented");
        }
        public AddDays(time: DateTime, days: number): DateTime {
            throw new Error("not yet implemented");
        }
        public AddHours(time: DateTime, hours: number): DateTime {
            throw new Error("not yet implemented");
        }
        public AddMinutes(time: DateTime, minutes: number): DateTime {
            throw new Error("not yet implemented");
        }
        public AddMonths(time: DateTime, months: number): DateTime;
        public AddSeconds(time: DateTime, seconds: number): DateTime {
            throw new Error("not yet implemented");
        }
        public AddWeeks(time: DateTime, weeks: number): DateTime {
            throw new Error("not yet implemented");
        }
        public AddYears(time: DateTime, years: number): DateTime;
        public GetDayOfMonth(time: DateTime): number;
        public GetDayOfWeek(time: DateTime): DayOfWeek;
        public GetDayOfYear(time: DateTime): number;
        public GetDaysInMonth(year: number, month: number): number {
            throw new Error("not yet implemented");
        }
        public GetDaysInMonth(year: number, month: number, era: number): number;
        public GetDaysInYear(year: number): number {
            throw new Error("not yet implemented");
        }
        public GetDaysInYear(year: number, era: number): number;
        public GetEra(time: DateTime): number;
        public GetHour(time: DateTime): number {
            throw new Error("not yet implemented");
        }
        public GetMilliseconds(time: DateTime): number {
            throw new Error("not yet implemented");
        }
        public GetMinute(time: DateTime): number {
            throw new Error("not yet implemented");
        }
        public GetMonth(time: DateTime): number;
        public GetMonthsInYear(year: number): number {
            throw new Error("not yet implemented");
        }
        public GetMonthsInYear(year: number, era: number): number;
        public GetSecond(time: DateTime): number {
            throw new Error("not yet implemented");
        }
        private GetFirstDayWeekOfYear(time: DateTime, firstDayOfWeek: number): number {
            throw new Error("not yet implemented");
        }
        private GetWeekOfYearFullDays(time: DateTime, firstDayOfWeek: number, fullDays: number): number {
            throw new Error("not yet implemented");
        }
        private GetWeekOfYearOfMinSupportedDateTime(firstDayOfWeek: number, minimumDaysInFirstWeek: number): number {
            throw new Error("not yet implemented");
        }
        public GetWeekOfYear(time: DateTime, rule: CalendarWeekRule, firstDayOfWeek: DayOfWeek): number {
            throw new Error("not yet implemented");
        }
        public GetYear(time: DateTime): number;
        public IsLeapDay(year: number, month: number, day: number): boolean {
            throw new Error("not yet implemented");
        }
        public IsLeapDay(year: number, month: number, day: number, era: number): boolean;
        public IsLeapMonth(year: number, month: number): boolean {
            throw new Error("not yet implemented");
        }
        public IsLeapMonth(year: number, month: number, era: number): boolean;
        public GetLeapMonth(year: number): number {
            throw new Error("not yet implemented");
        }
        public GetLeapMonth(year: number, era: number): number {
            throw new Error("not yet implemented");
        }
        public IsLeapYear(year: number): boolean {
            throw new Error("not yet implemented");
        }
        public IsLeapYear(year: number, era: number): boolean;
        public ToDateTime(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number): DateTime {
            throw new Error("not yet implemented");
        }
        public ToDateTime(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, era: number): DateTime;
        private TryToDateTime(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, era: number, out result: DateTime): boolean {
            throw new Error("not yet implemented");
        }
        private IsValidYear(year: number, era: number): boolean {
            throw new Error("not yet implemented");
        }
        private IsValidMonth(year: number, month: number, era: number): boolean {
            throw new Error("not yet implemented");
        }
        private IsValidDay(year: number, month: number, day: number, era: number): boolean {
            throw new Error("not yet implemented");
        }
        public ToFourDigitYear(year: number): number {
            throw new Error("not yet implemented");
        }
        private static TimeToTicks(hour: number, minute: number, second: number, millisecond: number): number {
            throw new Error("not yet implemented");
        }
        private static GetSystemTwoDigitYearSetting(CalID: CalendarId, defaultYearValue: number): number {
            throw new Error("not yet implemented");
        }
    }
    export enum CalendarDataType {
        Uninitialized = 0,
        NativeName = 1,
        MonthDay = 2,
        ShortDates = 3,
        LongDates = 4,
        YearMonths = 5,
        DayNames = 6,
        AbbrevDayNames = 7,
        MonthNames = 8,
        AbbrevMonthNames = 9,
        SuperShortDayNames = 10,
        MonthGenitiveNames = 11,
        AbbrevMonthGenitiveNames = 12,
        EraNames = 13,
        AbbrevEraNames = 14,
    }
    export class IcuEnumCalendarsData extends ValueType {
        public Results: List<string>;
        public DisallowDuplicates: boolean;

    }
    export class CalendarData {
        private static readonly Invariant: CalendarData;

        private sNativeName: string;
        private saShortDates: string[];
        private saYearMonths: string[];
        private saLongDates: string[];
        private sMonthDay: string;
        private saEraNames: string[];
        private saAbbrevEraNames: string[];
        private saAbbrevEnglishEraNames: string[];
        private saDayNames: string[];
        private saAbbrevDayNames: string[];
        private saSuperShortDayNames: string[];
        private saMonthNames: string[];
        private saAbbrevMonthNames: string[];
        private saMonthGenitiveNames: string[];
        private saAbbrevMonthGenitiveNames: string[];
        private saLeapYearMonthNames: string[];
        private iTwoDigitYearMax: number;
        private iCurrentEra: number;
        private bUseUserOverrides: boolean;

        private constructor() {
            throw new Error("not yet implemented");
        }
        protected constructor(localeName: string, calendarId: CalendarId, bUseUserOverrides: boolean) {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

        private static CreateInvariant(): CalendarData {
            throw new Error("not yet implemented");
        }
        private InitializeEraNames(localeName: string, calendarId: CalendarId) {
            throw new Error("not yet implemented");
        }
        private InitializeAbbreviatedEraNames(localeName: string, calendarId: CalendarId) {
            throw new Error("not yet implemented");
        }
        private static GetCalendarCurrentEra(calendar: Calendar): number {
            throw new Error("not yet implemented");
        }
        private static CalendarIdToCultureName(calendarId: CalendarId): string {
            throw new Error("not yet implemented");
        }
        private static SystemSupportsTaiwaneseCalendar(): boolean {
            throw new Error("not yet implemented");
        }
        private IcuLoadCalendarDataFromSystem(localeName: string, calendarId: CalendarId): boolean {
            throw new Error("not yet implemented");
        }
        private static IcuGetCalendars(localeName: string, calendars: CalendarId[]): number {
            throw new Error("not yet implemented");
        }
        private static GetCalendarInfo(localeName: string, calendarId: CalendarId, dataType: CalendarDataType, out calendarString: string): boolean {
            throw new Error("not yet implemented");
        }
        private static EnumDatePatterns(localeName: string, calendarId: CalendarId, dataType: CalendarDataType, out datePatterns: string[]): boolean {
            throw new Error("not yet implemented");
        }
        private static FixDefaultShortDatePattern(shortDatePatterns: List<string>) {
            throw new Error("not yet implemented");
        }
        private static NormalizeDatePattern(input: string): string {
            throw new Error("not yet implemented");
        }
        private static NormalizeDayOfWeek(input: string, ref destination: ValueStringBuilder, ref index: number) {
            throw new Error("not yet implemented");
        }
        private static CountOccurrences(input: string, value: string, ref index: number): number {
            throw new Error("not yet implemented");
        }
        private static EnumMonthNames(localeName: string, calendarId: CalendarId, dataType: CalendarDataType, out monthNames: string[], ref leapHebrewMonthName: string): boolean {
            throw new Error("not yet implemented");
        }
        private static EnumEraNames(localeName: string, calendarId: CalendarId, dataType: CalendarDataType, out eraNames: string[]): boolean {
            throw new Error("not yet implemented");
        }
        private static EnumCalendarInfo(localeName: string, calendarId: CalendarId, dataType: CalendarDataType, out calendarData: string[]): boolean {
            throw new Error("not yet implemented");
        }
        private static EnumCalendarInfo(localeName: string, calendarId: CalendarId, dataType: CalendarDataType, ref callbackContext: IcuEnumCalendarsData): boolean {
            throw new Error("not yet implemented");
        }
        private static EnumCalendarInfoCallback(calendarStringPtr: string*, context: number) {
            throw new Error("not yet implemented");
        }
        private static NlsSystemSupportsTaiwaneseCalendar(): boolean {
            throw new Error("not yet implemented");
        }
        private static CallGetCalendarInfoEx(localeName: string, calendar: CalendarId, calType: number, out data: number): boolean {
            throw new Error("not yet implemented");
        }
        private static CallGetCalendarInfoEx(localeName: string, calendar: CalendarId, calType: number, out data: string): boolean {
            throw new Error("not yet implemented");
        }
        private static EnumCalendarInfoCallback(lpCalendarInfoString: string*, calendar: number, pReserved: number, lParam: void*): BOOL {
            throw new Error("not yet implemented");
        }
        private static EnumCalendarsCallback(lpCalendarInfoString: string*, calendar: number, reserved: number, lParam: void*): BOOL {
            throw new Error("not yet implemented");
        }
        private LoadCalendarDataFromSystemCore(localeName: string, calendarId: CalendarId): boolean {
            throw new Error("not yet implemented");
        }
        private static InsertOrSwapOverride(value: string, ref destination: string[]) {
            throw new Error("not yet implemented");
        }
        private NlsLoadCalendarDataFromSystem(localeName: string, calendarId: CalendarId): boolean {
            throw new Error("not yet implemented");
        }
        private static NormalizeCalendarId(ref calendarId: CalendarId, ref localeName: string) {
            throw new Error("not yet implemented");
        }
        private static CheckSpecialCalendar(ref calendar: CalendarId, ref localeName: string) {
            throw new Error("not yet implemented");
        }
        private static CallEnumCalendarInfo(localeName: string, calendar: CalendarId, calType: number, lcType: number, out data: string[]): boolean {
            throw new Error("not yet implemented");
        }
        private static GetCalendarDayInfo(localeName: string, calendar: CalendarId, calType: number, out outputStrings: string[]): boolean {
            throw new Error("not yet implemented");
        }
        private static GetCalendarMonthInfo(localeName: string, calendar: CalendarId, calType: number, out outputStrings: string[]): boolean {
            throw new Error("not yet implemented");
        }
        private static GetCalendarsCore(localeName: string, useUserOverride: boolean, calendars: CalendarId[]): number {
            throw new Error("not yet implemented");
        }
        private static NlsGetCalendars(localeName: string, useUserOverride: boolean, calendars: CalendarId[]): number {
            throw new Error("not yet implemented");
        }
        private static GetTwoDigitYearMax(calendarId: CalendarId): number {
            throw new Error("not yet implemented");
        }
        private __InitializeEraNames__g__AreEraNamesEmpty_24_0(): boolean {
            throw new Error("not yet implemented");
        }
    }
    export namespace CalendarData {
        export class IcuEnumCalendarsData extends ValueType {
            public Results: List<string>;
            public DisallowDuplicates: boolean;

        }

        export class EnumData extends ValueType {
            public userOverride: string;
            public strings: List<string>;

        }

        export class NlsEnumCalendarsData extends ValueType {
            public userOverride: number;
            public calendars: List<number>;

        }

        export class ____c {
            public static readonly ____9: ____c;
            public static ____9__32_0: SpanFunc<string, string, CalendarId, CalendarDataType, ResultCode>;

            private static staticctor_initialize = (() => {
                throw new Error("not yet implemented");
            })();
            private constructor() { }
            public constructor() {
                throw new Error("not yet implemented");
            }

            private __GetCalendarInfo__b__32_0(buffer: Span<string>, locale: string, id: CalendarId, type: CalendarDataType): ResultCode {
                throw new Error("not yet implemented");
            }
        }
    }
    export enum CultureTypes {
        NeutralCultures = 0x1,
        SpecificCultures = 0x2,
        InstalledWin32Cultures = 0x4,
        AllCultures = 0x7,
        UserCustomCulture = 0x8,
        ReplacementCultures = 0x10,
        WindowsOnlyCultures = 0x20,
        FrameworkCultures = 0x40,
    }
    export enum DigitShapes {
        Context = 0,
        None = 1,
        NativeNational = 2,
    }
    export enum NumberStyles {
        None = 0x0,
        AllowLeadingWhite = 0x1,
        AllowTrailingWhite = 0x2,
        AllowLeadingSign = 0x4,
        Integer = 0x7,
        AllowTrailingSign = 0x8,
        AllowParentheses = 0x10,
        AllowDecimalPoint = 0x20,
        AllowThousands = 0x40,
        Number = 0x6f,
        AllowExponent = 0x80,
        Float = 0xa7,
        AllowCurrencySymbol = 0x100,
        Currency = 0x17f,
        Any = 0x1ff,
        AllowHexSpecifier = 0x200,
        HexNumber = 0x203,
        AllowBinarySpecifier = 0x400,
        BinaryNumber = 0x403,
    }
    export class NumberFormatInfo implements IFormatProvider, ICloneable {
        private static s_invariantInfo: NumberFormatInfo;
        private static readonly s_asciiDigits: string[];

        public static get InvariantInfo(): NumberFormatInfo {
            throw new Error("not yet implemented");
        }
        public static get CurrentInfo(): NumberFormatInfo {
            throw new Error("not yet implemented");
        }

        private _numberGroupSizes: number[];
        private _currencyGroupSizes: number[];
        private _percentGroupSizes: number[];
        private _positiveSign: string;
        private _negativeSign: string;
        private _numberDecimalSeparator: string;
        private _numberGroupSeparator: string;
        private _currencyGroupSeparator: string;
        private _currencyDecimalSeparator: string;
        private _currencySymbol: string;
        private _nanSymbol: string;
        private _positiveInfinitySymbol: string;
        private _negativeInfinitySymbol: string;
        private _percentDecimalSeparator: string;
        private _percentGroupSeparator: string;
        private _percentSymbol: string;
        private _perMilleSymbol: string;
        private _positiveSignUtf8: number[];
        private _negativeSignUtf8: number[];
        private _currencySymbolUtf8: number[];
        private _numberDecimalSeparatorUtf8: number[];
        private _currencyDecimalSeparatorUtf8: number[];
        private _currencyGroupSeparatorUtf8: number[];
        private _numberGroupSeparatorUtf8: number[];
        private _percentSymbolUtf8: number[];
        private _percentDecimalSeparatorUtf8: number[];
        private _percentGroupSeparatorUtf8: number[];
        private _perMilleSymbolUtf8: number[];
        private _nanSymbolUtf8: number[];
        private _positiveInfinitySymbolUtf8: number[];
        private _negativeInfinitySymbolUtf8: number[];
        private _nativeDigits: string[];
        private _numberDecimalDigits: number;
        private _currencyDecimalDigits: number;
        private _currencyPositivePattern: number;
        private _currencyNegativePattern: number;
        private _numberNegativePattern: number;
        private _percentPositivePattern: number;
        private _percentNegativePattern: number;
        private _percentDecimalDigits: number;
        private _digitSubstitution: number;
        private _isReadOnly: boolean;
        private _hasInvariantNumberSigns: boolean;
        private _allowHyphenDuringParsing: boolean;

        private get HasInvariantNumberSigns(): boolean {
            throw new Error("not yet implemented");
        }
        private get AllowHyphenDuringParsing(): boolean {
            throw new Error("not yet implemented");
        }
        public get CurrencyDecimalDigits(): number {
            throw new Error("not yet implemented");
        }
        public set CurrencyDecimalDigits(value: number) {
            throw new Error("not yet implemented");
        }
        public get CurrencyDecimalSeparator(): string {
            throw new Error("not yet implemented");
        }
        public set CurrencyDecimalSeparator(value: string) {
            throw new Error("not yet implemented");
        }
        public get IsReadOnly(): boolean {
            throw new Error("not yet implemented");
        }
        public get CurrencyGroupSizes(): number[] {
            throw new Error("not yet implemented");
        }
        public set CurrencyGroupSizes(value: number[]) {
            throw new Error("not yet implemented");
        }
        public get NumberGroupSizes(): number[] {
            throw new Error("not yet implemented");
        }
        public set NumberGroupSizes(value: number[]) {
            throw new Error("not yet implemented");
        }
        public get PercentGroupSizes(): number[] {
            throw new Error("not yet implemented");
        }
        public set PercentGroupSizes(value: number[]) {
            throw new Error("not yet implemented");
        }
        public get CurrencyGroupSeparator(): string {
            throw new Error("not yet implemented");
        }
        public set CurrencyGroupSeparator(value: string) {
            throw new Error("not yet implemented");
        }
        public get CurrencySymbol(): string {
            throw new Error("not yet implemented");
        }
        public set CurrencySymbol(value: string) {
            throw new Error("not yet implemented");
        }
        public get NaNSymbol(): string {
            throw new Error("not yet implemented");
        }
        public set NaNSymbol(value: string) {
            throw new Error("not yet implemented");
        }
        public get CurrencyNegativePattern(): number {
            throw new Error("not yet implemented");
        }
        public set CurrencyNegativePattern(value: number) {
            throw new Error("not yet implemented");
        }
        public get NumberNegativePattern(): number {
            throw new Error("not yet implemented");
        }
        public set NumberNegativePattern(value: number) {
            throw new Error("not yet implemented");
        }
        public get PercentPositivePattern(): number {
            throw new Error("not yet implemented");
        }
        public set PercentPositivePattern(value: number) {
            throw new Error("not yet implemented");
        }
        public get PercentNegativePattern(): number {
            throw new Error("not yet implemented");
        }
        public set PercentNegativePattern(value: number) {
            throw new Error("not yet implemented");
        }
        public get NegativeInfinitySymbol(): string {
            throw new Error("not yet implemented");
        }
        public set NegativeInfinitySymbol(value: string) {
            throw new Error("not yet implemented");
        }
        public get NegativeSign(): string {
            throw new Error("not yet implemented");
        }
        public set NegativeSign(value: string) {
            throw new Error("not yet implemented");
        }
        public get NumberDecimalDigits(): number {
            throw new Error("not yet implemented");
        }
        public set NumberDecimalDigits(value: number) {
            throw new Error("not yet implemented");
        }
        public get NumberDecimalSeparator(): string {
            throw new Error("not yet implemented");
        }
        public set NumberDecimalSeparator(value: string) {
            throw new Error("not yet implemented");
        }
        public get NumberGroupSeparator(): string {
            throw new Error("not yet implemented");
        }
        public set NumberGroupSeparator(value: string) {
            throw new Error("not yet implemented");
        }
        public get CurrencyPositivePattern(): number {
            throw new Error("not yet implemented");
        }
        public set CurrencyPositivePattern(value: number) {
            throw new Error("not yet implemented");
        }
        public get PositiveInfinitySymbol(): string {
            throw new Error("not yet implemented");
        }
        public set PositiveInfinitySymbol(value: string) {
            throw new Error("not yet implemented");
        }
        public get PositiveSign(): string {
            throw new Error("not yet implemented");
        }
        public set PositiveSign(value: string) {
            throw new Error("not yet implemented");
        }
        public get PercentDecimalDigits(): number {
            throw new Error("not yet implemented");
        }
        public set PercentDecimalDigits(value: number) {
            throw new Error("not yet implemented");
        }
        public get PercentDecimalSeparator(): string {
            throw new Error("not yet implemented");
        }
        public set PercentDecimalSeparator(value: string) {
            throw new Error("not yet implemented");
        }
        public get PercentGroupSeparator(): string {
            throw new Error("not yet implemented");
        }
        public set PercentGroupSeparator(value: string) {
            throw new Error("not yet implemented");
        }
        public get PercentSymbol(): string {
            throw new Error("not yet implemented");
        }
        public set PercentSymbol(value: string) {
            throw new Error("not yet implemented");
        }
        public get PerMilleSymbol(): string {
            throw new Error("not yet implemented");
        }
        public set PerMilleSymbol(value: string) {
            throw new Error("not yet implemented");
        }
        public get NativeDigits(): string[] {
            throw new Error("not yet implemented");
        }
        public set NativeDigits(value: string[]) {
            throw new Error("not yet implemented");
        }
        public get DigitSubstitution(): DigitShapes {
            throw new Error("not yet implemented");
        }
        public set DigitSubstitution(value: DigitShapes) {
            throw new Error("not yet implemented");
        }

        public constructor() {
            throw new Error("not yet implemented");
        }
        protected constructor(cultureData: CultureData) {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

        private static VerifyNativeDigits(nativeDig: string[], propertyName: string) {
            throw new Error("not yet implemented");
        }
        private static VerifyDigitSubstitution(digitSub: DigitShapes, propertyName: string) {
            throw new Error("not yet implemented");
        }
        private InitializeInvariantAndNegativeSignFlags() {
            throw new Error("not yet implemented");
        }
        private VerifyWritable() {
            throw new Error("not yet implemented");
        }
        public static GetInstance(formatProvider: IFormatProvider): NumberFormatInfo {
            throw new Error("not yet implemented");
        }
        public Clone(): any {
            throw new Error("not yet implemented");
        }
        private CurrencyDecimalSeparatorTChar(): ReadOnlySpan<TChar> {
            throw new Error("not yet implemented");
        }
        private static CheckGroupSize(propName: string, groupSize: number[]) {
            throw new Error("not yet implemented");
        }
        private CurrencyGroupSeparatorTChar(): ReadOnlySpan<TChar> {
            throw new Error("not yet implemented");
        }
        private CurrencySymbolTChar(): ReadOnlySpan<TChar> {
            throw new Error("not yet implemented");
        }
        private NaNSymbolTChar(): ReadOnlySpan<TChar> {
            throw new Error("not yet implemented");
        }
        private NegativeInfinitySymbolTChar(): ReadOnlySpan<TChar> {
            throw new Error("not yet implemented");
        }
        private NegativeSignTChar(): ReadOnlySpan<TChar> {
            throw new Error("not yet implemented");
        }
        private NumberDecimalSeparatorTChar(): ReadOnlySpan<TChar> {
            throw new Error("not yet implemented");
        }
        private NumberGroupSeparatorTChar(): ReadOnlySpan<TChar> {
            throw new Error("not yet implemented");
        }
        private PositiveInfinitySymbolTChar(): ReadOnlySpan<TChar> {
            throw new Error("not yet implemented");
        }
        private PositiveSignTChar(): ReadOnlySpan<TChar> {
            throw new Error("not yet implemented");
        }
        private PercentDecimalSeparatorTChar(): ReadOnlySpan<TChar> {
            throw new Error("not yet implemented");
        }
        private PercentGroupSeparatorTChar(): ReadOnlySpan<TChar> {
            throw new Error("not yet implemented");
        }
        private PercentSymbolTChar(): ReadOnlySpan<TChar> {
            throw new Error("not yet implemented");
        }
        private PerMilleSymbolTChar(): ReadOnlySpan<TChar> {
            throw new Error("not yet implemented");
        }
        public GetFormat(formatType: Type): any {
            throw new Error("not yet implemented");
        }
        public static ReadOnly(nfi: NumberFormatInfo): NumberFormatInfo {
            throw new Error("not yet implemented");
        }
        private static ValidateParseStyleInteger(style: NumberStyles) {
            throw new Error("not yet implemented");
        }
        private static ValidateParseStyleFloatingPoint(style: NumberStyles) {
            throw new Error("not yet implemented");
        }
        private static __GetInstance__g__GetProviderNonNull_58_0(provider: IFormatProvider): NumberFormatInfo {
            throw new Error("not yet implemented");
        }
        private static __ValidateParseStyleInteger__g__ThrowInvalid_165_0(value: NumberStyles) {
            throw new Error("not yet implemented");
        }
        private static __ValidateParseStyleFloatingPoint__g__ThrowInvalid_166_0(value: NumberStyles) {
            throw new Error("not yet implemented");
        }
    }
    export enum LocaleNumberData {
        LanguageId = 1,
        OemCodePage = 11,
        MeasurementSystem = 13,
        FractionalDigitsCount = 17,
        MonetaryFractionalDigitsCount = 25,
        PositiveMonetaryNumberFormat = 27,
        NegativeMonetaryNumberFormat = 28,
        GeoId = 91,
        ReadingLayout = 112,
        NegativePercentFormat = 116,
        PositivePercentFormat = 117,
        AnsiCodePage = 4100,
        CalendarType = 4105,
        FirstDayOfWeek = 4108,
        FirstWeekOfYear = 4109,
        NegativeNumberFormat = 4112,
        MacCodePage = 4113,
        EbcdicCodePage = 4114,
        DigitSubstitution = 4116,
    }
    export enum LocaleStringData {
        LocalizedDisplayName = 2,
        AbbreviatedWindowsLanguageName = 3,
        NativeLanguageName = 4,
        LocalizedCountryName = 6,
        NativeCountryName = 8,
        ListSeparator = 12,
        DecimalSeparator = 14,
        ThousandSeparator = 15,
        Digits = 19,
        MonetarySymbol = 20,
        Iso4217MonetarySymbol = 21,
        MonetaryDecimalSeparator = 22,
        MonetaryThousandSeparator = 23,
        AMDesignator = 40,
        PMDesignator = 41,
        PositiveSign = 80,
        NegativeSign = 81,
        Iso639LanguageTwoLetterName = 89,
        Iso639LanguageName = 89,
        Iso3166CountryName = 90,
        Iso639LanguageThreeLetterName = 103,
        Iso3166CountryName2 = 104,
        NaNSymbol = 105,
        PositiveInfinitySymbol = 106,
        NegativeInfinitySymbol = 107,
        ParentName = 109,
        ConsoleFallbackName = 110,
        LocalizedLanguageName = 111,
        EnglishDisplayName = 114,
        NativeDisplayName = 115,
        PercentSymbol = 118,
        PerMilleSymbol = 119,
        EnglishLanguageName = 4097,
        EnglishCountryName = 4098,
        CurrencyEnglishName = 4103,
        CurrencyNativeName = 4104,
    }
    export enum LocaleGroupingData {
        Digit = 16,
        Monetary = 24,
    }
    export class CultureData {
        private static s_cachedRegions: Dictionary<string, CultureData>;
        private static s_regionNames: Dictionary<string, string>;
        private static s_Invariant: CultureData;
        private static s_cachedCultures: Dictionary<string, CultureData>;
        private static readonly s_lock: any;

        private static get RegionNames(): Dictionary<string, string> {
            throw new Error("not yet implemented");
        }
        private static get Invariant(): CultureData {
            throw new Error("not yet implemented");
        }

        private _sRealName: string;
        private _sWindowsName: string;
        private _sName: string;
        private _sParent: string;
        private _sEnglishDisplayName: string;
        private _sNativeDisplayName: string;
        private _sSpecificCulture: string;
        private _sISO639Language: string;
        private _sISO639Language2: string;
        private _sEnglishLanguage: string;
        private _sNativeLanguage: string;
        private _sAbbrevLang: string;
        private _sConsoleFallbackName: string;
        private _iInputLanguageHandle: number;
        private _sRegionName: string;
        private _sLocalizedCountry: string;
        private _sEnglishCountry: string;
        private _sNativeCountry: string;
        private _sISO3166CountryName: string;
        private _sISO3166CountryName2: string;
        private _iGeoId: number;
        private _sPositiveSign: string;
        private _sNegativeSign: string;
        private _iDigits: number;
        private _iNegativeNumber: number;
        private _waGrouping: number[];
        private _sDecimalSeparator: string;
        private _sThousandSeparator: string;
        private _sNaN: string;
        private _sPositiveInfinity: string;
        private _sNegativeInfinity: string;
        private _iNegativePercent: number;
        private _iPositivePercent: number;
        private _sPercent: string;
        private _sPerMille: string;
        private _sCurrency: string;
        private _sIntlMonetarySymbol: string;
        private _sEnglishCurrency: string;
        private _sNativeCurrency: string;
        private _iCurrencyDigits: number;
        private _iCurrency: number;
        private _iNegativeCurrency: number;
        private _waMonetaryGrouping: number[];
        private _sMonetaryDecimal: string;
        private _sMonetaryThousand: string;
        private _iMeasure: number;
        private _sListSeparator: string;
        private _sAM1159: string;
        private _sPM2359: string;
        private _sTimeSeparator: string;
        private _saLongTimes: string[];
        private _saShortTimes: string[];
        private _saDurationFormats: string[];
        private _iFirstDayOfWeek: number;
        private _iFirstWeekOfYear: number;
        private _waCalendars: CalendarId[];
        private _calendars: CalendarData[];
        private _iReadingLayout: number;
        private _iDefaultAnsiCodePage: number;
        private _iDefaultOemCodePage: number;
        private _iDefaultMacCodePage: number;
        private _iDefaultEbcdicCodePage: number;
        private _iLanguage: number;
        private _bUseOverrides: boolean;
        private _bUseOverridesUserSetting: boolean;
        private _bNeutral: boolean;

        private get InteropName(): string {
            throw new Error("not yet implemented");
        }
        private get CultureName(): string {
            throw new Error("not yet implemented");
        }
        private get UseUserOverride(): boolean {
            throw new Error("not yet implemented");
        }
        private get Name(): string {
            throw new Error("not yet implemented");
        }
        private get ParentName(): string {
            throw new Error("not yet implemented");
        }
        private get DisplayName(): string {
            throw new Error("not yet implemented");
        }
        private get EnglishName(): string {
            throw new Error("not yet implemented");
        }
        private get NativeName(): string {
            throw new Error("not yet implemented");
        }
        private get SpecificCultureName(): string {
            throw new Error("not yet implemented");
        }
        private get TwoLetterISOLanguageName(): string {
            throw new Error("not yet implemented");
        }
        private get ThreeLetterISOLanguageName(): string {
            throw new Error("not yet implemented");
        }
        private get ThreeLetterWindowsLanguageName(): string {
            throw new Error("not yet implemented");
        }
        private get LocalizedLanguageName(): string {
            throw new Error("not yet implemented");
        }
        private get EnglishLanguageName(): string {
            throw new Error("not yet implemented");
        }
        private get NativeLanguageName(): string {
            throw new Error("not yet implemented");
        }
        private get RegionName(): string {
            throw new Error("not yet implemented");
        }
        private get GeoId(): number {
            throw new Error("not yet implemented");
        }
        private get LocalizedCountryName(): string {
            throw new Error("not yet implemented");
        }
        private get EnglishCountryName(): string {
            throw new Error("not yet implemented");
        }
        private get NativeCountryName(): string {
            throw new Error("not yet implemented");
        }
        private get TwoLetterISOCountryName(): string {
            throw new Error("not yet implemented");
        }
        private get ThreeLetterISOCountryName(): string {
            throw new Error("not yet implemented");
        }
        private get KeyboardLayoutId(): number {
            throw new Error("not yet implemented");
        }
        private get SCONSOLEFALLBACKNAME(): string {
            throw new Error("not yet implemented");
        }
        private get NumberGroupSizes(): number[] {
            throw new Error("not yet implemented");
        }
        private get NaNSymbol(): string {
            throw new Error("not yet implemented");
        }
        private get PositiveInfinitySymbol(): string {
            throw new Error("not yet implemented");
        }
        private get NegativeInfinitySymbol(): string {
            throw new Error("not yet implemented");
        }
        private get PercentNegativePattern(): number {
            throw new Error("not yet implemented");
        }
        private get PercentPositivePattern(): number {
            throw new Error("not yet implemented");
        }
        private get PercentSymbol(): string {
            throw new Error("not yet implemented");
        }
        private get PerMilleSymbol(): string {
            throw new Error("not yet implemented");
        }
        private get CurrencySymbol(): string {
            throw new Error("not yet implemented");
        }
        private get ISOCurrencySymbol(): string {
            throw new Error("not yet implemented");
        }
        private get CurrencyEnglishName(): string {
            throw new Error("not yet implemented");
        }
        private get CurrencyNativeName(): string {
            throw new Error("not yet implemented");
        }
        private get CurrencyGroupSizes(): number[] {
            throw new Error("not yet implemented");
        }
        private get MeasurementSystem(): number {
            throw new Error("not yet implemented");
        }
        private get ListSeparator(): string {
            throw new Error("not yet implemented");
        }
        private get AMDesignator(): string {
            throw new Error("not yet implemented");
        }
        private get PMDesignator(): string {
            throw new Error("not yet implemented");
        }
        private get LongTimes(): string[] {
            throw new Error("not yet implemented");
        }
        private get ShortTimes(): string[] {
            throw new Error("not yet implemented");
        }
        private get FirstDayOfWeek(): number {
            throw new Error("not yet implemented");
        }
        private get CalendarWeekRule(): number {
            throw new Error("not yet implemented");
        }
        private get CalendarIds(): CalendarId[] {
            throw new Error("not yet implemented");
        }
        private get IsRightToLeft(): boolean {
            throw new Error("not yet implemented");
        }
        private get ReadingLayout(): number {
            throw new Error("not yet implemented");
        }
        private get TextInfoName(): string {
            throw new Error("not yet implemented");
        }
        private get SortName(): string {
            throw new Error("not yet implemented");
        }
        private get IsSupplementalCustomCulture(): boolean {
            throw new Error("not yet implemented");
        }
        private get ANSICodePage(): number {
            throw new Error("not yet implemented");
        }
        private get OEMCodePage(): number {
            throw new Error("not yet implemented");
        }
        private get MacCodePage(): number {
            throw new Error("not yet implemented");
        }
        private get EBCDICCodePage(): number {
            throw new Error("not yet implemented");
        }
        private get LCID(): number {
            throw new Error("not yet implemented");
        }
        private get IsNeutralCulture(): boolean {
            throw new Error("not yet implemented");
        }
        private get IsInvariantCulture(): boolean {
            throw new Error("not yet implemented");
        }
        private get IsReplacementCulture(): boolean {
            throw new Error("not yet implemented");
        }
        private get DefaultCalendar(): Calendar {
            throw new Error("not yet implemented");
        }
        private get TimeSeparator(): string {
            throw new Error("not yet implemented");
        }
        private get NlsIsReplacementCulture(): boolean {
            throw new Error("not yet implemented");
        }
        private get ShouldUseUserOverrideNlsData(): boolean {
            throw new Error("not yet implemented");
        }

        public constructor() {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

        private static GetCultureDataForRegion(cultureName: string, useUserOverride: boolean): CultureData {
            throw new Error("not yet implemented");
        }
        private static ClearCachedData() {
            throw new Error("not yet implemented");
        }
        private static GetCultures(types: CultureTypes): CultureInfo[] {
            throw new Error("not yet implemented");
        }
        private static CreateCultureWithInvariantData(): CultureData {
            throw new Error("not yet implemented");
        }
        private static GetCultureData(cultureName: string, useUserOverride: boolean): CultureData {
            throw new Error("not yet implemented");
        }
        private static NormalizeCultureName(name: string, out isNeutralName: boolean): string {
            throw new Error("not yet implemented");
        }
        private static CreateCultureData(cultureName: string, useUserOverride: boolean): CultureData {
            throw new Error("not yet implemented");
        }
        private InitCompatibilityCultureData(): boolean {
            throw new Error("not yet implemented");
        }
        private static GetCultureData(culture: number, bUseUserOverride: boolean): CultureData {
            throw new Error("not yet implemented");
        }
        private GetLanguageDisplayNameCore(cultureName: string): string {
            throw new Error("not yet implemented");
        }
        private DeriveShortTimesFromLong(): string[] {
            throw new Error("not yet implemented");
        }
        private static StripSecondsFromPattern(time: string): string {
            throw new Error("not yet implemented");
        }
        private static GetIndexOfNextTokenAfterSeconds(time: string, index: number, out containsSpace: boolean): number {
            throw new Error("not yet implemented");
        }
        private ShortDates(calendarId: CalendarId): string[] {
            throw new Error("not yet implemented");
        }
        private LongDates(calendarId: CalendarId): string[] {
            throw new Error("not yet implemented");
        }
        private YearMonths(calendarId: CalendarId): string[] {
            throw new Error("not yet implemented");
        }
        private DayNames(calendarId: CalendarId): string[] {
            throw new Error("not yet implemented");
        }
        private AbbreviatedDayNames(calendarId: CalendarId): string[] {
            throw new Error("not yet implemented");
        }
        private SuperShortDayNames(calendarId: CalendarId): string[] {
            throw new Error("not yet implemented");
        }
        private MonthNames(calendarId: CalendarId): string[] {
            throw new Error("not yet implemented");
        }
        private GenitiveMonthNames(calendarId: CalendarId): string[] {
            throw new Error("not yet implemented");
        }
        private AbbreviatedMonthNames(calendarId: CalendarId): string[] {
            throw new Error("not yet implemented");
        }
        private AbbreviatedGenitiveMonthNames(calendarId: CalendarId): string[] {
            throw new Error("not yet implemented");
        }
        private LeapYearMonthNames(calendarId: CalendarId): string[] {
            throw new Error("not yet implemented");
        }
        private MonthDay(calendarId: CalendarId): string {
            throw new Error("not yet implemented");
        }
        private CalendarName(calendarId: CalendarId): string {
            throw new Error("not yet implemented");
        }
        private GetCalendar(calendarId: CalendarId): CalendarData {
            throw new Error("not yet implemented");
        }
        private EraNames(calendarId: CalendarId): string[] {
            throw new Error("not yet implemented");
        }
        private AbbrevEraNames(calendarId: CalendarId): string[] {
            throw new Error("not yet implemented");
        }
        private AbbreviatedEnglishEraNames(calendarId: CalendarId): string[] {
            throw new Error("not yet implemented");
        }
        private DateSeparator(calendarId: CalendarId): string {
            throw new Error("not yet implemented");
        }
        private static UnescapeNlsString(str: string, start: number, end: number): string {
            throw new Error("not yet implemented");
        }
        private static GetTimeSeparator(format: string): string {
            throw new Error("not yet implemented");
        }
        private static GetDateSeparator(format: string): string {
            throw new Error("not yet implemented");
        }
        private static GetSeparator(format: string, timeParts: string): string {
            throw new Error("not yet implemented");
        }
        private static IndexOfTimePart(format: string, startIndex: number, timeParts: string): number {
            throw new Error("not yet implemented");
        }
        private static IsCustomCultureId(cultureId: number): boolean {
            throw new Error("not yet implemented");
        }
        private GetNativeDigits(): string[] {
            throw new Error("not yet implemented");
        }
        private GetNFIValues(nfi: NumberFormatInfo) {
            throw new Error("not yet implemented");
        }
        private static AnsiToLower(testString: string): string {
            throw new Error("not yet implemented");
        }
        private GetLocaleInfoCore(type: LocaleNumberData): number {
            throw new Error("not yet implemented");
        }
        private GetLocaleInfoCoreUserOverride(type: LocaleNumberData): number {
            throw new Error("not yet implemented");
        }
        private GetLocaleInfoCoreUserOverride(type: LocaleStringData): string {
            throw new Error("not yet implemented");
        }
        private GetLocaleInfoCore(type: LocaleStringData, uiCultureName: string): string {
            throw new Error("not yet implemented");
        }
        private GetLocaleInfoCore(localeName: string, type: LocaleStringData, uiCultureName: string): string {
            throw new Error("not yet implemented");
        }
        private GetLocaleInfoCoreUserOverride(type: LocaleGroupingData): number[] {
            throw new Error("not yet implemented");
        }
        private static NormalizeCultureName(name: string, extension: ReadOnlySpan<string>, out collationStart: number): string {
            throw new Error("not yet implemented");
        }
        private InitIcuCultureDataCore(): boolean {
            throw new Error("not yet implemented");
        }
        private static GetLocaleName(localeName: string, out windowsName: string): boolean {
            throw new Error("not yet implemented");
        }
        private IcuGetLocaleInfo(type: LocaleStringData, uiCultureName: string): string {
            throw new Error("not yet implemented");
        }
        private IcuGetLocaleInfo(localeName: string, type: LocaleStringData, uiCultureName: string): string {
            throw new Error("not yet implemented");
        }
        private IcuGetLocaleInfo(type: LocaleNumberData): number {
            throw new Error("not yet implemented");
        }
        private IcuGetLocaleInfo(type: LocaleGroupingData): number[] {
            throw new Error("not yet implemented");
        }
        private IcuGetTimeFormatString(): string {
            throw new Error("not yet implemented");
        }
        private IcuGetTimeFormatString(shortFormat: boolean): string {
            throw new Error("not yet implemented");
        }
        private IcuGetLanguageDisplayName(cultureName: string): string {
            throw new Error("not yet implemented");
        }
        private static IcuIsEnsurePredefinedLocaleName(name: string): boolean {
            throw new Error("not yet implemented");
        }
        private static ConvertIcuTimeFormatString(icuFormatString: ReadOnlySpan<string>): string {
            throw new Error("not yet implemented");
        }
        private static IcuLocaleNameToLCID(cultureName: string): number {
            throw new Error("not yet implemented");
        }
        private static IcuGetGeoId(cultureName: string): number {
            throw new Error("not yet implemented");
        }
        private static IcuGetDigitSubstitution(cultureName: string): number {
            throw new Error("not yet implemented");
        }
        private static IcuGetListSeparator(cultureName: string): string {
            throw new Error("not yet implemented");
        }
        private static IcuGetThreeLetterWindowsLanguageName(cultureName: string): string {
            throw new Error("not yet implemented");
        }
        private static IcuEnumCultures(types: CultureTypes): CultureInfo[] {
            throw new Error("not yet implemented");
        }
        private static IcuGetConsoleFallbackName(cultureName: string): string {
            throw new Error("not yet implemented");
        }
        private static IsValidCultureName(subject: string, out indexOfUnderscore: number, out indexOfExtensions: number): boolean {
            throw new Error("not yet implemented");
        }
        private static GetLocaleInfoEx(localeName: string, field: number): string {
            throw new Error("not yet implemented");
        }
        private static GetLocaleInfoExInt(localeName: string, field: number): number {
            throw new Error("not yet implemented");
        }
        private static GetLocaleInfoEx(lpLocaleName: string, lcType: number, lpLCData: string*, cchData: number): number {
            throw new Error("not yet implemented");
        }
        private NlsGetLocaleInfo(type: LocaleStringData): string {
            throw new Error("not yet implemented");
        }
        private NlsGetLocaleInfo(localeName: string, type: LocaleStringData): string {
            throw new Error("not yet implemented");
        }
        private NlsGetLocaleInfo(type: LocaleNumberData): number {
            throw new Error("not yet implemented");
        }
        private NlsGetLocaleInfo(type: LocaleGroupingData): number[] {
            throw new Error("not yet implemented");
        }
        private static NlsIsEnsurePredefinedLocaleName(name: string): boolean {
            throw new Error("not yet implemented");
        }
        private NlsGetTimeFormatString(): string {
            throw new Error("not yet implemented");
        }
        private NlsGetFirstDayOfWeek(): number {
            throw new Error("not yet implemented");
        }
        private static NlsGetCultureDataFromRegionName(regionName: string): CultureData {
            throw new Error("not yet implemented");
        }
        private NlsGetLanguageDisplayName(cultureName: string): string {
            throw new Error("not yet implemented");
        }
        private NlsGetRegionDisplayName(): string {
            throw new Error("not yet implemented");
        }
        private static GetLocaleInfoFromLCType(localeName: string, lctype: number, useUserOverride: boolean): string {
            throw new Error("not yet implemented");
        }
        private static ReescapeWin32String(str: string): string {
            throw new Error("not yet implemented");
        }
        private static ReescapeWin32Strings(array: string[]): string[] {
            throw new Error("not yet implemented");
        }
        private static ConvertWin32GroupString(win32Str: string): number[] {
            throw new Error("not yet implemented");
        }
        private static ConvertFirstDayOfWeekMonToSun(iTemp: number): number {
            throw new Error("not yet implemented");
        }
        private static EnumSystemLocalesProc(lpLocaleString: string*, flags: number, contextHandle: void*): BOOL {
            throw new Error("not yet implemented");
        }
        private static EnumAllSystemLocalesProc(lpLocaleString: string*, flags: number, contextHandle: void*): BOOL {
            throw new Error("not yet implemented");
        }
        private static EnumTimeCallback(lpTimeFormatString: string*, lParam: void*): BOOL {
            throw new Error("not yet implemented");
        }
        private static nativeEnumTimeFormats(localeName: string, dwFlags: number, useUserOverride: boolean): string[] {
            throw new Error("not yet implemented");
        }
        private static NlsLocaleNameToLCID(cultureName: string): number {
            throw new Error("not yet implemented");
        }
        private NlsGetThreeLetterWindowsLanguageName(cultureName: string): string {
            throw new Error("not yet implemented");
        }
        private static NlsEnumCultures(types: CultureTypes): CultureInfo[] {
            throw new Error("not yet implemented");
        }
        private NlsGetConsoleFallbackName(cultureName: string): string {
            throw new Error("not yet implemented");
        }
        private InitCultureDataCore(): boolean {
            throw new Error("not yet implemented");
        }
        private InitUserOverride(useUserOverride: boolean) {
            throw new Error("not yet implemented");
        }
        private static GetCurrentRegionData(): CultureData {
            throw new Error("not yet implemented");
        }
        private static LCIDToLocaleName(culture: number): string {
            throw new Error("not yet implemented");
        }
        private GetTimeFormatsCore(shortFormat: boolean): string[] {
            throw new Error("not yet implemented");
        }
        private GetAnsiCodePage(_: string): number {
            throw new Error("not yet implemented");
        }
        private GetOemCodePage(_: string): number {
            throw new Error("not yet implemented");
        }
        private GetMacCodePage(_: string): number {
            throw new Error("not yet implemented");
        }
        private GetEbcdicCodePage(_: string): number {
            throw new Error("not yet implemented");
        }
    }
    export namespace CultureData {
        export enum LocaleStringData {
            LocalizedDisplayName = 2,
            AbbreviatedWindowsLanguageName = 3,
            NativeLanguageName = 4,
            LocalizedCountryName = 6,
            NativeCountryName = 8,
            ListSeparator = 12,
            DecimalSeparator = 14,
            ThousandSeparator = 15,
            Digits = 19,
            MonetarySymbol = 20,
            Iso4217MonetarySymbol = 21,
            MonetaryDecimalSeparator = 22,
            MonetaryThousandSeparator = 23,
            AMDesignator = 40,
            PMDesignator = 41,
            PositiveSign = 80,
            NegativeSign = 81,
            Iso639LanguageTwoLetterName = 89,
            Iso639LanguageName = 89,
            Iso3166CountryName = 90,
            Iso639LanguageThreeLetterName = 103,
            Iso3166CountryName2 = 104,
            NaNSymbol = 105,
            PositiveInfinitySymbol = 106,
            NegativeInfinitySymbol = 107,
            ParentName = 109,
            ConsoleFallbackName = 110,
            LocalizedLanguageName = 111,
            EnglishDisplayName = 114,
            NativeDisplayName = 115,
            PercentSymbol = 118,
            PerMilleSymbol = 119,
            EnglishLanguageName = 4097,
            EnglishCountryName = 4098,
            CurrencyEnglishName = 4103,
            CurrencyNativeName = 4104,
        }

        export enum LocaleGroupingData {
            Digit = 16,
            Monetary = 24,
        }

        export enum LocaleNumberData {
            LanguageId = 1,
            OemCodePage = 11,
            MeasurementSystem = 13,
            FractionalDigitsCount = 17,
            MonetaryFractionalDigitsCount = 25,
            PositiveMonetaryNumberFormat = 27,
            NegativeMonetaryNumberFormat = 28,
            GeoId = 91,
            ReadingLayout = 112,
            NegativePercentFormat = 116,
            PositivePercentFormat = 117,
            AnsiCodePage = 4100,
            CalendarType = 4105,
            FirstDayOfWeek = 4108,
            FirstWeekOfYear = 4109,
            NegativeNumberFormat = 4112,
            MacCodePage = 4113,
            EbcdicCodePage = 4114,
            DigitSubstitution = 4116,
        }

        export class EnumLocaleData extends ValueType {
            public regionName: string;
            public cultureName: string;

        }

        export class EnumData extends ValueType {
            public strings: List<string>;

        }
    }
    export enum Tristate {
        NotInitialized = 0,
        False = 1,
        True = 2,
    }
    export enum UnicodeCategory {
        UppercaseLetter = 0,
        LowercaseLetter = 1,
        TitlecaseLetter = 2,
        ModifierLetter = 3,
        OtherLetter = 4,
        NonSpacingMark = 5,
        SpacingCombiningMark = 6,
        EnclosingMark = 7,
        DecimalDigitNumber = 8,
        LetterNumber = 9,
        OtherNumber = 10,
        SpaceSeparator = 11,
        LineSeparator = 12,
        ParagraphSeparator = 13,
        Control = 14,
        Format = 15,
        Surrogate = 16,
        PrivateUse = 17,
        ConnectorPunctuation = 18,
        DashPunctuation = 19,
        OpenPunctuation = 20,
        ClosePunctuation = 21,
        InitialQuotePunctuation = 22,
        FinalQuotePunctuation = 23,
        OtherPunctuation = 24,
        MathSymbol = 25,
        CurrencySymbol = 26,
        ModifierSymbol = 27,
        OtherSymbol = 28,
        OtherNotAssigned = 29,
    }
    export class TextInfo implements ICloneable, IDeserializationCallback {
        private static readonly Invariant: TextInfo;

        private _listSeparator: string;
        private _isReadOnly: boolean;
        private _cultureName: string;
        private _cultureData: CultureData;
        private _textInfoName: string;
        private _isAsciiCasingSameAsInvariant: Tristate;
        private _needsTurkishCasing: Tristate;
        private _sortHandle: number;

        private get HasEmptyCultureName(): boolean {
            throw new Error("not yet implemented");
        }
        public get ANSICodePage(): number {
            throw new Error("not yet implemented");
        }
        public get OEMCodePage(): number {
            throw new Error("not yet implemented");
        }
        public get MacCodePage(): number {
            throw new Error("not yet implemented");
        }
        public get EBCDICCodePage(): number {
            throw new Error("not yet implemented");
        }
        public get LCID(): number {
            throw new Error("not yet implemented");
        }
        public get CultureName(): string {
            throw new Error("not yet implemented");
        }
        public get IsReadOnly(): boolean {
            throw new Error("not yet implemented");
        }
        public get ListSeparator(): string {
            throw new Error("not yet implemented");
        }
        public set ListSeparator(value: string) {
            throw new Error("not yet implemented");
        }
        private get IsAsciiCasingSameAsInvariant(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsRightToLeft(): boolean {
            throw new Error("not yet implemented");
        }

        protected constructor(cultureData: CultureData) {
            throw new Error("not yet implemented");
        }
        private constructor(cultureData: CultureData, readOnly: boolean) {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

        private __explicit__IDeserializationCallback_OnDeserialization(sender: any) {
            throw new Error("not yet implemented");
        }
        public OnDeserialization(sender: any) {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        public Clone(): any {
            throw new Error("not yet implemented");
        }
        public static ReadOnly(textInfo: TextInfo): TextInfo {
            throw new Error("not yet implemented");
        }
        private VerifyWritable() {
            throw new Error("not yet implemented");
        }
        private SetReadOnlyState(readOnly: boolean) {
            throw new Error("not yet implemented");
        }
        public ToLower(c: string): string {
            throw new Error("not yet implemented");
        }
        private static ToLowerInvariant(c: string): string {
            throw new Error("not yet implemented");
        }
        public ToLower(str: string): string {
            throw new Error("not yet implemented");
        }
        private ChangeCase(c: string, toUpper: boolean): string {
            throw new Error("not yet implemented");
        }
        private ChangeCaseToLower(source: ReadOnlySpan<string>, destination: Span<string>) {
            throw new Error("not yet implemented");
        }
        private ChangeCaseToUpper(source: ReadOnlySpan<string>, destination: Span<string>) {
            throw new Error("not yet implemented");
        }
        private ChangeCaseCommon(source: ReadOnlySpan<string>, destination: Span<string>) {
            throw new Error("not yet implemented");
        }
        private ChangeCaseCommon(source: string): string {
            throw new Error("not yet implemented");
        }
        private static ToLowerAsciiInvariant(s: string): string {
            throw new Error("not yet implemented");
        }
        private static ToLowerAsciiInvariant(c: string): string {
            throw new Error("not yet implemented");
        }
        public ToUpper(c: string): string {
            throw new Error("not yet implemented");
        }
        private static ToUpperInvariant(c: string): string {
            throw new Error("not yet implemented");
        }
        public ToUpper(str: string): string {
            throw new Error("not yet implemented");
        }
        private static ToUpperAsciiInvariant(c: string): string {
            throw new Error("not yet implemented");
        }
        private PopulateIsAsciiCasingSameAsInvariant() {
            throw new Error("not yet implemented");
        }
        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
        public ToTitleCase(str: string): string {
            throw new Error("not yet implemented");
        }
        private static AddNonLetter(ref result: StringBuilder, ref input: string, inputIndex: number, charLen: number): number {
            throw new Error("not yet implemented");
        }
        private AddTitlecaseLetter(ref result: StringBuilder, ref input: string, inputIndex: number, charLen: number): number {
            throw new Error("not yet implemented");
        }
        private ChangeCaseCore(src: string*, srcLen: number, dstBuffer: string*, dstBufferCapacity: number, bToUpper: boolean) {
            throw new Error("not yet implemented");
        }
        private static IsWordSeparator(category: UnicodeCategory): boolean {
            throw new Error("not yet implemented");
        }
        private static IsLetterCategory(uc: UnicodeCategory): boolean {
            throw new Error("not yet implemented");
        }
        private static NeedsTurkishCasing(localeName: string): boolean {
            throw new Error("not yet implemented");
        }
        private IcuChangeCase(src: string*, srcLen: number, dstBuffer: string*, dstBufferCapacity: number, bToUpper: boolean) {
            throw new Error("not yet implemented");
        }
        private NlsChangeCase(pSource: string*, pSourceLen: number, pResult: string*, pResultLen: number, toUpper: boolean) {
            throw new Error("not yet implemented");
        }
        private static IsInvariantLocale(localeName: string): boolean {
            throw new Error("not yet implemented");
        }
    }
    export namespace TextInfo {
        export enum Tristate {
            NotInitialized = 0,
            False = 1,
            True = 2,
        }

        export class ToUpperConversion extends ValueType {
        }

        export class ToLowerConversion extends ValueType {
        }
    }
    export enum CompareOptions {
        None = 0x0,
        IgnoreCase = 0x1,
        IgnoreNonSpace = 0x2,
        IgnoreSymbols = 0x4,
        IgnoreKanaType = 0x8,
        IgnoreWidth = 0x10,
        OrdinalIgnoreCase = 0x10000000,
        StringSort = 0x20000000,
        Ordinal = 0x40000000,
    }
    export class SortKey {
        private _compareInfo: CompareInfo;
        private _options: CompareOptions;
        private _string: string;
        private _keyData: number[];

        public get OriginalString(): string {
            throw new Error("not yet implemented");
        }
        public get KeyData(): number[] {
            throw new Error("not yet implemented");
        }

        protected constructor(compareInfo: CompareInfo, str: string, options: CompareOptions, keyData: number[]) {
            throw new Error("not yet implemented");
        }

        public static Compare(sortkey1: SortKey, sortkey2: SortKey): number {
            throw new Error("not yet implemented");
        }
        public Equals(value: any): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
    }
    export class CompareInfo implements IDeserializationCallback {
        private static readonly Invariant: CompareInfo;
        private static readonly s_nonSpecialAsciiChars: SearchValues<string>;

        private static get HighCharTable(): ReadOnlySpan<boolean> {
            throw new Error("not yet implemented");
        }

        private m_name: string;
        private _sortHandle: number;
        private _sortName: string;
        private m_SortVersion: SortVersion;
        private culture: number;
        private _isAsciiEqualityOrdinal: boolean;

        public get Name(): string {
            throw new Error("not yet implemented");
        }
        public get Version(): SortVersion {
            throw new Error("not yet implemented");
        }
        public get LCID(): number {
            throw new Error("not yet implemented");
        }

        protected constructor(culture: CultureInfo) {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

        public static GetCompareInfo(culture: number, assembly: Assembly): CompareInfo {
            throw new Error("not yet implemented");
        }
        public static GetCompareInfo(name: string, assembly: Assembly): CompareInfo {
            throw new Error("not yet implemented");
        }
        public static GetCompareInfo(culture: number): CompareInfo {
            throw new Error("not yet implemented");
        }
        public static GetCompareInfo(name: string): CompareInfo {
            throw new Error("not yet implemented");
        }
        public static IsSortable(ch: string): boolean {
            throw new Error("not yet implemented");
        }
        public static IsSortable(text: string): boolean {
            throw new Error("not yet implemented");
        }
        public static IsSortable(text: ReadOnlySpan<string>): boolean {
            throw new Error("not yet implemented");
        }
        public static IsSortable(value: Rune): boolean {
            throw new Error("not yet implemented");
        }
        private InitSort(culture: CultureInfo) {
            throw new Error("not yet implemented");
        }
        private OnDeserializing(ctx: StreamingContext) {
            throw new Error("not yet implemented");
        }
        private __explicit__IDeserializationCallback_OnDeserialization(sender: any) {
            throw new Error("not yet implemented");
        }
        public OnDeserialization(sender: any) {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private OnDeserialized(ctx: StreamingContext) {
            throw new Error("not yet implemented");
        }
        private OnDeserialized() {
            throw new Error("not yet implemented");
        }
        private OnSerializing(ctx: StreamingContext) {
            throw new Error("not yet implemented");
        }
        public Compare(string1: string, string2: string): number {
            throw new Error("not yet implemented");
        }
        public Compare(string1: string, string2: string, options: CompareOptions): number {
            throw new Error("not yet implemented");
        }
        private CompareOptionIgnoreCase(string1: ReadOnlySpan<string>, string2: ReadOnlySpan<string>): number {
            throw new Error("not yet implemented");
        }
        public Compare(string1: string, offset1: number, length1: number, string2: string, offset2: number, length2: number): number {
            throw new Error("not yet implemented");
        }
        public Compare(string1: string, offset1: number, string2: string, offset2: number, options: CompareOptions): number {
            throw new Error("not yet implemented");
        }
        public Compare(string1: string, offset1: number, string2: string, offset2: number): number {
            throw new Error("not yet implemented");
        }
        public Compare(string1: string, offset1: number, length1: number, string2: string, offset2: number, length2: number, options: CompareOptions): number {
            throw new Error("not yet implemented");
        }
        public Compare(string1: ReadOnlySpan<string>, string2: ReadOnlySpan<string>, options: CompareOptions): number {
            throw new Error("not yet implemented");
        }
        private static CheckCompareOptionsForCompare(options: CompareOptions) {
            throw new Error("not yet implemented");
        }
        private static ThrowCompareOptionsCheckFailed(options: CompareOptions) {
            throw new Error("not yet implemented");
        }
        private CompareStringCore(string1: ReadOnlySpan<string>, string2: ReadOnlySpan<string>, options: CompareOptions): number {
            throw new Error("not yet implemented");
        }
        public IsPrefix(source: string, prefix: string, options: CompareOptions): boolean {
            throw new Error("not yet implemented");
        }
        public IsPrefix(source: ReadOnlySpan<string>, prefix: ReadOnlySpan<string>, options: CompareOptions): boolean {
            throw new Error("not yet implemented");
        }
        public IsPrefix(source: ReadOnlySpan<string>, prefix: ReadOnlySpan<string>, options: CompareOptions, out matchLength: number): boolean {
            throw new Error("not yet implemented");
        }
        private StartsWithCore(source: ReadOnlySpan<string>, prefix: ReadOnlySpan<string>, options: CompareOptions, matchLengthPtr: number*): boolean {
            throw new Error("not yet implemented");
        }
        public IsPrefix(source: string, prefix: string): boolean {
            throw new Error("not yet implemented");
        }
        public IsSuffix(source: string, suffix: string, options: CompareOptions): boolean {
            throw new Error("not yet implemented");
        }
        public IsSuffix(source: ReadOnlySpan<string>, suffix: ReadOnlySpan<string>, options: CompareOptions): boolean {
            throw new Error("not yet implemented");
        }
        public IsSuffix(source: ReadOnlySpan<string>, suffix: ReadOnlySpan<string>, options: CompareOptions, out matchLength: number): boolean {
            throw new Error("not yet implemented");
        }
        public IsSuffix(source: string, suffix: string): boolean {
            throw new Error("not yet implemented");
        }
        private EndsWithCore(source: ReadOnlySpan<string>, suffix: ReadOnlySpan<string>, options: CompareOptions, matchLengthPtr: number*): boolean {
            throw new Error("not yet implemented");
        }
        public IndexOf(source: string, value: string): number {
            throw new Error("not yet implemented");
        }
        public IndexOf(source: string, value: string): number {
            throw new Error("not yet implemented");
        }
        public IndexOf(source: string, value: string, options: CompareOptions): number {
            throw new Error("not yet implemented");
        }
        public IndexOf(source: string, value: string, options: CompareOptions): number {
            throw new Error("not yet implemented");
        }
        public IndexOf(source: string, value: string, startIndex: number): number {
            throw new Error("not yet implemented");
        }
        public IndexOf(source: string, value: string, startIndex: number): number {
            throw new Error("not yet implemented");
        }
        public IndexOf(source: string, value: string, startIndex: number, options: CompareOptions): number {
            throw new Error("not yet implemented");
        }
        public IndexOf(source: string, value: string, startIndex: number, options: CompareOptions): number {
            throw new Error("not yet implemented");
        }
        public IndexOf(source: string, value: string, startIndex: number, count: number): number {
            throw new Error("not yet implemented");
        }
        public IndexOf(source: string, value: string, startIndex: number, count: number): number {
            throw new Error("not yet implemented");
        }
        public IndexOf(source: string, value: string, startIndex: number, count: number, options: CompareOptions): number {
            throw new Error("not yet implemented");
        }
        public IndexOf(source: string, value: string, startIndex: number, count: number, options: CompareOptions): number {
            throw new Error("not yet implemented");
        }
        public IndexOf(source: ReadOnlySpan<string>, value: ReadOnlySpan<string>, options: CompareOptions): number {
            throw new Error("not yet implemented");
        }
        public IndexOf(source: ReadOnlySpan<string>, value: ReadOnlySpan<string>, options: CompareOptions, out matchLength: number): number {
            throw new Error("not yet implemented");
        }
        public IndexOf(source: ReadOnlySpan<string>, value: Rune, options: CompareOptions): number {
            throw new Error("not yet implemented");
        }
        private IndexOf(source: ReadOnlySpan<string>, value: ReadOnlySpan<string>, matchLengthPtr: number*, options: CompareOptions, fromBeginning: boolean): number {
            throw new Error("not yet implemented");
        }
        private IndexOfCore(source: ReadOnlySpan<string>, target: ReadOnlySpan<string>, options: CompareOptions, matchLengthPtr: number*, fromBeginning: boolean): number {
            throw new Error("not yet implemented");
        }
        public LastIndexOf(source: string, value: string): number {
            throw new Error("not yet implemented");
        }
        public LastIndexOf(source: string, value: string): number {
            throw new Error("not yet implemented");
        }
        public LastIndexOf(source: string, value: string, options: CompareOptions): number {
            throw new Error("not yet implemented");
        }
        public LastIndexOf(source: string, value: string, options: CompareOptions): number {
            throw new Error("not yet implemented");
        }
        public LastIndexOf(source: string, value: string, startIndex: number): number {
            throw new Error("not yet implemented");
        }
        public LastIndexOf(source: string, value: string, startIndex: number): number {
            throw new Error("not yet implemented");
        }
        public LastIndexOf(source: string, value: string, startIndex: number, options: CompareOptions): number {
            throw new Error("not yet implemented");
        }
        public LastIndexOf(source: string, value: string, startIndex: number, options: CompareOptions): number {
            throw new Error("not yet implemented");
        }
        public LastIndexOf(source: string, value: string, startIndex: number, count: number): number {
            throw new Error("not yet implemented");
        }
        public LastIndexOf(source: string, value: string, startIndex: number, count: number): number {
            throw new Error("not yet implemented");
        }
        public LastIndexOf(source: string, value: string, startIndex: number, count: number, options: CompareOptions): number {
            throw new Error("not yet implemented");
        }
        public LastIndexOf(source: string, value: string, startIndex: number, count: number, options: CompareOptions): number {
            throw new Error("not yet implemented");
        }
        public LastIndexOf(source: ReadOnlySpan<string>, value: ReadOnlySpan<string>, options: CompareOptions): number {
            throw new Error("not yet implemented");
        }
        public LastIndexOf(source: ReadOnlySpan<string>, value: ReadOnlySpan<string>, options: CompareOptions, out matchLength: number): number {
            throw new Error("not yet implemented");
        }
        public LastIndexOf(source: ReadOnlySpan<string>, value: Rune, options: CompareOptions): number {
            throw new Error("not yet implemented");
        }
        public GetSortKey(source: string, options: CompareOptions): SortKey {
            throw new Error("not yet implemented");
        }
        public GetSortKey(source: string): SortKey {
            throw new Error("not yet implemented");
        }
        private CreateSortKeyCore(source: string, options: CompareOptions): SortKey {
            throw new Error("not yet implemented");
        }
        public GetSortKey(source: ReadOnlySpan<string>, destination: Span<number>, options: CompareOptions): number {
            throw new Error("not yet implemented");
        }
        private GetSortKeyCore(source: ReadOnlySpan<string>, destination: Span<number>, options: CompareOptions): number {
            throw new Error("not yet implemented");
        }
        public GetSortKeyLength(source: ReadOnlySpan<string>, options: CompareOptions): number {
            throw new Error("not yet implemented");
        }
        private GetSortKeyLengthCore(source: ReadOnlySpan<string>, options: CompareOptions): number {
            throw new Error("not yet implemented");
        }
        public Equals(value: any): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public GetHashCode(source: string, options: CompareOptions): number {
            throw new Error("not yet implemented");
        }
        public GetHashCode(source: ReadOnlySpan<string>, options: CompareOptions): number {
            throw new Error("not yet implemented");
        }
        private GetHashCodeOfStringCore(source: ReadOnlySpan<string>, options: CompareOptions): number {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
        private IcuInitSortHandle(interopCultureName: string) {
            throw new Error("not yet implemented");
        }
        private GetIsAsciiEqualityOrdinal(interopCultureName: string): boolean {
            throw new Error("not yet implemented");
        }
        private IcuCompareString(string1: ReadOnlySpan<string>, string2: ReadOnlySpan<string>, options: CompareOptions): number {
            throw new Error("not yet implemented");
        }
        private IcuIndexOfCore(source: ReadOnlySpan<string>, target: ReadOnlySpan<string>, options: CompareOptions, matchLengthPtr: number*, fromBeginning: boolean): number {
            throw new Error("not yet implemented");
        }
        private IndexOfOrdinalIgnoreCaseHelper(source: ReadOnlySpan<string>, target: ReadOnlySpan<string>, options: CompareOptions, matchLengthPtr: number*, fromBeginning: boolean): number {
            throw new Error("not yet implemented");
        }
        private IndexOfOrdinalHelper(source: ReadOnlySpan<string>, target: ReadOnlySpan<string>, options: CompareOptions, matchLengthPtr: number*, fromBeginning: boolean): number {
            throw new Error("not yet implemented");
        }
        private IcuStartsWith(source: ReadOnlySpan<string>, prefix: ReadOnlySpan<string>, options: CompareOptions, matchLengthPtr: number*): boolean {
            throw new Error("not yet implemented");
        }
        private StartsWithOrdinalIgnoreCaseHelper(source: ReadOnlySpan<string>, prefix: ReadOnlySpan<string>, options: CompareOptions, matchLengthPtr: number*): boolean {
            throw new Error("not yet implemented");
        }
        private StartsWithOrdinalHelper(source: ReadOnlySpan<string>, prefix: ReadOnlySpan<string>, options: CompareOptions, matchLengthPtr: number*): boolean {
            throw new Error("not yet implemented");
        }
        private IcuEndsWith(source: ReadOnlySpan<string>, suffix: ReadOnlySpan<string>, options: CompareOptions, matchLengthPtr: number*): boolean {
            throw new Error("not yet implemented");
        }
        private EndsWithOrdinalIgnoreCaseHelper(source: ReadOnlySpan<string>, suffix: ReadOnlySpan<string>, options: CompareOptions, matchLengthPtr: number*): boolean {
            throw new Error("not yet implemented");
        }
        private EndsWithOrdinalHelper(source: ReadOnlySpan<string>, suffix: ReadOnlySpan<string>, options: CompareOptions, matchLengthPtr: number*): boolean {
            throw new Error("not yet implemented");
        }
        private IcuCreateSortKey(source: string, options: CompareOptions): SortKey {
            throw new Error("not yet implemented");
        }
        private IcuGetSortKey(source: ReadOnlySpan<string>, destination: Span<number>, options: CompareOptions): number {
            throw new Error("not yet implemented");
        }
        private IcuGetSortKeyLength(source: ReadOnlySpan<string>, options: CompareOptions): number {
            throw new Error("not yet implemented");
        }
        private static IcuIsSortable(text: ReadOnlySpan<string>): boolean {
            throw new Error("not yet implemented");
        }
        private IcuGetHashCodeOfString(source: ReadOnlySpan<string>, options: CompareOptions): number {
            throw new Error("not yet implemented");
        }
        private static CanUseAsciiOrdinalForOptions(options: CompareOptions): boolean {
            throw new Error("not yet implemented");
        }
        private IcuGetSortVersion(): SortVersion {
            throw new Error("not yet implemented");
        }
        private InvariantCreateSortKey(source: string, options: CompareOptions): SortKey {
            throw new Error("not yet implemented");
        }
        private static InvariantCreateSortKeyOrdinal(source: ReadOnlySpan<string>, sortKey: Span<number>) {
            throw new Error("not yet implemented");
        }
        private static InvariantCreateSortKeyOrdinalIgnoreCase(source: ReadOnlySpan<string>, sortKey: Span<number>) {
            throw new Error("not yet implemented");
        }
        private static InvariantGetSortKey(source: ReadOnlySpan<string>, destination: Span<number>, options: CompareOptions): number {
            throw new Error("not yet implemented");
        }
        private static InvariantGetSortKeyLength(source: ReadOnlySpan<string>, options: CompareOptions): number {
            throw new Error("not yet implemented");
        }
        private NlsInitSortHandle() {
            throw new Error("not yet implemented");
        }
        private static NlsGetSortHandle(cultureName: string): number {
            throw new Error("not yet implemented");
        }
        private static FindStringOrdinal(dwFindStringOrdinalFlags: number, source: ReadOnlySpan<string>, value: ReadOnlySpan<string>, bIgnoreCase: boolean): number {
            throw new Error("not yet implemented");
        }
        private static NlsIndexOfOrdinalCore(source: ReadOnlySpan<string>, value: ReadOnlySpan<string>, ignoreCase: boolean, fromBeginning: boolean): number {
            throw new Error("not yet implemented");
        }
        private NlsGetHashCodeOfString(source: ReadOnlySpan<string>, options: CompareOptions): number {
            throw new Error("not yet implemented");
        }
        private static NlsCompareStringOrdinalIgnoreCase(ref string1: string, count1: number, ref string2: string, count2: number): number {
            throw new Error("not yet implemented");
        }
        private NlsCompareString(string1: ReadOnlySpan<string>, string2: ReadOnlySpan<string>, options: CompareOptions): number {
            throw new Error("not yet implemented");
        }
        private FindString(dwFindNLSStringFlags: number, lpStringSource: ReadOnlySpan<string>, lpStringValue: ReadOnlySpan<string>, pcchFound: number*): number {
            throw new Error("not yet implemented");
        }
        private NlsIndexOfCore(source: ReadOnlySpan<string>, target: ReadOnlySpan<string>, options: CompareOptions, matchLengthPtr: number*, fromBeginning: boolean): number {
            throw new Error("not yet implemented");
        }
        private NlsStartsWith(source: ReadOnlySpan<string>, prefix: ReadOnlySpan<string>, options: CompareOptions, matchLengthPtr: number*): boolean {
            throw new Error("not yet implemented");
        }
        private NlsEndsWith(source: ReadOnlySpan<string>, suffix: ReadOnlySpan<string>, options: CompareOptions, matchLengthPtr: number*): boolean {
            throw new Error("not yet implemented");
        }
        private NlsCreateSortKey(source: string, options: CompareOptions): SortKey {
            throw new Error("not yet implemented");
        }
        private NlsGetSortKey(source: ReadOnlySpan<string>, destination: Span<number>, options: CompareOptions): number {
            throw new Error("not yet implemented");
        }
        private NlsGetSortKeyLength(source: ReadOnlySpan<string>, options: CompareOptions): number {
            throw new Error("not yet implemented");
        }
        private static NlsIsSortable(text: ReadOnlySpan<string>): boolean {
            throw new Error("not yet implemented");
        }
        private static GetNativeCompareFlags(options: CompareOptions): number {
            throw new Error("not yet implemented");
        }
        private NlsGetSortVersion(): SortVersion {
            throw new Error("not yet implemented");
        }
        private IsPrefixUtf8(source: ReadOnlySpan<number>, prefix: ReadOnlySpan<number>, options: CompareOptions): boolean {
            throw new Error("not yet implemented");
        }
        private StartsWithCoreUtf8(source: ReadOnlySpan<number>, prefix: ReadOnlySpan<number>, options: CompareOptions): boolean {
            throw new Error("not yet implemented");
        }
    }
    export namespace CompareInfo {
        export class SortHandleCache {
            private static readonly s_sortNameToSortHandleCache: Dictionary<string, number>;

            private static staticctor_initialize = (() => {
                throw new Error("not yet implemented");
            })();
            private constructor() { }

            private static GetCachedSortHandle(sortName: string): number {
                throw new Error("not yet implemented");
            }
        }
    }
    export enum DateTimeFormatFlags {
        None = 0x0,
        UseGenitiveMonth = 0x1,
        UseLeapYearMonth = 0x2,
        UseSpacesInMonthNames = 0x4,
        UseHebrewRule = 0x8,
        UseSpacesInDayNames = 0x10,
        UseDigitPrefixInTokens = 0x20,
        NotInitialized = 0xffffffff,
    }
    export class TokenHashValue {
        private tokenString: string;
        private tokenType: TokenType;
        private tokenValue: number;

        protected constructor(tokenString: string, tokenType: TokenType, tokenValue: number) {
            throw new Error("not yet implemented");
        }

    }
    export enum MonthNameStyles {
        Regular = 0x0,
        Genitive = 0x1,
        LeapYear = 0x2,
    }
    export enum DateTimeStyles {
        None = 0x0,
        AllowLeadingWhite = 0x1,
        AllowTrailingWhite = 0x2,
        AllowInnerWhite = 0x4,
        AllowWhiteSpaces = 0x7,
        NoCurrentDateDefault = 0x8,
        AdjustToUniversal = 0x10,
        AssumeLocal = 0x20,
        AssumeUniversal = 0x40,
        RoundtripKind = 0x80,
    }
    export class DateTimeFormatInfo implements IFormatProvider, ICloneable {
        private static s_jajpDTFI: DateTimeFormatInfo;
        private static s_zhtwDTFI: DateTimeFormatInfo;

        public static get InvariantInfo(): DateTimeFormatInfo {
            throw new Error("not yet implemented");
        }
        public static get CurrentInfo(): DateTimeFormatInfo {
            throw new Error("not yet implemented");
        }

        private _cultureData: CultureData;
        private _name: string;
        private _langName: string;
        private _compareInfo: CompareInfo;
        private _cultureInfo: CultureInfo;
        private amDesignator: string;
        private pmDesignator: string;
        private dateSeparator: string;
        private generalShortTimePattern: string;
        private generalLongTimePattern: string;
        private timeSeparator: string;
        private monthDayPattern: string;
        private dateTimeOffsetPattern: string;
        private amDesignatorUtf8: number[];
        private pmDesignatorUtf8: number[];
        private timeSeparatorUtf8: number[];
        private dateSeparatorUtf8: number[];
        private calendar: Calendar;
        private firstDayOfWeek: number;
        private calendarWeekRule: number;
        private fullDateTimePattern: string;
        private abbreviatedDayNames: string[];
        private m_superShortDayNames: string[];
        private dayNames: string[];
        private abbreviatedMonthNames: string[];
        private monthNames: string[];
        private genitiveMonthNames: string[];
        private m_genitiveAbbreviatedMonthNames: string[];
        private leapYearMonthNames: string[];
        private longDatePattern: string;
        private shortDatePattern: string;
        private yearMonthPattern: string;
        private longTimePattern: string;
        private shortTimePattern: string;
        private allYearMonthPatterns: string[];
        private allShortDatePatterns: string[];
        private allLongDatePatterns: string[];
        private allShortTimePatterns: string[];
        private allLongTimePatterns: string[];
        private m_eraNames: string[];
        private m_abbrevEraNames: string[];
        private m_abbrevEnglishEraNames: string[];
        private optionalCalendars: CalendarId[];
        private _isReadOnly: boolean;
        private formatFlags: DateTimeFormatFlags;
        private _decimalSeparator: string;
        private _decimalSeparatorUtf8: number[];
        private _fullTimeSpanPositivePattern: string;
        private _fullTimeSpanNegativePattern: string;
        private _dtfiTokenHash: TokenHashValue[];

        private get CultureName(): string {
            throw new Error("not yet implemented");
        }
        private get Culture(): CultureInfo {
            throw new Error("not yet implemented");
        }
        private get LanguageName(): string {
            throw new Error("not yet implemented");
        }
        public get AMDesignator(): string {
            throw new Error("not yet implemented");
        }
        public set AMDesignator(value: string) {
            throw new Error("not yet implemented");
        }
        public get Calendar(): Calendar {
            throw new Error("not yet implemented");
        }
        public set Calendar(value: Calendar) {
            throw new Error("not yet implemented");
        }
        private get OptionalCalendars(): CalendarId[] {
            throw new Error("not yet implemented");
        }
        private get EraNames(): string[] {
            throw new Error("not yet implemented");
        }
        private get AbbreviatedEraNames(): string[] {
            throw new Error("not yet implemented");
        }
        private get AbbreviatedEnglishEraNames(): string[] {
            throw new Error("not yet implemented");
        }
        public get DateSeparator(): string {
            throw new Error("not yet implemented");
        }
        public set DateSeparator(value: string) {
            throw new Error("not yet implemented");
        }
        public get FirstDayOfWeek(): DayOfWeek {
            throw new Error("not yet implemented");
        }
        public set FirstDayOfWeek(value: DayOfWeek) {
            throw new Error("not yet implemented");
        }
        public get CalendarWeekRule(): CalendarWeekRule {
            throw new Error("not yet implemented");
        }
        public set CalendarWeekRule(value: CalendarWeekRule) {
            throw new Error("not yet implemented");
        }
        public get FullDateTimePattern(): string {
            throw new Error("not yet implemented");
        }
        public set FullDateTimePattern(value: string) {
            throw new Error("not yet implemented");
        }
        public get LongDatePattern(): string {
            throw new Error("not yet implemented");
        }
        public set LongDatePattern(value: string) {
            throw new Error("not yet implemented");
        }
        public get LongTimePattern(): string {
            throw new Error("not yet implemented");
        }
        public set LongTimePattern(value: string) {
            throw new Error("not yet implemented");
        }
        public get MonthDayPattern(): string {
            throw new Error("not yet implemented");
        }
        public set MonthDayPattern(value: string) {
            throw new Error("not yet implemented");
        }
        public get PMDesignator(): string {
            throw new Error("not yet implemented");
        }
        public set PMDesignator(value: string) {
            throw new Error("not yet implemented");
        }
        public get RFC1123Pattern(): string {
            throw new Error("not yet implemented");
        }
        public get ShortDatePattern(): string {
            throw new Error("not yet implemented");
        }
        public set ShortDatePattern(value: string) {
            throw new Error("not yet implemented");
        }
        public get ShortTimePattern(): string {
            throw new Error("not yet implemented");
        }
        public set ShortTimePattern(value: string) {
            throw new Error("not yet implemented");
        }
        public get SortableDateTimePattern(): string {
            throw new Error("not yet implemented");
        }
        private get GeneralShortTimePattern(): string {
            throw new Error("not yet implemented");
        }
        private get GeneralLongTimePattern(): string {
            throw new Error("not yet implemented");
        }
        private get DateTimeOffsetPattern(): string {
            throw new Error("not yet implemented");
        }
        public get TimeSeparator(): string {
            throw new Error("not yet implemented");
        }
        public set TimeSeparator(value: string) {
            throw new Error("not yet implemented");
        }
        public get UniversalSortableDateTimePattern(): string {
            throw new Error("not yet implemented");
        }
        public get YearMonthPattern(): string {
            throw new Error("not yet implemented");
        }
        public set YearMonthPattern(value: string) {
            throw new Error("not yet implemented");
        }
        public get AbbreviatedDayNames(): string[] {
            throw new Error("not yet implemented");
        }
        public set AbbreviatedDayNames(value: string[]) {
            throw new Error("not yet implemented");
        }
        public get ShortestDayNames(): string[] {
            throw new Error("not yet implemented");
        }
        public set ShortestDayNames(value: string[]) {
            throw new Error("not yet implemented");
        }
        public get DayNames(): string[] {
            throw new Error("not yet implemented");
        }
        public set DayNames(value: string[]) {
            throw new Error("not yet implemented");
        }
        public get AbbreviatedMonthNames(): string[] {
            throw new Error("not yet implemented");
        }
        public set AbbreviatedMonthNames(value: string[]) {
            throw new Error("not yet implemented");
        }
        public get MonthNames(): string[] {
            throw new Error("not yet implemented");
        }
        public set MonthNames(value: string[]) {
            throw new Error("not yet implemented");
        }
        private get HasSpacesInMonthNames(): boolean {
            throw new Error("not yet implemented");
        }
        private get HasSpacesInDayNames(): boolean {
            throw new Error("not yet implemented");
        }
        private get AllYearMonthPatterns(): string[] {
            throw new Error("not yet implemented");
        }
        private get AllShortDatePatterns(): string[] {
            throw new Error("not yet implemented");
        }
        private get AllShortTimePatterns(): string[] {
            throw new Error("not yet implemented");
        }
        private get AllLongDatePatterns(): string[] {
            throw new Error("not yet implemented");
        }
        private get AllLongTimePatterns(): string[] {
            throw new Error("not yet implemented");
        }
        private get UnclonedYearMonthPatterns(): string[] {
            throw new Error("not yet implemented");
        }
        private get UnclonedShortDatePatterns(): string[] {
            throw new Error("not yet implemented");
        }
        private get UnclonedLongDatePatterns(): string[] {
            throw new Error("not yet implemented");
        }
        private get UnclonedShortTimePatterns(): string[] {
            throw new Error("not yet implemented");
        }
        private get UnclonedLongTimePatterns(): string[] {
            throw new Error("not yet implemented");
        }
        public get IsReadOnly(): boolean {
            throw new Error("not yet implemented");
        }
        public get NativeCalendarName(): string {
            throw new Error("not yet implemented");
        }
        public get AbbreviatedMonthGenitiveNames(): string[] {
            throw new Error("not yet implemented");
        }
        public set AbbreviatedMonthGenitiveNames(value: string[]) {
            throw new Error("not yet implemented");
        }
        public get MonthGenitiveNames(): string[] {
            throw new Error("not yet implemented");
        }
        public set MonthGenitiveNames(value: string[]) {
            throw new Error("not yet implemented");
        }
        private get DecimalSeparator(): string {
            throw new Error("not yet implemented");
        }
        private get FullTimeSpanPositivePattern(): string {
            throw new Error("not yet implemented");
        }
        private get FullTimeSpanNegativePattern(): string {
            throw new Error("not yet implemented");
        }
        private get CompareInfo(): CompareInfo {
            throw new Error("not yet implemented");
        }
        private get FormatFlags(): DateTimeFormatFlags {
            throw new Error("not yet implemented");
        }
        private get HasForceTwoDigitYears(): boolean {
            throw new Error("not yet implemented");
        }
        private get HasYearMonthAdjustment(): boolean {
            throw new Error("not yet implemented");
        }

        public constructor() {
            throw new Error("not yet implemented");
        }
        protected constructor(cultureData: CultureData, cal: Calendar) {
            throw new Error("not yet implemented");
        }

        private InternalGetAbbreviatedDayOfWeekNames(): string[] {
            throw new Error("not yet implemented");
        }
        private InternalGetAbbreviatedDayOfWeekNamesCore(): string[] {
            throw new Error("not yet implemented");
        }
        private InternalGetSuperShortDayNames(): string[] {
            throw new Error("not yet implemented");
        }
        private InternalGetSuperShortDayNamesCore(): string[] {
            throw new Error("not yet implemented");
        }
        private InternalGetDayOfWeekNames(): string[] {
            throw new Error("not yet implemented");
        }
        private InternalGetDayOfWeekNamesCore(): string[] {
            throw new Error("not yet implemented");
        }
        private InternalGetAbbreviatedMonthNames(): string[] {
            throw new Error("not yet implemented");
        }
        private InternalGetAbbreviatedMonthNamesCore(): string[] {
            throw new Error("not yet implemented");
        }
        private InternalGetMonthNames(): string[] {
            throw new Error("not yet implemented");
        }
        private internalGetMonthNamesCore(): string[] {
            throw new Error("not yet implemented");
        }
        private InitializeOverridableProperties(cultureData: CultureData, calendarId: CalendarId) {
            throw new Error("not yet implemented");
        }
        public static GetInstance(provider: IFormatProvider): DateTimeFormatInfo {
            throw new Error("not yet implemented");
        }
        public GetFormat(formatType: Type): any {
            throw new Error("not yet implemented");
        }
        public Clone(): any {
            throw new Error("not yet implemented");
        }
        private AMDesignatorTChar(): ReadOnlySpan<TChar> {
            throw new Error("not yet implemented");
        }
        public GetEra(eraName: string): number {
            throw new Error("not yet implemented");
        }
        public GetEraName(era: number): string {
            throw new Error("not yet implemented");
        }
        public GetAbbreviatedEraName(era: number): string {
            throw new Error("not yet implemented");
        }
        private DateSeparatorTChar(): ReadOnlySpan<TChar> {
            throw new Error("not yet implemented");
        }
        private OnLongDatePatternChanged() {
            throw new Error("not yet implemented");
        }
        private OnLongTimePatternChanged() {
            throw new Error("not yet implemented");
        }
        private PMDesignatorTChar(): ReadOnlySpan<TChar> {
            throw new Error("not yet implemented");
        }
        private OnShortDatePatternChanged() {
            throw new Error("not yet implemented");
        }
        private OnShortTimePatternChanged() {
            throw new Error("not yet implemented");
        }
        private TimeSeparatorTChar(): ReadOnlySpan<TChar> {
            throw new Error("not yet implemented");
        }
        private OnYearMonthPatternChanged() {
            throw new Error("not yet implemented");
        }
        private static CheckNullValue(values: string[], length: number) {
            throw new Error("not yet implemented");
        }
        private InternalGetMonthName(month: number, style: MonthNameStyles, abbreviated: boolean): string {
            throw new Error("not yet implemented");
        }
        private InternalGetGenitiveMonthNames(abbreviated: boolean): string[] {
            throw new Error("not yet implemented");
        }
        private InternalGetLeapYearMonthNames(): string[] {
            throw new Error("not yet implemented");
        }
        public GetAbbreviatedDayName(dayofweek: DayOfWeek): string {
            throw new Error("not yet implemented");
        }
        public GetShortestDayName(dayOfWeek: DayOfWeek): string {
            throw new Error("not yet implemented");
        }
        private static GetCombinedPatterns(patterns1: string[], patterns2: string[], connectString: string): string[] {
            throw new Error("not yet implemented");
        }
        public GetAllDateTimePatterns(): string[] {
            throw new Error("not yet implemented");
        }
        public GetAllDateTimePatterns(format: string): string[] {
            throw new Error("not yet implemented");
        }
        public GetDayName(dayofweek: DayOfWeek): string {
            throw new Error("not yet implemented");
        }
        public GetAbbreviatedMonthName(month: number): string {
            throw new Error("not yet implemented");
        }
        public GetMonthName(month: number): string {
            throw new Error("not yet implemented");
        }
        private static GetMergedPatterns(patterns: string[], defaultPattern: string): string[] {
            throw new Error("not yet implemented");
        }
        public static ReadOnly(dtfi: DateTimeFormatInfo): DateTimeFormatInfo {
            throw new Error("not yet implemented");
        }
        public SetAllDateTimePatterns(patterns: string[], format: string) {
            throw new Error("not yet implemented");
        }
        private DecimalSeparatorTChar(): ReadOnlySpan<TChar> {
            throw new Error("not yet implemented");
        }
        private static ValidateStyles(style: DateTimeStyles, styles: boolean) {
            throw new Error("not yet implemented");
        }
        private InitializeFormatFlags(): DateTimeFormatFlags {
            throw new Error("not yet implemented");
        }
        private YearMonthAdjustment(ref year: number, ref month: number, parsedMonthName: boolean): boolean {
            throw new Error("not yet implemented");
        }
        private static GetJapaneseCalendarDTFI(): DateTimeFormatInfo {
            throw new Error("not yet implemented");
        }
        private static GetTaiwanCalendarDTFI(): DateTimeFormatInfo {
            throw new Error("not yet implemented");
        }
        private ClearTokenHashTable() {
            throw new Error("not yet implemented");
        }
        private CreateTokenHashTable(): TokenHashValue[] {
            throw new Error("not yet implemented");
        }
        private AddMonthNames(temp: TokenHashValue[], monthPostfix: ReadOnlySpan<string>) {
            throw new Error("not yet implemented");
        }
        private static TryParseHebrewNumber(ref str: __DTString, out badFormat: boolean, out number: number): boolean {
            throw new Error("not yet implemented");
        }
        private static IsHebrewChar(ch: string): boolean {
            throw new Error("not yet implemented");
        }
        private IsAllowedJapaneseTokenFollowedByNonSpaceLetter(tokenString: string, nextCh: string): boolean {
            throw new Error("not yet implemented");
        }
        private Tokenize(TokenMask: TokenType, out tokenType: TokenType, out tokenValue: number, ref str: __DTString): boolean {
            throw new Error("not yet implemented");
        }
        private InsertAtCurrentHashNode(hashTable: TokenHashValue[], str: string, ch: string, tokenType: TokenType, tokenValue: number, pos: number, hashcode: number, hashProbe: number) {
            throw new Error("not yet implemented");
        }
        private InsertHash(hashTable: TokenHashValue[], str: string, tokenType: TokenType, tokenValue: number) {
            throw new Error("not yet implemented");
        }
        private CompareStringIgnoreCaseOptimized(string1: string, offset1: number, length1: number, string2: string, offset2: number, length2: number): boolean {
            throw new Error("not yet implemented");
        }
        private static __ValidateStyles__g__ThrowInvalid_229_0(style: DateTimeStyles, styles: boolean) {
            throw new Error("not yet implemented");
        }
    }
    export namespace DateTimeFormatInfo {
        export class TokenHashValue {
            private tokenString: string;
            private tokenType: TokenType;
            private tokenValue: number;

            protected constructor(tokenString: string, tokenType: TokenType, tokenValue: number) {
                throw new Error("not yet implemented");
            }

        }
    }
    export class CultureInfo implements IFormatProvider, ICloneable {
        private static s_userDefaultCulture: CultureInfo;
        private static s_userDefaultUICulture: CultureInfo;
        private static readonly s_InvariantCultureInfo: CultureInfo;
        private static s_DefaultThreadCurrentUICulture: CultureInfo;
        private static s_DefaultThreadCurrentCulture: CultureInfo;
        private static s_asyncLocalCurrentCulture: AsyncLocal<CultureInfo>;
        private static s_asyncLocalCurrentUICulture: AsyncLocal<CultureInfo>;
        private static s_cachedCulturesByName: Dictionary<string, CultureInfo>;
        private static s_cachedCulturesByLcid: Dictionary<number, CultureInfo>;
        private static __UserDefaultLocaleName__k__BackingField: string;
        private static s_currentThreadCulture: CultureInfo;
        private static s_currentThreadUICulture: CultureInfo;
        private static LOCALE_NEUTRAL: number;
        private static LOCALE_USER_DEFAULT: number;
        private static LOCALE_SYSTEM_DEFAULT: number;
        private static LOCALE_CUSTOM_UNSPECIFIED: number;
        private static LOCALE_CUSTOM_DEFAULT: number;
        private static LOCALE_INVARIANT: number;

        public static get CurrentCulture(): CultureInfo {
            throw new Error("not yet implemented");
        }
        public static set CurrentCulture(value: CultureInfo) {
            throw new Error("not yet implemented");
        }
        public static get CurrentUICulture(): CultureInfo {
            throw new Error("not yet implemented");
        }
        public static set CurrentUICulture(value: CultureInfo) {
            throw new Error("not yet implemented");
        }
        private static get UserDefaultUICulture(): CultureInfo {
            throw new Error("not yet implemented");
        }
        public static get InstalledUICulture(): CultureInfo {
            throw new Error("not yet implemented");
        }
        public static get DefaultThreadCurrentCulture(): CultureInfo {
            throw new Error("not yet implemented");
        }
        public static set DefaultThreadCurrentCulture(value: CultureInfo) {
            throw new Error("not yet implemented");
        }
        public static get DefaultThreadCurrentUICulture(): CultureInfo {
            throw new Error("not yet implemented");
        }
        public static set DefaultThreadCurrentUICulture(value: CultureInfo) {
            throw new Error("not yet implemented");
        }
        public static get InvariantCulture(): CultureInfo {
            throw new Error("not yet implemented");
        }
        private static get CachedCulturesByName(): Dictionary<string, CultureInfo> {
            throw new Error("not yet implemented");
        }
        private static get CachedCulturesByLcid(): Dictionary<number, CultureInfo> {
            throw new Error("not yet implemented");
        }
        private static get UserDefaultLocaleName(): string {
            throw new Error("not yet implemented");
        }
        private static set UserDefaultLocaleName(value: string) {
            throw new Error("not yet implemented");
        }

        private _isReadOnly: boolean;
        private _compareInfo: CompareInfo;
        private _textInfo: TextInfo;
        private _numInfo: NumberFormatInfo;
        private _dateTimeInfo: DateTimeFormatInfo;
        private _calendar: Calendar;
        private _cultureData: CultureData;
        private _isInherited: boolean;
        private _consoleFallbackCulture: CultureInfo;
        private _name: string;
        private _nonSortName: string;
        private _sortName: string;
        private _parent: CultureInfo;

        public get Parent(): CultureInfo {
            throw new Error("not yet implemented");
        }
        public get LCID(): number {
            throw new Error("not yet implemented");
        }
        public get KeyboardLayoutId(): number {
            throw new Error("not yet implemented");
        }
        public get Name(): string {
            throw new Error("not yet implemented");
        }
        private get SortName(): string {
            throw new Error("not yet implemented");
        }
        private get InteropName(): string {
            throw new Error("not yet implemented");
        }
        public get IetfLanguageTag(): string {
            throw new Error("not yet implemented");
        }
        public get DisplayName(): string {
            throw new Error("not yet implemented");
        }
        public get NativeName(): string {
            throw new Error("not yet implemented");
        }
        public get EnglishName(): string {
            throw new Error("not yet implemented");
        }
        public get TwoLetterISOLanguageName(): string {
            throw new Error("not yet implemented");
        }
        public get ThreeLetterISOLanguageName(): string {
            throw new Error("not yet implemented");
        }
        public get ThreeLetterWindowsLanguageName(): string {
            throw new Error("not yet implemented");
        }
        public get CompareInfo(): CompareInfo {
            throw new Error("not yet implemented");
        }
        public get TextInfo(): TextInfo {
            throw new Error("not yet implemented");
        }
        public get IsNeutralCulture(): boolean {
            throw new Error("not yet implemented");
        }
        public get CultureTypes(): CultureTypes {
            throw new Error("not yet implemented");
        }
        public get NumberFormat(): NumberFormatInfo {
            throw new Error("not yet implemented");
        }
        public set NumberFormat(value: NumberFormatInfo) {
            throw new Error("not yet implemented");
        }
        public get DateTimeFormat(): DateTimeFormatInfo {
            throw new Error("not yet implemented");
        }
        public set DateTimeFormat(value: DateTimeFormatInfo) {
            throw new Error("not yet implemented");
        }
        public get Calendar(): Calendar {
            throw new Error("not yet implemented");
        }
        public get OptionalCalendars(): Calendar[] {
            throw new Error("not yet implemented");
        }
        public get UseUserOverride(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsReadOnly(): boolean {
            throw new Error("not yet implemented");
        }
        private get HasInvariantCultureName(): boolean {
            throw new Error("not yet implemented");
        }

        public constructor(name: string) {
            throw new Error("not yet implemented");
        }
        public constructor(name: string, useUserOverride: boolean) {
            throw new Error("not yet implemented");
        }
        private constructor(cultureData: CultureData, isReadOnly: boolean) {
            throw new Error("not yet implemented");
        }
        public constructor(culture: number) {
            throw new Error("not yet implemented");
        }
        public constructor(culture: number, useUserOverride: boolean) {
            throw new Error("not yet implemented");
        }
        protected constructor(cultureName: string, textAndCompareCultureName: string) {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

        private static AsyncLocalSetCurrentCulture(args: AsyncLocalValueChangedArgs<CultureInfo>) {
            throw new Error("not yet implemented");
        }
        private static AsyncLocalSetCurrentUICulture(args: AsyncLocalValueChangedArgs<CultureInfo>) {
            throw new Error("not yet implemented");
        }
        private static InitializeUserDefaultCulture(): CultureInfo {
            throw new Error("not yet implemented");
        }
        private static InitializeUserDefaultUICulture(): CultureInfo {
            throw new Error("not yet implemented");
        }
        private static GetCultureNotSupportedExceptionMessage(): string {
            throw new Error("not yet implemented");
        }
        private static CreateCultureInfoNoThrow(name: string, useUserOverride: boolean): CultureInfo {
            throw new Error("not yet implemented");
        }
        private static GetCultureByName(name: string): CultureInfo {
            throw new Error("not yet implemented");
        }
        public static CreateSpecificCulture(name: string): CultureInfo {
            throw new Error("not yet implemented");
        }
        private static VerifyCultureName(cultureName: string, throwException: boolean): boolean {
            throw new Error("not yet implemented");
        }
        private static VerifyCultureName(culture: CultureInfo, throwException: boolean): boolean {
            throw new Error("not yet implemented");
        }
        public static GetCultures(types: CultureTypes): CultureInfo[] {
            throw new Error("not yet implemented");
        }
        public Equals(value: any): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
        public GetFormat(formatType: Type): any {
            throw new Error("not yet implemented");
        }
        public ClearCachedData() {
            throw new Error("not yet implemented");
        }
        private static GetCalendarInstance(calType: CalendarId): Calendar {
            throw new Error("not yet implemented");
        }
        private static GetCalendarInstanceRare(calType: CalendarId): Calendar {
            throw new Error("not yet implemented");
        }
        public GetConsoleFallbackUICulture(): CultureInfo {
            throw new Error("not yet implemented");
        }
        public Clone(): any {
            throw new Error("not yet implemented");
        }
        public static ReadOnly(ci: CultureInfo): CultureInfo {
            throw new Error("not yet implemented");
        }
        private VerifyWritable() {
            throw new Error("not yet implemented");
        }
        public static GetCultureInfo(culture: number): CultureInfo {
            throw new Error("not yet implemented");
        }
        public static GetCultureInfo(name: string): CultureInfo {
            throw new Error("not yet implemented");
        }
        public static GetCultureInfo(name: string, altName: string): CultureInfo {
            throw new Error("not yet implemented");
        }
        public static GetCultureInfo(name: string, predefinedOnly: boolean): CultureInfo {
            throw new Error("not yet implemented");
        }
        public static GetCultureInfoByIetfLanguageTag(name: string): CultureInfo {
            throw new Error("not yet implemented");
        }
        private static GetUserDefaultCulture(): CultureInfo {
            throw new Error("not yet implemented");
        }
        private static GetUserDefaultUICulture(): CultureInfo {
            throw new Error("not yet implemented");
        }
        private static GetUserDefaultLocaleName(): string {
            throw new Error("not yet implemented");
        }
    }
    export namespace CultureInfo {
        export class ____O {
            public static __0____AsyncLocalSetCurrentCulture: Action<AsyncLocalValueChangedArgs<CultureInfo>>;
            public static __1____AsyncLocalSetCurrentUICulture: Action<AsyncLocalValueChangedArgs<CultureInfo>>;

        }
    }
    export class DaylightTimeStruct extends ValueType {
        public Start: DateTime;
        public End: DateTime;
        public Delta: TimeSpan;

        public constructor(start: DateTime, end: DateTime, delta: TimeSpan) {
            throw new Error("not yet implemented");
        }

    }
}
export namespace System.IO {
    export class ReadWriteTask extends Task<number> implements IAsyncResult, IDisposable, ITaskCompletionAction {
        private static s_invokeAsyncCallback: ContextCallback;

        private _isRead: boolean;
        private _apm: boolean;
        private _endCalled: boolean;
        private _stream: Stream;
        private _buffer: number[];
        private _offset: number;
        private _count: number;
        private _callback: AsyncCallback;
        private _context: ExecutionContext;

        private get __explicit__ITaskCompletionAction_InvokeMayRunArbitraryCode(): boolean {
            throw new Error("not yet implemented");
        }
        public get InvokeMayRunArbitraryCode(): boolean {
            throw new Error("Invalid call (use ExplicitAs property)");
        }

        public constructor(isRead: boolean, apm: boolean, function: Func<any, number>, state: any, stream: Stream, buffer: number[], offset: number, count: number, callback: AsyncCallback) {
            throw new Error("not yet implemented");
        }

        private ClearBeginState() {
            throw new Error("not yet implemented");
        }
        private static InvokeAsyncCallback(completedTask: any) {
            throw new Error("not yet implemented");
        }
        private __explicit__ITaskCompletionAction_Invoke(completingTask: Task) {
            throw new Error("not yet implemented");
        }
        public Invoke(completingTask: Task) {
            throw new Error("Invalid call (use ExplicitAs property)");
        }

        public readonly ExplicitAsIAsyncResult: IAsyncResult = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'InvokeMayRunArbitraryCode') {
                    return target.__explicit__ITaskCompletionAction_InvokeMayRunArbitraryCode;
                }
        
                if (prop === 'Invoke') {
                    return target.__explicit__ITaskCompletionAction_Invoke.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIDisposable: IDisposable = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'InvokeMayRunArbitraryCode') {
                    return target.__explicit__ITaskCompletionAction_InvokeMayRunArbitraryCode;
                }
        
                if (prop === 'Invoke') {
                    return target.__explicit__ITaskCompletionAction_Invoke.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsITaskCompletionAction: ITaskCompletionAction = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'InvokeMayRunArbitraryCode') {
                    return target.__explicit__ITaskCompletionAction_InvokeMayRunArbitraryCode;
                }
        
                if (prop === 'Invoke') {
                    return target.__explicit__ITaskCompletionAction_Invoke.bind(target);
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
    }
    export namespace ReadWriteTask {
        export class ____O {
            public static __0____InvokeAsyncCallback: ContextCallback;

        }
    }
    export enum SeekOrigin {
        Begin = 0,
        Current = 1,
        End = 2,
    }
    export abstract class Stream extends MarshalByRefObject implements IDisposable, IAsyncDisposable {
        public static readonly Null: Stream;

        private _asyncActiveSemaphore: SemaphoreSlim;

        public get CanRead(): boolean;
        public get CanWrite(): boolean;
        public get CanSeek(): boolean;
        public get CanTimeout(): boolean {
            throw new Error("not yet implemented");
        }
        public get Length(): number;
        public get Position(): number;
        public set Position(value: number);
        public get ReadTimeout(): number {
            throw new Error("not yet implemented");
        }
        public set ReadTimeout(value: number) {
            throw new Error("not yet implemented");
        }
        public get WriteTimeout(): number {
            throw new Error("not yet implemented");
        }
        public set WriteTimeout(value: number) {
            throw new Error("not yet implemented");
        }

        protected constructor() {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

        private EnsureAsyncActiveSemaphoreInitialized(): SemaphoreSlim {
            throw new Error("not yet implemented");
        }
        public CopyTo(destination: Stream) {
            throw new Error("not yet implemented");
        }
        public CopyTo(destination: Stream, bufferSize: number) {
            throw new Error("not yet implemented");
        }
        public CopyToAsync(destination: Stream): Task {
            throw new Error("not yet implemented");
        }
        public CopyToAsync(destination: Stream, bufferSize: number): Task {
            throw new Error("not yet implemented");
        }
        public CopyToAsync(destination: Stream, cancellationToken: CancellationToken): Task {
            throw new Error("not yet implemented");
        }
        public CopyToAsync(destination: Stream, bufferSize: number, cancellationToken: CancellationToken): Task {
            throw new Error("not yet implemented");
        }
        private GetCopyBufferSize(): number {
            throw new Error("not yet implemented");
        }
        public Dispose() {
            throw new Error("not yet implemented");
        }
        public Close() {
            throw new Error("not yet implemented");
        }
        private Dispose(disposing: boolean) {
            throw new Error("not yet implemented");
        }
        public DisposeAsync(): ValueTask {
            throw new Error("not yet implemented");
        }
        public Flush(): void;
        public FlushAsync(): Task {
            throw new Error("not yet implemented");
        }
        public FlushAsync(cancellationToken: CancellationToken): Task {
            throw new Error("not yet implemented");
        }
        private CreateWaitHandle(): WaitHandle {
            throw new Error("not yet implemented");
        }
        public BeginRead(buffer: number[], offset: number, count: number, callback: AsyncCallback, state: any): IAsyncResult {
            throw new Error("not yet implemented");
        }
        private BeginReadInternal(buffer: number[], offset: number, count: number, callback: AsyncCallback, state: any, serializeAsynchronously: boolean, apm: boolean): Task<number> {
            throw new Error("not yet implemented");
        }
        public EndRead(asyncResult: IAsyncResult): number {
            throw new Error("not yet implemented");
        }
        public ReadAsync(buffer: number[], offset: number, count: number): Task<number> {
            throw new Error("not yet implemented");
        }
        public ReadAsync(buffer: number[], offset: number, count: number, cancellationToken: CancellationToken): Task<number> {
            throw new Error("not yet implemented");
        }
        public ReadAsync(buffer: Memory<number>, cancellationToken: CancellationToken): ValueTask<number> {
            throw new Error("not yet implemented");
        }
        public ReadExactlyAsync(buffer: Memory<number>, cancellationToken: CancellationToken): ValueTask {
            throw new Error("not yet implemented");
        }
        public ReadExactlyAsync(buffer: number[], offset: number, count: number, cancellationToken: CancellationToken): ValueTask {
            throw new Error("not yet implemented");
        }
        public ReadAtLeastAsync(buffer: Memory<number>, minimumBytes: number, throwOnEndOfStream: boolean, cancellationToken: CancellationToken): ValueTask<number> {
            throw new Error("not yet implemented");
        }
        private ReadAtLeastAsyncCore(buffer: Memory<number>, minimumBytes: number, throwOnEndOfStream: boolean, cancellationToken: CancellationToken): ValueTask<number> {
            throw new Error("not yet implemented");
        }
        private HasOverriddenBeginEndRead(): boolean {
            throw new Error("not yet implemented");
        }
        private HasOverriddenBeginEndWrite(): boolean {
            throw new Error("not yet implemented");
        }
        private BeginEndReadAsync(buffer: number[], offset: number, count: number): Task<number> {
            throw new Error("not yet implemented");
        }
        public BeginWrite(buffer: number[], offset: number, count: number, callback: AsyncCallback, state: any): IAsyncResult {
            throw new Error("not yet implemented");
        }
        private BeginWriteInternal(buffer: number[], offset: number, count: number, callback: AsyncCallback, state: any, serializeAsynchronously: boolean, apm: boolean): Task {
            throw new Error("not yet implemented");
        }
        private static RunReadWriteTaskWhenReady(asyncWaiter: Task, readWriteTask: ReadWriteTask) {
            throw new Error("not yet implemented");
        }
        private static RunReadWriteTask(readWriteTask: ReadWriteTask) {
            throw new Error("not yet implemented");
        }
        private FinishTrackingAsyncOperation(task: ReadWriteTask) {
            throw new Error("not yet implemented");
        }
        public EndWrite(asyncResult: IAsyncResult) {
            throw new Error("not yet implemented");
        }
        public WriteAsync(buffer: number[], offset: number, count: number): Task {
            throw new Error("not yet implemented");
        }
        public WriteAsync(buffer: number[], offset: number, count: number, cancellationToken: CancellationToken): Task {
            throw new Error("not yet implemented");
        }
        public WriteAsync(buffer: ReadOnlyMemory<number>, cancellationToken: CancellationToken): ValueTask {
            throw new Error("not yet implemented");
        }
        private static FinishWriteAsync(writeTask: Task, localBuffer: number[]): Task {
            throw new Error("not yet implemented");
        }
        private BeginEndWriteAsync(buffer: number[], offset: number, count: number): Task {
            throw new Error("not yet implemented");
        }
        public Seek(offset: number, origin: SeekOrigin): number;
        public SetLength(value: number): void;
        public Read(buffer: number[], offset: number, count: number): number;
        public Read(buffer: Span<number>): number {
            throw new Error("not yet implemented");
        }
        public ReadByte(): number {
            throw new Error("not yet implemented");
        }
        public ReadExactly(buffer: Span<number>) {
            throw new Error("not yet implemented");
        }
        public ReadExactly(buffer: number[], offset: number, count: number) {
            throw new Error("not yet implemented");
        }
        public ReadAtLeast(buffer: Span<number>, minimumBytes: number, throwOnEndOfStream: boolean): number {
            throw new Error("not yet implemented");
        }
        private ReadAtLeastCore(buffer: Span<number>, minimumBytes: number, throwOnEndOfStream: boolean): number {
            throw new Error("not yet implemented");
        }
        public Write(buffer: number[], offset: number, count: number): void;
        public Write(buffer: ReadOnlySpan<number>) {
            throw new Error("not yet implemented");
        }
        public WriteByte(value: number) {
            throw new Error("not yet implemented");
        }
        public static Synchronized(stream: Stream): Stream {
            throw new Error("not yet implemented");
        }
        private ObjectInvariant() {
            throw new Error("not yet implemented");
        }
        private static ValidateBufferArguments(buffer: number[], offset: number, count: number) {
            throw new Error("not yet implemented");
        }
        private static ValidateReadAtLeastArguments(bufferLength: number, minimumBytes: number) {
            throw new Error("not yet implemented");
        }
        private static ValidateCopyToArguments(destination: Stream, bufferSize: number) {
            throw new Error("not yet implemented");
        }
        private static __CopyToAsync__g__Core_27_0(source: Stream, destination: Stream, bufferSize: number, cancellationToken: CancellationToken): Task {
            throw new Error("not yet implemented");
        }
        private static __ReadAsync__g__FinishReadAsync_42_0(readTask: Task<number>, localBuffer: number[], localDestination: Memory<number>): ValueTask<number> {
            throw new Error("not yet implemented");
        }
    }
    export namespace Stream {
        export class ReadWriteParameters extends ValueType {
            private Buffer: number[];
            private Offset: number;
            private Count: number;

        }

        export class ReadWriteTask extends Task<number> implements IAsyncResult, IDisposable, ITaskCompletionAction {
            private static s_invokeAsyncCallback: ContextCallback;

            private _isRead: boolean;
            private _apm: boolean;
            private _endCalled: boolean;
            private _stream: Stream;
            private _buffer: number[];
            private _offset: number;
            private _count: number;
            private _callback: AsyncCallback;
            private _context: ExecutionContext;

            private get __explicit__ITaskCompletionAction_InvokeMayRunArbitraryCode(): boolean {
                throw new Error("not yet implemented");
            }
            public get InvokeMayRunArbitraryCode(): boolean {
                throw new Error("Invalid call (use ExplicitAs property)");
            }

            public constructor(isRead: boolean, apm: boolean, function: Func<any, number>, state: any, stream: Stream, buffer: number[], offset: number, count: number, callback: AsyncCallback) {
                throw new Error("not yet implemented");
            }

            private ClearBeginState() {
                throw new Error("not yet implemented");
            }
            private static InvokeAsyncCallback(completedTask: any) {
                throw new Error("not yet implemented");
            }
            private __explicit__ITaskCompletionAction_Invoke(completingTask: Task) {
                throw new Error("not yet implemented");
            }
            public Invoke(completingTask: Task) {
                throw new Error("Invalid call (use ExplicitAs property)");
            }

            public readonly ExplicitAsIAsyncResult: IAsyncResult = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'InvokeMayRunArbitraryCode') {
                        return target.__explicit__ITaskCompletionAction_InvokeMayRunArbitraryCode;
                    }
            
                    if (prop === 'Invoke') {
                        return target.__explicit__ITaskCompletionAction_Invoke.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
            public readonly ExplicitAsIDisposable: IDisposable = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'InvokeMayRunArbitraryCode') {
                        return target.__explicit__ITaskCompletionAction_InvokeMayRunArbitraryCode;
                    }
            
                    if (prop === 'Invoke') {
                        return target.__explicit__ITaskCompletionAction_Invoke.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
            public readonly ExplicitAsITaskCompletionAction: ITaskCompletionAction = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'InvokeMayRunArbitraryCode') {
                        return target.__explicit__ITaskCompletionAction_InvokeMayRunArbitraryCode;
                    }
            
                    if (prop === 'Invoke') {
                        return target.__explicit__ITaskCompletionAction_Invoke.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
        }
        export namespace ReadWriteTask {
            export class ____O {
                public static __0____InvokeAsyncCallback: ContextCallback;

            }
        }

        export class NullStream extends Stream implements IDisposable, IAsyncDisposable {
            public get CanRead(): boolean {
                throw new Error("not yet implemented");
            }
            public get CanWrite(): boolean {
                throw new Error("not yet implemented");
            }
            public get CanSeek(): boolean {
                throw new Error("not yet implemented");
            }
            public get Length(): number {
                throw new Error("not yet implemented");
            }
            public get Position(): number {
                throw new Error("not yet implemented");
            }
            public set Position(value: number) {
                throw new Error("not yet implemented");
            }

            protected constructor() {
                throw new Error("not yet implemented");
            }

            public CopyTo(destination: Stream, bufferSize: number) {
                throw new Error("not yet implemented");
            }
            public CopyToAsync(destination: Stream, bufferSize: number, cancellationToken: CancellationToken): Task {
                throw new Error("not yet implemented");
            }
            private Dispose(disposing: boolean) {
                throw new Error("not yet implemented");
            }
            public Flush() {
                throw new Error("not yet implemented");
            }
            public FlushAsync(cancellationToken: CancellationToken): Task {
                throw new Error("not yet implemented");
            }
            public BeginRead(buffer: number[], offset: number, count: number, callback: AsyncCallback, state: any): IAsyncResult {
                throw new Error("not yet implemented");
            }
            public EndRead(asyncResult: IAsyncResult): number {
                throw new Error("not yet implemented");
            }
            public BeginWrite(buffer: number[], offset: number, count: number, callback: AsyncCallback, state: any): IAsyncResult {
                throw new Error("not yet implemented");
            }
            public EndWrite(asyncResult: IAsyncResult) {
                throw new Error("not yet implemented");
            }
            public Read(buffer: number[], offset: number, count: number): number {
                throw new Error("not yet implemented");
            }
            public Read(buffer: Span<number>): number {
                throw new Error("not yet implemented");
            }
            public ReadAsync(buffer: number[], offset: number, count: number, cancellationToken: CancellationToken): Task<number> {
                throw new Error("not yet implemented");
            }
            public ReadAsync(buffer: Memory<number>, cancellationToken: CancellationToken): ValueTask<number> {
                throw new Error("not yet implemented");
            }
            public ReadByte(): number {
                throw new Error("not yet implemented");
            }
            public Write(buffer: number[], offset: number, count: number) {
                throw new Error("not yet implemented");
            }
            public Write(buffer: ReadOnlySpan<number>) {
                throw new Error("not yet implemented");
            }
            public WriteAsync(buffer: number[], offset: number, count: number, cancellationToken: CancellationToken): Task {
                throw new Error("not yet implemented");
            }
            public WriteAsync(buffer: ReadOnlyMemory<number>, cancellationToken: CancellationToken): ValueTask {
                throw new Error("not yet implemented");
            }
            public WriteByte(value: number) {
                throw new Error("not yet implemented");
            }
            public Seek(offset: number, origin: SeekOrigin): number {
                throw new Error("not yet implemented");
            }
            public SetLength(length: number) {
                throw new Error("not yet implemented");
            }
        }

        export class SyncStream extends Stream implements IDisposable, IAsyncDisposable {
            private _stream: Stream;

            public get CanRead(): boolean {
                throw new Error("not yet implemented");
            }
            public get CanWrite(): boolean {
                throw new Error("not yet implemented");
            }
            public get CanSeek(): boolean {
                throw new Error("not yet implemented");
            }
            public get CanTimeout(): boolean {
                throw new Error("not yet implemented");
            }
            public get Length(): number {
                throw new Error("not yet implemented");
            }
            public get Position(): number {
                throw new Error("not yet implemented");
            }
            public set Position(value: number) {
                throw new Error("not yet implemented");
            }
            public get ReadTimeout(): number {
                throw new Error("not yet implemented");
            }
            public set ReadTimeout(value: number) {
                throw new Error("not yet implemented");
            }
            public get WriteTimeout(): number {
                throw new Error("not yet implemented");
            }
            public set WriteTimeout(value: number) {
                throw new Error("not yet implemented");
            }

            protected constructor(stream: Stream) {
                throw new Error("not yet implemented");
            }

            public Close() {
                throw new Error("not yet implemented");
            }
            private Dispose(disposing: boolean) {
                throw new Error("not yet implemented");
            }
            public DisposeAsync(): ValueTask {
                throw new Error("not yet implemented");
            }
            public Flush() {
                throw new Error("not yet implemented");
            }
            public Read(bytes: number[], offset: number, count: number): number {
                throw new Error("not yet implemented");
            }
            public Read(buffer: Span<number>): number {
                throw new Error("not yet implemented");
            }
            public ReadByte(): number {
                throw new Error("not yet implemented");
            }
            public BeginRead(buffer: number[], offset: number, count: number, callback: AsyncCallback, state: any): IAsyncResult {
                throw new Error("not yet implemented");
            }
            public EndRead(asyncResult: IAsyncResult): number {
                throw new Error("not yet implemented");
            }
            public Seek(offset: number, origin: SeekOrigin): number {
                throw new Error("not yet implemented");
            }
            public SetLength(length: number) {
                throw new Error("not yet implemented");
            }
            public Write(bytes: number[], offset: number, count: number) {
                throw new Error("not yet implemented");
            }
            public Write(buffer: ReadOnlySpan<number>) {
                throw new Error("not yet implemented");
            }
            public WriteByte(b: number) {
                throw new Error("not yet implemented");
            }
            public BeginWrite(buffer: number[], offset: number, count: number, callback: AsyncCallback, state: any): IAsyncResult {
                throw new Error("not yet implemented");
            }
            public EndWrite(asyncResult: IAsyncResult) {
                throw new Error("not yet implemented");
            }
        }

        export class ____CopyToAsync__g__Core_27_0__d extends ValueType implements IAsyncStateMachine {
            public ____1__state: number;
            public ____t__builder: AsyncTaskMethodBuilder;
            public bufferSize: number;
            public destination: Stream;
            public cancellationToken: CancellationToken;
            public source: Stream;
            private __buffer__5__2: number[];
            private ____u__1: ConfiguredValueTaskAwaiter;
            private ____u__2: ConfiguredValueTaskAwaiter;

            private __explicit__MoveNext() {
                throw new Error("not yet implemented");
            }
            private __explicit__SetStateMachine(stateMachine: IAsyncStateMachine) {
                throw new Error("not yet implemented");
            }
        }

        export class ____ReadAsync__g__FinishReadAsync_42_0__d extends ValueType implements IAsyncStateMachine {
            public ____1__state: number;
            public ____t__builder: AsyncValueTaskMethodBuilder<number>;
            public readTask: Task<number>;
            public localBuffer: number[];
            public localDestination: Memory<number>;
            private ____u__1: ConfiguredTaskAwaiter;

            private __explicit__MoveNext() {
                throw new Error("not yet implemented");
            }
            private __explicit__SetStateMachine(stateMachine: IAsyncStateMachine) {
                throw new Error("not yet implemented");
            }
        }

        export class ____c {
            public static readonly ____9: ____c;
            public static ____9__35_0: Action<any>;
            public static ____9__38_0: Func<any, number>;
            public static ____9__49_0: Func<Stream, ReadWriteParameters, AsyncCallback, any, IAsyncResult>;
            public static ____9__49_1: Func<Stream, IAsyncResult, number>;
            public static ____9__52_0: Func<any, number>;
            public static ____9__53_0: Action<Task, any>;
            public static ____9__62_0: Func<Stream, ReadWriteParameters, AsyncCallback, any, IAsyncResult>;
            public static ____9__62_1: Func<Stream, IAsyncResult, VoidTaskResult>;

            private static staticctor_initialize = (() => {
                throw new Error("not yet implemented");
            })();
            private constructor() { }
            public constructor() {
                throw new Error("not yet implemented");
            }

            private __FlushAsync__b__35_0(state: any) {
                throw new Error("not yet implemented");
            }
            private __BeginReadInternal__b__38_0(__p0__: any): number {
                throw new Error("not yet implemented");
            }
            private __BeginEndReadAsync__b__49_0(stream: Stream, args: ReadWriteParameters, callback: AsyncCallback, state: any): IAsyncResult {
                throw new Error("not yet implemented");
            }
            private __BeginEndReadAsync__b__49_1(stream: Stream, asyncResult: IAsyncResult): number {
                throw new Error("not yet implemented");
            }
            private __BeginWriteInternal__b__52_0(__p0__: any): number {
                throw new Error("not yet implemented");
            }
            private __RunReadWriteTaskWhenReady__b__53_0(t: Task, state: any) {
                throw new Error("not yet implemented");
            }
            private __BeginEndWriteAsync__b__62_0(stream: Stream, args: ReadWriteParameters, callback: AsyncCallback, state: any): IAsyncResult {
                throw new Error("not yet implemented");
            }
            private __BeginEndWriteAsync__b__62_1(stream: Stream, asyncResult: IAsyncResult): VoidTaskResult {
                throw new Error("not yet implemented");
            }
        }

        export class __FinishWriteAsync__d__61 extends ValueType implements IAsyncStateMachine {
            public ____1__state: number;
            public ____t__builder: AsyncTaskMethodBuilder;
            public writeTask: Task;
            public localBuffer: number[];
            private ____u__1: ConfiguredTaskAwaiter;

            private __explicit__MoveNext() {
                throw new Error("not yet implemented");
            }
            private __explicit__SetStateMachine(stateMachine: IAsyncStateMachine) {
                throw new Error("not yet implemented");
            }
        }

        export class __ReadAtLeastAsyncCore__d__46 extends ValueType implements IAsyncStateMachine {
            public ____1__state: number;
            public ____t__builder: PoolingAsyncValueTaskMethodBuilder<number>;
            public ____4__this: Stream;
            public buffer: Memory<number>;
            public cancellationToken: CancellationToken;
            public throwOnEndOfStream: boolean;
            public minimumBytes: number;
            private __totalRead__5__2: number;
            private ____u__1: ConfiguredValueTaskAwaiter;

            private __explicit__MoveNext() {
                throw new Error("not yet implemented");
            }
            private __explicit__SetStateMachine(stateMachine: IAsyncStateMachine) {
                throw new Error("not yet implemented");
            }
        }
    }
    export enum FileOptions {
        None = 0x0,
        Encrypted = 0x4000,
        DeleteOnClose = 0x4000000,
        SequentialScan = 0x8000000,
        RandomAccess = 0x10000000,
        Asynchronous = 0x40000000,
        WriteThrough = 0x80000000,
    }
    export enum FileAccess {
        Read = 0x1,
        Write = 0x2,
        ReadWrite = 0x3,
    }
    export enum FileMode {
        CreateNew = 1,
        Create = 2,
        Open = 3,
        OpenOrCreate = 4,
        Truncate = 5,
        Append = 6,
    }
    export enum FileShare {
        None = 0x0,
        Read = 0x1,
        Write = 0x2,
        ReadWrite = 0x3,
        Delete = 0x4,
        Inheritable = 0x10,
    }
    export class FileStreamOptions {
        private _mode: FileMode;
        private _access: FileAccess;
        private _share: FileShare;
        private _options: FileOptions;
        private _preallocationSize: number;
        private _bufferSize: number;
        private _unixCreateMode: Nullable<UnixFileMode>;

        public get Mode(): FileMode {
            throw new Error("not yet implemented");
        }
        public set Mode(value: FileMode) {
            throw new Error("not yet implemented");
        }
        public get Access(): FileAccess {
            throw new Error("not yet implemented");
        }
        public set Access(value: FileAccess) {
            throw new Error("not yet implemented");
        }
        public get Share(): FileShare {
            throw new Error("not yet implemented");
        }
        public set Share(value: FileShare) {
            throw new Error("not yet implemented");
        }
        public get Options(): FileOptions {
            throw new Error("not yet implemented");
        }
        public set Options(value: FileOptions) {
            throw new Error("not yet implemented");
        }
        public get PreallocationSize(): number {
            throw new Error("not yet implemented");
        }
        public set PreallocationSize(value: number) {
            throw new Error("not yet implemented");
        }
        public get BufferSize(): number {
            throw new Error("not yet implemented");
        }
        public set BufferSize(value: number) {
            throw new Error("not yet implemented");
        }
        public get UnixCreateMode(): Nullable<UnixFileMode> {
            throw new Error("not yet implemented");
        }
        public set UnixCreateMode(value: Nullable<UnixFileMode>) {
            throw new Error("not yet implemented");
        }

        public constructor() {
            throw new Error("not yet implemented");
        }

    }
    export class FileStream extends Stream implements IDisposable, IAsyncDisposable {
        private _strategy: FileStreamStrategy;

        public get Handle(): number {
            throw new Error("not yet implemented");
        }
        public get CanRead(): boolean {
            throw new Error("not yet implemented");
        }
        public get CanWrite(): boolean {
            throw new Error("not yet implemented");
        }
        public get SafeFileHandle(): SafeFileHandle {
            throw new Error("not yet implemented");
        }
        public get Name(): string {
            throw new Error("not yet implemented");
        }
        public get IsAsync(): boolean {
            throw new Error("not yet implemented");
        }
        public get Length(): number {
            throw new Error("not yet implemented");
        }
        public get Position(): number {
            throw new Error("not yet implemented");
        }
        public set Position(value: number) {
            throw new Error("not yet implemented");
        }
        public get CanSeek(): boolean {
            throw new Error("not yet implemented");
        }

        public constructor(handle: number, access: FileAccess) {
            throw new Error("not yet implemented");
        }
        public constructor(handle: number, access: FileAccess, ownsHandle: boolean) {
            throw new Error("not yet implemented");
        }
        public constructor(handle: number, access: FileAccess, ownsHandle: boolean, bufferSize: number) {
            throw new Error("not yet implemented");
        }
        public constructor(handle: number, access: FileAccess, ownsHandle: boolean, bufferSize: number, isAsync: boolean) {
            throw new Error("not yet implemented");
        }
        public constructor(handle: SafeFileHandle, access: FileAccess) {
            throw new Error("not yet implemented");
        }
        public constructor(handle: SafeFileHandle, access: FileAccess, bufferSize: number) {
            throw new Error("not yet implemented");
        }
        public constructor(handle: SafeFileHandle, access: FileAccess, bufferSize: number, isAsync: boolean) {
            throw new Error("not yet implemented");
        }
        public constructor(path: string, mode: FileMode) {
            throw new Error("not yet implemented");
        }
        public constructor(path: string, mode: FileMode, access: FileAccess) {
            throw new Error("not yet implemented");
        }
        public constructor(path: string, mode: FileMode, access: FileAccess, share: FileShare) {
            throw new Error("not yet implemented");
        }
        public constructor(path: string, mode: FileMode, access: FileAccess, share: FileShare, bufferSize: number) {
            throw new Error("not yet implemented");
        }
        public constructor(path: string, mode: FileMode, access: FileAccess, share: FileShare, bufferSize: number, useAsync: boolean) {
            throw new Error("not yet implemented");
        }
        public constructor(path: string, mode: FileMode, access: FileAccess, share: FileShare, bufferSize: number, options: FileOptions) {
            throw new Error("not yet implemented");
        }
        public constructor(path: string, options: FileStreamOptions) {
            throw new Error("not yet implemented");
        }
        private constructor(path: string, mode: FileMode, access: FileAccess, share: FileShare, bufferSize: number, options: FileOptions, preallocationSize: number) {
            throw new Error("not yet implemented");
        }

        private static ValidateHandle(handle: SafeFileHandle, access: FileAccess, bufferSize: number) {
            throw new Error("not yet implemented");
        }
        private static ValidateHandle(handle: SafeFileHandle, access: FileAccess, bufferSize: number, isAsync: boolean) {
            throw new Error("not yet implemented");
        }
        private Finalize() {
            throw new Error("not yet implemented");
        }
        public Lock(position: number, length: number) {
            throw new Error("not yet implemented");
        }
        public Unlock(position: number, length: number) {
            throw new Error("not yet implemented");
        }
        public FlushAsync(cancellationToken: CancellationToken): Task {
            throw new Error("not yet implemented");
        }
        public Read(buffer: number[], offset: number, count: number): number {
            throw new Error("not yet implemented");
        }
        public Read(buffer: Span<number>): number {
            throw new Error("not yet implemented");
        }
        public ReadAsync(buffer: number[], offset: number, count: number, cancellationToken: CancellationToken): Task<number> {
            throw new Error("not yet implemented");
        }
        public ReadAsync(buffer: Memory<number>, cancellationToken: CancellationToken): ValueTask<number> {
            throw new Error("not yet implemented");
        }
        public Write(buffer: number[], offset: number, count: number) {
            throw new Error("not yet implemented");
        }
        public Write(buffer: ReadOnlySpan<number>) {
            throw new Error("not yet implemented");
        }
        public WriteAsync(buffer: number[], offset: number, count: number, cancellationToken: CancellationToken): Task {
            throw new Error("not yet implemented");
        }
        public WriteAsync(buffer: ReadOnlyMemory<number>, cancellationToken: CancellationToken): ValueTask {
            throw new Error("not yet implemented");
        }
        public Flush() {
            throw new Error("not yet implemented");
        }
        public Flush(flushToDisk: boolean) {
            throw new Error("not yet implemented");
        }
        private ValidateReadWriteArgs(buffer: number[], offset: number, count: number) {
            throw new Error("not yet implemented");
        }
        public SetLength(value: number) {
            throw new Error("not yet implemented");
        }
        public ReadByte(): number {
            throw new Error("not yet implemented");
        }
        public WriteByte(value: number) {
            throw new Error("not yet implemented");
        }
        private Dispose(disposing: boolean) {
            throw new Error("not yet implemented");
        }
        public DisposeAsync(): ValueTask {
            throw new Error("not yet implemented");
        }
        public CopyTo(destination: Stream, bufferSize: number) {
            throw new Error("not yet implemented");
        }
        public CopyToAsync(destination: Stream, bufferSize: number, cancellationToken: CancellationToken): Task {
            throw new Error("not yet implemented");
        }
        public BeginRead(buffer: number[], offset: number, count: number, callback: AsyncCallback, state: any): IAsyncResult {
            throw new Error("not yet implemented");
        }
        public EndRead(asyncResult: IAsyncResult): number {
            throw new Error("not yet implemented");
        }
        public BeginWrite(buffer: number[], offset: number, count: number, callback: AsyncCallback, state: any): IAsyncResult {
            throw new Error("not yet implemented");
        }
        public EndWrite(asyncResult: IAsyncResult) {
            throw new Error("not yet implemented");
        }
        public Seek(offset: number, origin: SeekOrigin): number {
            throw new Error("not yet implemented");
        }
        private BaseFlushAsync(cancellationToken: CancellationToken): Task {
            throw new Error("not yet implemented");
        }
        private BaseRead(buffer: Span<number>): number {
            throw new Error("not yet implemented");
        }
        private BaseReadAsync(buffer: number[], offset: number, count: number, cancellationToken: CancellationToken): Task<number> {
            throw new Error("not yet implemented");
        }
        private BaseReadAsync(buffer: Memory<number>, cancellationToken: CancellationToken): ValueTask<number> {
            throw new Error("not yet implemented");
        }
        private BaseWrite(buffer: ReadOnlySpan<number>) {
            throw new Error("not yet implemented");
        }
        private BaseWriteAsync(buffer: number[], offset: number, count: number, cancellationToken: CancellationToken): Task {
            throw new Error("not yet implemented");
        }
        private BaseWriteAsync(buffer: ReadOnlyMemory<number>, cancellationToken: CancellationToken): ValueTask {
            throw new Error("not yet implemented");
        }
        private BaseDisposeAsync(): ValueTask {
            throw new Error("not yet implemented");
        }
        private BaseCopyToAsync(destination: Stream, bufferSize: number, cancellationToken: CancellationToken): Task {
            throw new Error("not yet implemented");
        }
        private BaseBeginRead(buffer: number[], offset: number, count: number, callback: AsyncCallback, state: any): IAsyncResult {
            throw new Error("not yet implemented");
        }
        private BaseEndRead(asyncResult: IAsyncResult): number {
            throw new Error("not yet implemented");
        }
        private BaseBeginWrite(buffer: number[], offset: number, count: number, callback: AsyncCallback, state: any): IAsyncResult {
            throw new Error("not yet implemented");
        }
        private BaseEndWrite(asyncResult: IAsyncResult) {
            throw new Error("not yet implemented");
        }
    }
    export namespace FileStream {
        export class __DisposeAsync__d__57 extends ValueType implements IAsyncStateMachine {
            public ____1__state: number;
            public ____t__builder: AsyncValueTaskMethodBuilder;
            public ____4__this: FileStream;
            private ____u__1: ConfiguredValueTaskAwaiter;

            private __explicit__MoveNext() {
                throw new Error("not yet implemented");
            }
            private __explicit__SetStateMachine(stateMachine: IAsyncStateMachine) {
                throw new Error("not yet implemented");
            }
        }
    }
    export class BinaryWriter implements IDisposable, IAsyncDisposable {
        public static readonly Null: BinaryWriter;

        private OutStream: Stream;
        private _encoding: Encoding;
        private _leaveOpen: boolean;
        private _useFastUtf8: boolean;

        public get BaseStream(): Stream {
            throw new Error("not yet implemented");
        }

        protected constructor() {
            throw new Error("not yet implemented");
        }
        public constructor(output: Stream) {
            throw new Error("not yet implemented");
        }
        public constructor(output: Stream, encoding: Encoding) {
            throw new Error("not yet implemented");
        }
        public constructor(output: Stream, encoding: Encoding, leaveOpen: boolean) {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

        public Close() {
            throw new Error("not yet implemented");
        }
        private Dispose(disposing: boolean) {
            throw new Error("not yet implemented");
        }
        public Dispose() {
            throw new Error("not yet implemented");
        }
        public DisposeAsync(): ValueTask {
            throw new Error("not yet implemented");
        }
        public Flush() {
            throw new Error("not yet implemented");
        }
        public Seek(offset: number, origin: SeekOrigin): number {
            throw new Error("not yet implemented");
        }
        public Write(value: boolean) {
            throw new Error("not yet implemented");
        }
        public Write(value: number) {
            throw new Error("not yet implemented");
        }
        public Write(value: number) {
            throw new Error("not yet implemented");
        }
        public Write(buffer: number[]) {
            throw new Error("not yet implemented");
        }
        public Write(buffer: number[], index: number, count: number) {
            throw new Error("not yet implemented");
        }
        public Write(ch: string) {
            throw new Error("not yet implemented");
        }
        public Write(chars: string[]) {
            throw new Error("not yet implemented");
        }
        public Write(chars: string[], index: number, count: number) {
            throw new Error("not yet implemented");
        }
        public Write(value: number) {
            throw new Error("not yet implemented");
        }
        public Write(value: number) {
            throw new Error("not yet implemented");
        }
        public Write(value: number) {
            throw new Error("not yet implemented");
        }
        public Write(value: number) {
            throw new Error("not yet implemented");
        }
        public Write(value: number) {
            throw new Error("not yet implemented");
        }
        public Write(value: number) {
            throw new Error("not yet implemented");
        }
        public Write(value: number) {
            throw new Error("not yet implemented");
        }
        public Write(value: number) {
            throw new Error("not yet implemented");
        }
        public Write(value: number) {
            throw new Error("not yet implemented");
        }
        public Write(value: Half) {
            throw new Error("not yet implemented");
        }
        public Write(value: string) {
            throw new Error("not yet implemented");
        }
        public Write(buffer: ReadOnlySpan<number>) {
            throw new Error("not yet implemented");
        }
        public Write(chars: ReadOnlySpan<string>) {
            throw new Error("not yet implemented");
        }
        private WriteCharsCommonWithoutLengthPrefix(chars: ReadOnlySpan<string>, useThisWriteOverride: boolean) {
            throw new Error("not yet implemented");
        }
        public Write7BitEncodedInt(value: number) {
            throw new Error("not yet implemented");
        }
        public Write7BitEncodedInt64(value: number) {
            throw new Error("not yet implemented");
        }
        private __WriteCharsCommonWithoutLengthPrefix__g__WriteToOutStream_39_0(buffer: number[], offset: number, count: number, useThisWriteOverride: boolean) {
            throw new Error("not yet implemented");
        }
    }
}
export namespace System.IO.Strategies {
    export abstract class OSFileStreamStrategy extends FileStreamStrategy implements IDisposable, IAsyncDisposable {
        private _fileHandle: SafeFileHandle;
        private _access: FileAccess;
        private _filePosition: number;
        private _appendStart: number;

        private get IsAsync(): boolean {
            throw new Error("not yet implemented");
        }
        public get CanSeek(): boolean {
            throw new Error("not yet implemented");
        }
        public get CanRead(): boolean {
            throw new Error("not yet implemented");
        }
        public get CanWrite(): boolean {
            throw new Error("not yet implemented");
        }
        public get Length(): number {
            throw new Error("not yet implemented");
        }
        public get Position(): number {
            throw new Error("not yet implemented");
        }
        public set Position(value: number) {
            throw new Error("not yet implemented");
        }
        private get Name(): string {
            throw new Error("not yet implemented");
        }
        private get IsClosed(): boolean {
            throw new Error("not yet implemented");
        }
        private get SafeFileHandle(): SafeFileHandle {
            throw new Error("not yet implemented");
        }

        protected constructor(handle: SafeFileHandle, access: FileAccess) {
            throw new Error("not yet implemented");
        }
        protected constructor(path: string, mode: FileMode, access: FileAccess, share: FileShare, options: FileOptions, preallocationSize: number, unixCreateMode: Nullable<UnixFileMode>) {
            throw new Error("not yet implemented");
        }

        private OnIncompleteOperation(expectedBytesTransferred: number, actualBytesTransferred: number) {
            throw new Error("not yet implemented");
        }
        public DisposeAsync(): ValueTask {
            throw new Error("not yet implemented");
        }
        private Dispose(disposing: boolean) {
            throw new Error("not yet implemented");
        }
        public Flush() {
            throw new Error("not yet implemented");
        }
        public FlushAsync(cancellationToken: CancellationToken): Task {
            throw new Error("not yet implemented");
        }
        private Flush(flushToDisk: boolean) {
            throw new Error("not yet implemented");
        }
        public Seek(offset: number, origin: SeekOrigin): number {
            throw new Error("not yet implemented");
        }
        private Lock(position: number, length: number) {
            throw new Error("not yet implemented");
        }
        private Unlock(position: number, length: number) {
            throw new Error("not yet implemented");
        }
        public SetLength(value: number) {
            throw new Error("not yet implemented");
        }
        private SetLengthCore(value: number) {
            throw new Error("not yet implemented");
        }
        public ReadByte(): number {
            throw new Error("not yet implemented");
        }
        public Read(buffer: number[], offset: number, count: number): number {
            throw new Error("not yet implemented");
        }
        public Read(buffer: Span<number>): number {
            throw new Error("not yet implemented");
        }
        public WriteByte(value: number) {
            throw new Error("not yet implemented");
        }
        public Write(buffer: number[], offset: number, count: number) {
            throw new Error("not yet implemented");
        }
        public Write(buffer: ReadOnlySpan<number>) {
            throw new Error("not yet implemented");
        }
        public BeginWrite(buffer: number[], offset: number, count: number, callback: AsyncCallback, state: any): IAsyncResult {
            throw new Error("not yet implemented");
        }
        public EndWrite(asyncResult: IAsyncResult) {
            throw new Error("not yet implemented");
        }
        public WriteAsync(buffer: number[], offset: number, count: number, cancellationToken: CancellationToken): Task {
            throw new Error("not yet implemented");
        }
        public WriteAsync(source: ReadOnlyMemory<number>, cancellationToken: CancellationToken): ValueTask {
            throw new Error("not yet implemented");
        }
        public BeginRead(buffer: number[], offset: number, count: number, callback: AsyncCallback, state: any): IAsyncResult {
            throw new Error("not yet implemented");
        }
        public EndRead(asyncResult: IAsyncResult): number {
            throw new Error("not yet implemented");
        }
        public ReadAsync(buffer: number[], offset: number, count: number, cancellationToken: CancellationToken): Task<number> {
            throw new Error("not yet implemented");
        }
        public ReadAsync(destination: Memory<number>, cancellationToken: CancellationToken): ValueTask<number> {
            throw new Error("not yet implemented");
        }
    }
    export abstract class FileStreamStrategy extends Stream implements IDisposable, IAsyncDisposable {
        private __IsDerived__k__BackingField: boolean;

        private get IsAsync(): boolean;
        private get IsDerived(): boolean {
            throw new Error("not yet implemented");
        }
        private set IsDerived(value: boolean) {
            throw new Error("not yet implemented");
        }
        private get Name(): string;
        private get SafeFileHandle(): SafeFileHandle;
        private get Handle(): number {
            throw new Error("not yet implemented");
        }
        private get IsClosed(): boolean;

        protected constructor() {
            throw new Error("not yet implemented");
        }

        private Lock(position: number, length: number): void;
        private Unlock(position: number, length: number): void;
        private Flush(flushToDisk: boolean): void;
        private DisposeInternal(disposing: boolean) {
            throw new Error("not yet implemented");
        }
    }
}
export namespace System.Numerics {
    export interface IBitwiseOperators<TSelf, TOther, TResult> {
    }
    export interface IEqualityOperators<TSelf, TOther, TResult> {
    }
    export interface IComparisonOperators<TSelf, TOther, TResult> implements IEqualityOperators<TSelf, TOther, TResult> {
    }
    export interface IModulusOperators<TSelf, TOther, TResult> {
    }
    export interface IAdditionOperators<TSelf, TOther, TResult> {
    }
    export interface IAdditiveIdentity<TSelf, TResult> {
    }
    export interface IDecrementOperators<TSelf> {
    }
    export interface IDivisionOperators<TSelf, TOther, TResult> {
    }
    export interface IIncrementOperators<TSelf> {
    }
    export interface IMultiplicativeIdentity<TSelf, TResult> {
    }
    export interface IMultiplyOperators<TSelf, TOther, TResult> {
    }
    export interface ISubtractionOperators<TSelf, TOther, TResult> {
    }
    export interface IUnaryPlusOperators<TSelf, TResult> {
    }
    export interface IUnaryNegationOperators<TSelf, TResult> {
    }
    export interface INumberBase<TSelf> implements IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEquatable<TSelf>, IEqualityOperators<TSelf, TSelf, boolean>, IIncrementOperators<TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable<TSelf>, IParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable<TSelf> {
        static Abs(value: TSelf): TSelf;
        static CreateChecked(value: TOther): TSelf {
            throw new Error("not yet implemented");
        }
        static CreateSaturating(value: TOther): TSelf {
            throw new Error("not yet implemented");
        }
        static CreateTruncating(value: TOther): TSelf {
            throw new Error("not yet implemented");
        }
        static IsCanonical(value: TSelf): boolean;
        static IsComplexNumber(value: TSelf): boolean;
        static IsEvenInteger(value: TSelf): boolean;
        static IsFinite(value: TSelf): boolean;
        static IsImaginaryNumber(value: TSelf): boolean;
        static IsInfinity(value: TSelf): boolean;
        static IsInteger(value: TSelf): boolean;
        static IsNaN(value: TSelf): boolean;
        static IsNegative(value: TSelf): boolean;
        static IsNegativeInfinity(value: TSelf): boolean;
        static IsNormal(value: TSelf): boolean;
        static IsOddInteger(value: TSelf): boolean;
        static IsPositive(value: TSelf): boolean;
        static IsPositiveInfinity(value: TSelf): boolean;
        static IsRealNumber(value: TSelf): boolean;
        static IsSubnormal(value: TSelf): boolean;
        static IsZero(value: TSelf): boolean;
        static MaxMagnitude(x: TSelf, y: TSelf): TSelf;
        static MaxMagnitudeNumber(x: TSelf, y: TSelf): TSelf;
        static MinMagnitude(x: TSelf, y: TSelf): TSelf;
        static MinMagnitudeNumber(x: TSelf, y: TSelf): TSelf;
        static Parse(s: string, style: NumberStyles, provider: IFormatProvider): TSelf;
        static Parse(s: ReadOnlySpan<string>, style: NumberStyles, provider: IFormatProvider): TSelf;
        static Parse(utf8Text: ReadOnlySpan<number>, style: NumberStyles, provider: IFormatProvider): TSelf {
            throw new Error("not yet implemented");
        }
        static TryConvertFromChecked(value: TOther, out result: TSelf): boolean;
        static TryConvertFromSaturating(value: TOther, out result: TSelf): boolean;
        static TryConvertFromTruncating(value: TOther, out result: TSelf): boolean;
        static TryConvertToChecked(value: TSelf, out result: TOther): boolean;
        static TryConvertToSaturating(value: TSelf, out result: TOther): boolean;
        static TryConvertToTruncating(value: TSelf, out result: TOther): boolean;
        static TryParse(s: string, style: NumberStyles, provider: IFormatProvider, out result: TSelf): boolean;
        static TryParse(s: ReadOnlySpan<string>, style: NumberStyles, provider: IFormatProvider, out result: TSelf): boolean;
        static TryParse(utf8Text: ReadOnlySpan<number>, style: NumberStyles, provider: IFormatProvider, out result: TSelf): boolean {
            throw new Error("not yet implemented");
        }
        __explicit__IUtf8SpanFormattable_TryFormat(utf8Destination: Span<number>, out bytesWritten: number, format: ReadOnlySpan<string>, provider: IFormatProvider): boolean {
            throw new Error("not yet implemented");
        }
        public TryFormat(utf8Destination: Span<number>, out bytesWritten: number, format: ReadOnlySpan<string>, provider: IFormatProvider): boolean {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        static System_IUtf8SpanParsable__TSelf___Parse(utf8Text: ReadOnlySpan<number>, provider: IFormatProvider): TSelf {
            throw new Error("not yet implemented");
        }
        static System_IUtf8SpanParsable__TSelf___TryParse(utf8Text: ReadOnlySpan<number>, provider: IFormatProvider, out result: TSelf): boolean {
            throw new Error("not yet implemented");
        }
    }
    export interface INumber<TSelf> implements IComparable, IComparable<TSelf>, IComparisonOperators<TSelf, TSelf, boolean>, IEqualityOperators<TSelf, TSelf, boolean>, IModulusOperators<TSelf, TSelf, TSelf>, INumberBase<TSelf>, IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEquatable<TSelf>, IIncrementOperators<TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable<TSelf>, IParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable<TSelf> {
        static Clamp(value: TSelf, min: TSelf, max: TSelf): TSelf {
            throw new Error("not yet implemented");
        }
        static CopySign(value: TSelf, sign: TSelf): TSelf {
            throw new Error("not yet implemented");
        }
        static Max(x: TSelf, y: TSelf): TSelf {
            throw new Error("not yet implemented");
        }
        static MaxNumber(x: TSelf, y: TSelf): TSelf {
            throw new Error("not yet implemented");
        }
        static Min(x: TSelf, y: TSelf): TSelf {
            throw new Error("not yet implemented");
        }
        static MinNumber(x: TSelf, y: TSelf): TSelf {
            throw new Error("not yet implemented");
        }
        static Sign(value: TSelf): number {
            throw new Error("not yet implemented");
        }
    }
    export interface IBinaryNumber<TSelf> implements IBitwiseOperators<TSelf, TSelf, TSelf>, INumber<TSelf>, IComparable, IComparable<TSelf>, IComparisonOperators<TSelf, TSelf, boolean>, IEqualityOperators<TSelf, TSelf, boolean>, IModulusOperators<TSelf, TSelf, TSelf>, INumberBase<TSelf>, IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEquatable<TSelf>, IIncrementOperators<TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable<TSelf>, IParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable<TSelf> {
        static IsPow2(value: TSelf): boolean;
        static Log2(value: TSelf): TSelf;
    }
    export interface IFloatingPointConstants<TSelf> implements INumberBase<TSelf>, IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEquatable<TSelf>, IEqualityOperators<TSelf, TSelf, boolean>, IIncrementOperators<TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable<TSelf>, IParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable<TSelf> {
    }
    export interface IExponentialFunctions<TSelf> implements IFloatingPointConstants<TSelf>, INumberBase<TSelf>, IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEquatable<TSelf>, IEqualityOperators<TSelf, TSelf, boolean>, IIncrementOperators<TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable<TSelf>, IParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable<TSelf> {
        static Exp(x: TSelf): TSelf;
        static ExpM1(x: TSelf): TSelf {
            throw new Error("not yet implemented");
        }
        static Exp2(x: TSelf): TSelf;
        static Exp2M1(x: TSelf): TSelf {
            throw new Error("not yet implemented");
        }
        static Exp10(x: TSelf): TSelf;
        static Exp10M1(x: TSelf): TSelf {
            throw new Error("not yet implemented");
        }
    }
    export interface ISignedNumber<TSelf> implements INumberBase<TSelf>, IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEquatable<TSelf>, IEqualityOperators<TSelf, TSelf, boolean>, IIncrementOperators<TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable<TSelf>, IParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable<TSelf> {
    }
    export interface IFloatingPoint<TSelf> implements IFloatingPointConstants<TSelf>, INumberBase<TSelf>, IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEquatable<TSelf>, IEqualityOperators<TSelf, TSelf, boolean>, IIncrementOperators<TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable<TSelf>, IParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable<TSelf>, INumber<TSelf>, IComparable, IComparable<TSelf>, IComparisonOperators<TSelf, TSelf, boolean>, IModulusOperators<TSelf, TSelf, TSelf>, ISignedNumber<TSelf> {
        static Ceiling(x: TSelf): TSelf {
            throw new Error("not yet implemented");
        }
        static Floor(x: TSelf): TSelf {
            throw new Error("not yet implemented");
        }
        static Round(x: TSelf): TSelf {
            throw new Error("not yet implemented");
        }
        static Round(x: TSelf, digits: number): TSelf {
            throw new Error("not yet implemented");
        }
        static Round(x: TSelf, mode: MidpointRounding): TSelf {
            throw new Error("not yet implemented");
        }
        static Round(x: TSelf, digits: number, mode: MidpointRounding): TSelf;
        static Truncate(x: TSelf): TSelf {
            throw new Error("not yet implemented");
        }
        GetExponentByteCount(): number;
        GetExponentShortestBitLength(): number;
        GetSignificandBitLength(): number;
        GetSignificandByteCount(): number;
        TryWriteExponentBigEndian(destination: Span<number>, out bytesWritten: number): boolean;
        TryWriteExponentLittleEndian(destination: Span<number>, out bytesWritten: number): boolean;
        TryWriteSignificandBigEndian(destination: Span<number>, out bytesWritten: number): boolean;
        TryWriteSignificandLittleEndian(destination: Span<number>, out bytesWritten: number): boolean;
        WriteExponentBigEndian(destination: number[]): number {
            throw new Error("not yet implemented");
        }
        WriteExponentBigEndian(destination: number[], startIndex: number): number {
            throw new Error("not yet implemented");
        }
        WriteExponentBigEndian(destination: Span<number>): number {
            throw new Error("not yet implemented");
        }
        WriteExponentLittleEndian(destination: number[]): number {
            throw new Error("not yet implemented");
        }
        WriteExponentLittleEndian(destination: number[], startIndex: number): number {
            throw new Error("not yet implemented");
        }
        WriteExponentLittleEndian(destination: Span<number>): number {
            throw new Error("not yet implemented");
        }
        WriteSignificandBigEndian(destination: number[]): number {
            throw new Error("not yet implemented");
        }
        WriteSignificandBigEndian(destination: number[], startIndex: number): number {
            throw new Error("not yet implemented");
        }
        WriteSignificandBigEndian(destination: Span<number>): number {
            throw new Error("not yet implemented");
        }
        WriteSignificandLittleEndian(destination: number[]): number {
            throw new Error("not yet implemented");
        }
        WriteSignificandLittleEndian(destination: number[], startIndex: number): number {
            throw new Error("not yet implemented");
        }
        WriteSignificandLittleEndian(destination: Span<number>): number {
            throw new Error("not yet implemented");
        }
    }
    export interface IHyperbolicFunctions<TSelf> implements IFloatingPointConstants<TSelf>, INumberBase<TSelf>, IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEquatable<TSelf>, IEqualityOperators<TSelf, TSelf, boolean>, IIncrementOperators<TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable<TSelf>, IParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable<TSelf> {
        static Acosh(x: TSelf): TSelf;
        static Asinh(x: TSelf): TSelf;
        static Atanh(x: TSelf): TSelf;
        static Cosh(x: TSelf): TSelf;
        static Sinh(x: TSelf): TSelf;
        static Tanh(x: TSelf): TSelf;
    }
    export interface ILogarithmicFunctions<TSelf> implements IFloatingPointConstants<TSelf>, INumberBase<TSelf>, IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEquatable<TSelf>, IEqualityOperators<TSelf, TSelf, boolean>, IIncrementOperators<TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable<TSelf>, IParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable<TSelf> {
        static Log(x: TSelf): TSelf;
        static Log(x: TSelf, newBase: TSelf): TSelf;
        static LogP1(x: TSelf): TSelf {
            throw new Error("not yet implemented");
        }
        static Log2(x: TSelf): TSelf;
        static Log2P1(x: TSelf): TSelf {
            throw new Error("not yet implemented");
        }
        static Log10(x: TSelf): TSelf;
        static Log10P1(x: TSelf): TSelf {
            throw new Error("not yet implemented");
        }
    }
    export interface IPowerFunctions<TSelf> implements INumberBase<TSelf>, IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEquatable<TSelf>, IEqualityOperators<TSelf, TSelf, boolean>, IIncrementOperators<TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable<TSelf>, IParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable<TSelf> {
        static Pow(x: TSelf, y: TSelf): TSelf;
    }
    export interface IRootFunctions<TSelf> implements IFloatingPointConstants<TSelf>, INumberBase<TSelf>, IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEquatable<TSelf>, IEqualityOperators<TSelf, TSelf, boolean>, IIncrementOperators<TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable<TSelf>, IParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable<TSelf> {
        static Cbrt(x: TSelf): TSelf;
        static Hypot(x: TSelf, y: TSelf): TSelf;
        static RootN(x: TSelf, n: number): TSelf;
        static Sqrt(x: TSelf): TSelf;
    }
    export interface ITrigonometricFunctions<TSelf> implements IFloatingPointConstants<TSelf>, INumberBase<TSelf>, IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEquatable<TSelf>, IEqualityOperators<TSelf, TSelf, boolean>, IIncrementOperators<TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable<TSelf>, IParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable<TSelf> {
        static Acos(x: TSelf): TSelf;
        static AcosPi(x: TSelf): TSelf;
        static Asin(x: TSelf): TSelf;
        static AsinPi(x: TSelf): TSelf;
        static Atan(x: TSelf): TSelf;
        static AtanPi(x: TSelf): TSelf;
        static Cos(x: TSelf): TSelf;
        static CosPi(x: TSelf): TSelf;
        static DegreesToRadians(degrees: TSelf): TSelf {
            throw new Error("not yet implemented");
        }
        static RadiansToDegrees(radians: TSelf): TSelf {
            throw new Error("not yet implemented");
        }
        static Sin(x: TSelf): TSelf;
        static SinCos(x: TSelf): ValueTuple<TSelf, TSelf>;
        static SinCosPi(x: TSelf): ValueTuple<TSelf, TSelf>;
        static SinPi(x: TSelf): TSelf;
        static Tan(x: TSelf): TSelf;
        static TanPi(x: TSelf): TSelf;
    }
    export interface IFloatingPointIeee754<TSelf> implements IExponentialFunctions<TSelf>, IFloatingPointConstants<TSelf>, INumberBase<TSelf>, IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEquatable<TSelf>, IEqualityOperators<TSelf, TSelf, boolean>, IIncrementOperators<TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable<TSelf>, IParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable<TSelf>, IFloatingPoint<TSelf>, INumber<TSelf>, IComparable, IComparable<TSelf>, IComparisonOperators<TSelf, TSelf, boolean>, IModulusOperators<TSelf, TSelf, TSelf>, ISignedNumber<TSelf>, IHyperbolicFunctions<TSelf>, ILogarithmicFunctions<TSelf>, IPowerFunctions<TSelf>, IRootFunctions<TSelf>, ITrigonometricFunctions<TSelf> {
        static Atan2(y: TSelf, x: TSelf): TSelf;
        static Atan2Pi(y: TSelf, x: TSelf): TSelf;
        static BitDecrement(x: TSelf): TSelf;
        static BitIncrement(x: TSelf): TSelf;
        static FusedMultiplyAdd(left: TSelf, right: TSelf, addend: TSelf): TSelf;
        static Ieee754Remainder(left: TSelf, right: TSelf): TSelf;
        static ILogB(x: TSelf): number;
        static Lerp(value1: TSelf, value2: TSelf, amount: TSelf): TSelf {
            throw new Error("not yet implemented");
        }
        static ReciprocalEstimate(x: TSelf): TSelf {
            throw new Error("not yet implemented");
        }
        static ReciprocalSqrtEstimate(x: TSelf): TSelf {
            throw new Error("not yet implemented");
        }
        static ScaleB(x: TSelf, n: number): TSelf;
    }
    export interface IBinaryFloatingPointIeee754<TSelf> implements IBinaryNumber<TSelf>, IBitwiseOperators<TSelf, TSelf, TSelf>, INumber<TSelf>, IComparable, IComparable<TSelf>, IComparisonOperators<TSelf, TSelf, boolean>, IEqualityOperators<TSelf, TSelf, boolean>, IModulusOperators<TSelf, TSelf, TSelf>, INumberBase<TSelf>, IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEquatable<TSelf>, IIncrementOperators<TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable<TSelf>, IParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable<TSelf>, IFloatingPointIeee754<TSelf>, IExponentialFunctions<TSelf>, IFloatingPointConstants<TSelf>, IFloatingPoint<TSelf>, ISignedNumber<TSelf>, IHyperbolicFunctions<TSelf>, ILogarithmicFunctions<TSelf>, IPowerFunctions<TSelf>, IRootFunctions<TSelf>, ITrigonometricFunctions<TSelf> {
    }
    export interface IMinMaxValue<TSelf> {
    }
    export interface IShiftOperators<TSelf, TOther, TResult> {
    }
    export interface IBinaryInteger<TSelf> implements IBinaryNumber<TSelf>, IBitwiseOperators<TSelf, TSelf, TSelf>, INumber<TSelf>, IComparable, IComparable<TSelf>, IComparisonOperators<TSelf, TSelf, boolean>, IEqualityOperators<TSelf, TSelf, boolean>, IModulusOperators<TSelf, TSelf, TSelf>, INumberBase<TSelf>, IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEquatable<TSelf>, IIncrementOperators<TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable<TSelf>, IParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable<TSelf>, IShiftOperators<TSelf, number, TSelf> {
        static DivRem(left: TSelf, right: TSelf): ValueTuple<TSelf, TSelf> {
            throw new Error("not yet implemented");
        }
        static LeadingZeroCount(value: TSelf): TSelf {
            throw new Error("not yet implemented");
        }
        static PopCount(value: TSelf): TSelf;
        static ReadBigEndian(source: number[], isUnsigned: boolean): TSelf {
            throw new Error("not yet implemented");
        }
        static ReadBigEndian(source: number[], startIndex: number, isUnsigned: boolean): TSelf {
            throw new Error("not yet implemented");
        }
        static ReadBigEndian(source: ReadOnlySpan<number>, isUnsigned: boolean): TSelf {
            throw new Error("not yet implemented");
        }
        static ReadLittleEndian(source: number[], isUnsigned: boolean): TSelf {
            throw new Error("not yet implemented");
        }
        static ReadLittleEndian(source: number[], startIndex: number, isUnsigned: boolean): TSelf {
            throw new Error("not yet implemented");
        }
        static ReadLittleEndian(source: ReadOnlySpan<number>, isUnsigned: boolean): TSelf {
            throw new Error("not yet implemented");
        }
        static RotateLeft(value: TSelf, rotateAmount: number): TSelf {
            throw new Error("not yet implemented");
        }
        static RotateRight(value: TSelf, rotateAmount: number): TSelf {
            throw new Error("not yet implemented");
        }
        static TrailingZeroCount(value: TSelf): TSelf;
        static TryReadBigEndian(source: ReadOnlySpan<number>, isUnsigned: boolean, out value: TSelf): boolean;
        static TryReadLittleEndian(source: ReadOnlySpan<number>, isUnsigned: boolean, out value: TSelf): boolean;
        GetByteCount(): number;
        GetShortestBitLength(): number;
        TryWriteBigEndian(destination: Span<number>, out bytesWritten: number): boolean;
        TryWriteLittleEndian(destination: Span<number>, out bytesWritten: number): boolean;
        WriteBigEndian(destination: number[]): number {
            throw new Error("not yet implemented");
        }
        WriteBigEndian(destination: number[], startIndex: number): number {
            throw new Error("not yet implemented");
        }
        WriteBigEndian(destination: Span<number>): number {
            throw new Error("not yet implemented");
        }
        WriteLittleEndian(destination: number[]): number {
            throw new Error("not yet implemented");
        }
        WriteLittleEndian(destination: number[], startIndex: number): number {
            throw new Error("not yet implemented");
        }
        WriteLittleEndian(destination: Span<number>): number {
            throw new Error("not yet implemented");
        }
    }
    export interface IUnsignedNumber<TSelf> implements INumberBase<TSelf>, IAdditionOperators<TSelf, TSelf, TSelf>, IAdditiveIdentity<TSelf, TSelf>, IDecrementOperators<TSelf>, IDivisionOperators<TSelf, TSelf, TSelf>, IEquatable<TSelf>, IEqualityOperators<TSelf, TSelf, boolean>, IIncrementOperators<TSelf>, IMultiplicativeIdentity<TSelf, TSelf>, IMultiplyOperators<TSelf, TSelf, TSelf>, ISpanFormattable, IFormattable, ISpanParsable<TSelf>, IParsable<TSelf>, ISubtractionOperators<TSelf, TSelf, TSelf>, IUnaryPlusOperators<TSelf, TSelf>, IUnaryNegationOperators<TSelf, TSelf>, IUtf8SpanFormattable, IUtf8SpanParsable<TSelf> {
    }
}
export namespace System.Reflection {
    export interface ICustomAttributeProvider {
        GetCustomAttributes(inherit: boolean): any[];
        GetCustomAttributes(attributeType: Type, inherit: boolean): any[];
        IsDefined(attributeType: Type, inherit: boolean): boolean;
    }
    export enum MethodAttributes {
        PrivateScope = 0x0,
        ReuseSlot = 0x0,
        Private = 0x1,
        FamANDAssem = 0x2,
        Assembly = 0x3,
        Family = 0x4,
        FamORAssem = 0x5,
        Public = 0x6,
        MemberAccessMask = 0x7,
        UnmanagedExport = 0x8,
        Static = 0x10,
        Final = 0x20,
        Virtual = 0x40,
        HideBySig = 0x80,
        NewSlot = 0x100,
        VtableLayoutMask = 0x100,
        CheckAccessOnOverride = 0x200,
        Abstract = 0x400,
        SpecialName = 0x800,
        RTSpecialName = 0x1000,
        PinvokeImpl = 0x2000,
        HasSecurity = 0x4000,
        RequireSecObject = 0x8000,
        ReservedMask = 0xd000,
    }
    export enum MethodImplAttributes {
        IL = 0,
        Managed = 0,
        Native = 1,
        OPTIL = 2,
        CodeTypeMask = 3,
        Runtime = 3,
        ManagedMask = 4,
        Unmanaged = 4,
        NoInlining = 8,
        ForwardRef = 16,
        Synchronized = 32,
        NoOptimization = 64,
        PreserveSig = 128,
        AggressiveInlining = 256,
        AggressiveOptimization = 512,
        InternalCall = 4096,
        MaxMethodImplVal = 65535,
    }
    export enum CallingConventions {
        Standard = 0x1,
        VarArgs = 0x2,
        Any = 0x3,
        HasThis = 0x20,
        ExplicitThis = 0x40,
    }
    export enum CorElementType {
        ELEMENT_TYPE_END = 0,
        ELEMENT_TYPE_VOID = 1,
        ELEMENT_TYPE_BOOLEAN = 2,
        ELEMENT_TYPE_CHAR = 3,
        ELEMENT_TYPE_I1 = 4,
        ELEMENT_TYPE_U1 = 5,
        ELEMENT_TYPE_I2 = 6,
        ELEMENT_TYPE_U2 = 7,
        ELEMENT_TYPE_I4 = 8,
        ELEMENT_TYPE_U4 = 9,
        ELEMENT_TYPE_I8 = 10,
        ELEMENT_TYPE_U8 = 11,
        ELEMENT_TYPE_R4 = 12,
        ELEMENT_TYPE_R8 = 13,
        ELEMENT_TYPE_STRING = 14,
        ELEMENT_TYPE_PTR = 15,
        ELEMENT_TYPE_BYREF = 16,
        ELEMENT_TYPE_VALUETYPE = 17,
        ELEMENT_TYPE_CLASS = 18,
        ELEMENT_TYPE_VAR = 19,
        ELEMENT_TYPE_ARRAY = 20,
        ELEMENT_TYPE_GENERICINST = 21,
        ELEMENT_TYPE_TYPEDBYREF = 22,
        ELEMENT_TYPE_I = 24,
        ELEMENT_TYPE_U = 25,
        ELEMENT_TYPE_FNPTR = 27,
        ELEMENT_TYPE_OBJECT = 28,
        ELEMENT_TYPE_SZARRAY = 29,
        ELEMENT_TYPE_MVAR = 30,
        ELEMENT_TYPE_CMOD_REQD = 31,
        ELEMENT_TYPE_CMOD_OPT = 32,
        ELEMENT_TYPE_INTERNAL = 33,
        ELEMENT_TYPE_MAX = 34,
        ELEMENT_TYPE_MODIFIER = 64,
        ELEMENT_TYPE_SENTINEL = 65,
        ELEMENT_TYPE_PINNED = 69,
    }
    export class Table {
        private m_keys: K[];
        private m_values: V[];
        private m_count: number;

        protected constructor(size: number) {
            throw new Error("not yet implemented");
        }

        private Insert(key: K, value: V) {
            throw new Error("not yet implemented");
        }
    }
    export class CerHashtable<K, V> extends ValueType {
        private m_Table: Table;

        private get Item(): V {
            throw new Error("not yet implemented");
        }
        private set Item(key: K) {
            throw new Error("not yet implemented");
        }

        private static GetHashCodeHelper(key: K): number {
            throw new Error("not yet implemented");
        }
        private Rehash(newSize: number) {
            throw new Error("not yet implemented");
        }
    }
    export namespace CerHashtable {
        export class Table {
            private m_keys: K[];
            private m_values: V[];
            private m_count: number;

            protected constructor(size: number) {
                throw new Error("not yet implemented");
            }

            private Insert(key: K, value: V) {
                throw new Error("not yet implemented");
            }
        }
    }
    export enum FieldAttributes {
        PrivateScope = 0x0,
        Private = 0x1,
        FamANDAssem = 0x2,
        Assembly = 0x3,
        Family = 0x4,
        FamORAssem = 0x5,
        Public = 0x6,
        FieldAccessMask = 0x7,
        Static = 0x10,
        InitOnly = 0x20,
        Literal = 0x40,
        NotSerialized = 0x80,
        HasFieldRVA = 0x100,
        SpecialName = 0x200,
        RTSpecialName = 0x400,
        HasFieldMarshal = 0x1000,
        PinvokeImpl = 0x2000,
        HasDefault = 0x8000,
        ReservedMask = 0x9500,
    }
    export enum BindingFlags {
        Default = 0x0,
        IgnoreCase = 0x1,
        DeclaredOnly = 0x2,
        Instance = 0x4,
        Static = 0x8,
        Public = 0x10,
        NonPublic = 0x20,
        FlattenHierarchy = 0x40,
        InvokeMethod = 0x100,
        CreateInstance = 0x200,
        GetField = 0x400,
        SetField = 0x800,
        GetProperty = 0x1000,
        SetProperty = 0x2000,
        PutDispProperty = 0x4000,
        PutRefDispProperty = 0x8000,
        ExactBinding = 0x10000,
        SuppressChangeType = 0x20000,
        OptionalParamBinding = 0x40000,
        IgnoreReturn = 0x1000000,
        DoNotWrapExceptions = 0x2000000,
    }
    export class TypeFilter extends MulticastDelegate implements ICloneable, ISerializable {
        public constructor(object: any, method: number) {
            throw new Error("not yet implemented");
        }

        public Invoke(m: Type, filterCriteria: any): boolean {
            throw new Error("not yet implemented");
        }
        public BeginInvoke(m: Type, filterCriteria: any, callback: AsyncCallback, object: any): IAsyncResult {
            throw new Error("not yet implemented");
        }
        public EndInvoke(result: IAsyncResult): boolean {
            throw new Error("not yet implemented");
        }
    }
    export class ConstArray extends ValueType {
        private m_length: number;
        private m_constArray: number;

        public get Signature(): number {
            throw new Error("not yet implemented");
        }
        public get Length(): number {
            throw new Error("not yet implemented");
        }
        public get Item(): number {
            throw new Error("not yet implemented");
        }

    }
    export class __smallResult__e__FixedBuffer extends ValueType {
        public FixedElementField: number;

    }
    export class MetadataEnumResult extends ValueType {
        private largeResult: number[];
        private length: number;
        private smallResult: __smallResult__e__FixedBuffer;

        public get Length(): number {
            throw new Error("not yet implemented");
        }
        public get Item(): number {
            throw new Error("not yet implemented");
        }

    }
    export namespace MetadataEnumResult {
        export class __smallResult__e__FixedBuffer extends ValueType {
            public FixedElementField: number;

        }
    }
    export enum MetadataTokenType {
        Module = 0,
        TypeRef = 16777216,
        TypeDef = 33554432,
        FieldDef = 67108864,
        MethodDef = 100663296,
        ParamDef = 134217728,
        InterfaceImpl = 150994944,
        MemberRef = 167772160,
        CustomAttribute = 201326592,
        Permission = 234881024,
        Signature = 285212672,
        Event = 335544320,
        Property = 385875968,
        ModuleRef = 436207616,
        TypeSpec = 452984832,
        Assembly = 536870912,
        AssemblyRef = 587202560,
        File = 637534208,
        ExportedType = 654311424,
        ManifestResource = 671088640,
        GenericPar = 704643072,
        MethodSpec = 721420288,
        String = 1879048192,
        Name = 1895825408,
        BaseType = 1912602624,
        Invalid = 2147483647,
    }
    export enum EventAttributes {
        None = 0x0,
        SpecialName = 0x200,
        RTSpecialName = 0x400,
        ReservedMask = 0x400,
    }
    export enum PropertyAttributes {
        None = 0x0,
        SpecialName = 0x200,
        RTSpecialName = 0x400,
        HasDefault = 0x1000,
        Reserved2 = 0x2000,
        Reserved3 = 0x4000,
        Reserved4 = 0x8000,
        ReservedMask = 0xf400,
    }
    export enum ParameterAttributes {
        None = 0x0,
        In = 0x1,
        Out = 0x2,
        Lcid = 0x4,
        Retval = 0x8,
        Optional = 0x10,
        HasDefault = 0x1000,
        HasFieldMarshal = 0x2000,
        Reserved3 = 0x4000,
        Reserved4 = 0x8000,
        ReservedMask = 0xf000,
    }
    export enum GenericParameterAttributes {
        None = 0x0,
        Covariant = 0x1,
        Contravariant = 0x2,
        VarianceMask = 0x3,
        ReferenceTypeConstraint = 0x4,
        NotNullableValueTypeConstraint = 0x8,
        DefaultConstructorConstraint = 0x10,
        SpecialConstraintMask = 0x1c,
    }
    export class MetadataToken extends ValueType {
        public Value: number;

        public get IsGlobalTypeDefToken(): boolean {
            throw new Error("not yet implemented");
        }
        public get TokenType(): MetadataTokenType {
            throw new Error("not yet implemented");
        }
        public get IsTypeRef(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsTypeDef(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsFieldDef(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsMethodDef(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsMemberRef(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsEvent(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsProperty(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsParamDef(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsTypeSpec(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsMethodSpec(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsString(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsSignature(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsGenericPar(): boolean {
            throw new Error("not yet implemented");
        }

        public constructor(token: number) {
            throw new Error("not yet implemented");
        }

        public static IsNullToken(token: number): boolean {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
    }
    export enum PInvokeAttributes {
        ThrowOnUnmappableCharUseAssem = 0x0,
        BestFitUseAssem = 0x0,
        CharSetNotSpec = 0x0,
        NoMangle = 0x1,
        CharSetAnsi = 0x2,
        CharSetUnicode = 0x4,
        CharSetAuto = 0x6,
        CharSetMask = 0x6,
        BestFitEnabled = 0x10,
        BestFitDisabled = 0x20,
        BestFitMask = 0x30,
        SupportsLastError = 0x40,
        CallConvWinapi = 0x100,
        CallConvCdecl = 0x200,
        CallConvStdcall = 0x300,
        CallConvThiscall = 0x400,
        CallConvFastcall = 0x500,
        CallConvMask = 0x700,
        ThrowOnUnmappableCharEnabled = 0x1000,
        ThrowOnUnmappableCharDisabled = 0x2000,
        ThrowOnUnmappableCharMask = 0x3000,
        MaxValue = 0xffff,
    }
    export class MetadataImport extends ValueType {
        private static readonly EmptyImport: MetadataImport;

        private m_metadataImport2: number;
        private m_keepalive: any;

        protected constructor(metadataImport2: number, keepalive: any) {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        private Equals(import: MetadataImport): boolean {
            throw new Error("not yet implemented");
        }
        private static _GetMarshalAs(pNativeType: number, cNativeType: number, out unmanagedType: number, out safeArraySubType: number, out safeArrayUserDefinedSubType: string, out arraySubType: number, out sizeParamIndex: number, out sizeConst: number, out marshalType: string, out marshalCookie: string, out iidParamIndex: number) {
            throw new Error("not yet implemented");
        }
        private static GetMarshalAs(nativeType: ConstArray, out unmanagedType: UnmanagedType, out safeArraySubType: VarEnum, out safeArrayUserDefinedSubType: string, out arraySubType: UnmanagedType, out sizeParamIndex: number, out sizeConst: number, out marshalType: string, out marshalCookie: string, out iidParamIndex: number) {
            throw new Error("not yet implemented");
        }
        private static ThrowError(hResult: number) {
            throw new Error("not yet implemented");
        }
        private static _Enum(scope: number, type: number, parent: number, out result: MetadataEnumResult) {
            throw new Error("not yet implemented");
        }
        public Enum(type: MetadataTokenType, parent: number, out result: MetadataEnumResult) {
            throw new Error("not yet implemented");
        }
        public EnumNestedTypes(mdTypeDef: number, out result: MetadataEnumResult) {
            throw new Error("not yet implemented");
        }
        public EnumCustomAttributes(mdToken: number, out result: MetadataEnumResult) {
            throw new Error("not yet implemented");
        }
        public EnumParams(mdMethodDef: number, out result: MetadataEnumResult) {
            throw new Error("not yet implemented");
        }
        public EnumFields(mdTypeDef: number, out result: MetadataEnumResult) {
            throw new Error("not yet implemented");
        }
        public EnumProperties(mdTypeDef: number, out result: MetadataEnumResult) {
            throw new Error("not yet implemented");
        }
        public EnumEvents(mdTypeDef: number, out result: MetadataEnumResult) {
            throw new Error("not yet implemented");
        }
        private static _GetDefaultValue(scope: number, mdToken: number, out value: number, out length: number, out corElementType: number): string {
            throw new Error("not yet implemented");
        }
        public GetDefaultValue(mdToken: number, out value: number, out length: number, out corElementType: CorElementType): string {
            throw new Error("not yet implemented");
        }
        private static _GetUserString(scope: number, mdToken: number, name: Void**, out length: number) {
            throw new Error("not yet implemented");
        }
        public GetUserString(mdToken: number): string {
            throw new Error("not yet implemented");
        }
        private static _GetName(scope: number, mdToken: number, name: Void**) {
            throw new Error("not yet implemented");
        }
        public GetName(mdToken: number): MdUtf8String {
            throw new Error("not yet implemented");
        }
        private static _GetNamespace(scope: number, mdToken: number, namesp: Void**) {
            throw new Error("not yet implemented");
        }
        public GetNamespace(mdToken: number): MdUtf8String {
            throw new Error("not yet implemented");
        }
        private static _GetEventProps(scope: number, mdToken: number, name: Void**, out eventAttributes: number) {
            throw new Error("not yet implemented");
        }
        public GetEventProps(mdToken: number, out name: Void*, out eventAttributes: EventAttributes) {
            throw new Error("not yet implemented");
        }
        private static _GetFieldDefProps(scope: number, mdToken: number, out fieldAttributes: number) {
            throw new Error("not yet implemented");
        }
        public GetFieldDefProps(mdToken: number, out fieldAttributes: FieldAttributes) {
            throw new Error("not yet implemented");
        }
        private static _GetPropertyProps(scope: number, mdToken: number, name: Void**, out propertyAttributes: number, out signature: ConstArray) {
            throw new Error("not yet implemented");
        }
        public GetPropertyProps(mdToken: number, out name: Void*, out propertyAttributes: PropertyAttributes, out signature: ConstArray) {
            throw new Error("not yet implemented");
        }
        private static _GetParentToken(scope: number, mdToken: number, out tkParent: number) {
            throw new Error("not yet implemented");
        }
        public GetParentToken(tkToken: number): number {
            throw new Error("not yet implemented");
        }
        private static _GetParamDefProps(scope: number, parameterToken: number, out sequence: number, out attributes: number) {
            throw new Error("not yet implemented");
        }
        public GetParamDefProps(parameterToken: number, out sequence: number, out attributes: ParameterAttributes) {
            throw new Error("not yet implemented");
        }
        private static _GetGenericParamProps(scope: number, genericParameter: number, out flags: number) {
            throw new Error("not yet implemented");
        }
        public GetGenericParamProps(genericParameter: number, out attributes: GenericParameterAttributes) {
            throw new Error("not yet implemented");
        }
        private static _GetScopeProps(scope: number, out mvid: Guid) {
            throw new Error("not yet implemented");
        }
        public GetScopeProps(out mvid: Guid) {
            throw new Error("not yet implemented");
        }
        public GetMethodSignature(token: MetadataToken): ConstArray {
            throw new Error("not yet implemented");
        }
        private static _GetSigOfMethodDef(scope: number, methodToken: number, ref signature: ConstArray) {
            throw new Error("not yet implemented");
        }
        public GetSigOfMethodDef(methodToken: number): ConstArray {
            throw new Error("not yet implemented");
        }
        private static _GetSignatureFromToken(scope: number, methodToken: number, ref signature: ConstArray) {
            throw new Error("not yet implemented");
        }
        public GetSignatureFromToken(token: number): ConstArray {
            throw new Error("not yet implemented");
        }
        private static _GetMemberRefProps(scope: number, memberTokenRef: number, out signature: ConstArray) {
            throw new Error("not yet implemented");
        }
        public GetMemberRefProps(memberTokenRef: number): ConstArray {
            throw new Error("not yet implemented");
        }
        private static _GetCustomAttributeProps(scope: number, customAttributeToken: number, out constructorToken: number, out signature: ConstArray) {
            throw new Error("not yet implemented");
        }
        public GetCustomAttributeProps(customAttributeToken: number, out constructorToken: number, out signature: ConstArray) {
            throw new Error("not yet implemented");
        }
        private static _GetClassLayout(scope: number, typeTokenDef: number, out packSize: number, out classSize: number) {
            throw new Error("not yet implemented");
        }
        public GetClassLayout(typeTokenDef: number, out packSize: number, out classSize: number) {
            throw new Error("not yet implemented");
        }
        private static _GetFieldOffset(scope: number, typeTokenDef: number, fieldTokenDef: number, out offset: number): boolean {
            throw new Error("not yet implemented");
        }
        public GetFieldOffset(typeTokenDef: number, fieldTokenDef: number, out offset: number): boolean {
            throw new Error("not yet implemented");
        }
        private static _GetSigOfFieldDef(scope: number, fieldToken: number, ref fieldMarshal: ConstArray) {
            throw new Error("not yet implemented");
        }
        public GetSigOfFieldDef(fieldToken: number): ConstArray {
            throw new Error("not yet implemented");
        }
        private static _GetFieldMarshal(scope: number, fieldToken: number, ref fieldMarshal: ConstArray) {
            throw new Error("not yet implemented");
        }
        public GetFieldMarshal(fieldToken: number): ConstArray {
            throw new Error("not yet implemented");
        }
        private static _GetPInvokeMap(scope: number, token: number, out attributes: number, importName: Void**, importDll: Void**) {
            throw new Error("not yet implemented");
        }
        public GetPInvokeMap(token: number, out attributes: PInvokeAttributes, out importName: string, out importDll: string) {
            throw new Error("not yet implemented");
        }
        private static _IsValidToken(scope: number, token: number): boolean {
            throw new Error("not yet implemented");
        }
        public IsValidToken(token: number): boolean {
            throw new Error("not yet implemented");
        }
    }
    export interface IReflectableType {
        GetTypeInfo(): TypeInfo;
    }
    export class ParameterModifier extends ValueType {
        private _byRef: boolean[];

        public get Item(): boolean {
            throw new Error("not yet implemented");
        }
        public set Item(index: number) {
            throw new Error("not yet implemented");
        }
        private get IsByRefArray(): boolean[] {
            throw new Error("not yet implemented");
        }

        public constructor(parameterCount: number) {
            throw new Error("not yet implemented");
        }

    }
    export class ParameterInfo implements ICustomAttributeProvider, IObjectReference {
        private AttrsImpl: ParameterAttributes;
        private ClassImpl: Type;
        private DefaultValueImpl: any;
        private MemberImpl: MemberInfo;
        private NameImpl: string;
        private PositionImpl: number;

        public get Attributes(): ParameterAttributes {
            throw new Error("not yet implemented");
        }
        public get Member(): MemberInfo {
            throw new Error("not yet implemented");
        }
        public get Name(): string {
            throw new Error("not yet implemented");
        }
        public get ParameterType(): Type {
            throw new Error("not yet implemented");
        }
        public get Position(): number {
            throw new Error("not yet implemented");
        }
        public get IsIn(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsLcid(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsOptional(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsOut(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsRetval(): boolean {
            throw new Error("not yet implemented");
        }
        public get DefaultValue(): any {
            throw new Error("not yet implemented");
        }
        public get RawDefaultValue(): any {
            throw new Error("not yet implemented");
        }
        public get HasDefaultValue(): boolean {
            throw new Error("not yet implemented");
        }
        public get CustomAttributes(): IEnumerable<CustomAttributeData> {
            throw new Error("not yet implemented");
        }
        public get MetadataToken(): number {
            throw new Error("not yet implemented");
        }

        protected constructor() {
            throw new Error("not yet implemented");
        }

        public IsDefined(attributeType: Type, inherit: boolean): boolean {
            throw new Error("not yet implemented");
        }
        public GetCustomAttributesData(): IList<CustomAttributeData> {
            throw new Error("not yet implemented");
        }
        public GetCustomAttributes(inherit: boolean): any[] {
            throw new Error("not yet implemented");
        }
        public GetCustomAttributes(attributeType: Type, inherit: boolean): any[] {
            throw new Error("not yet implemented");
        }
        public GetModifiedParameterType(): Type {
            throw new Error("not yet implemented");
        }
        public GetOptionalCustomModifiers(): Type[] {
            throw new Error("not yet implemented");
        }
        public GetRequiredCustomModifiers(): Type[] {
            throw new Error("not yet implemented");
        }
        public GetRealObject(context: StreamingContext): any {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
    }
    export abstract class PropertyInfo extends MemberInfo implements ICustomAttributeProvider {
        public get MemberType(): MemberTypes {
            throw new Error("not yet implemented");
        }
        public get PropertyType(): Type;
        public get Attributes(): PropertyAttributes;
        public get IsSpecialName(): boolean {
            throw new Error("not yet implemented");
        }
        public get CanRead(): boolean;
        public get CanWrite(): boolean;
        public get GetMethod(): MethodInfo {
            throw new Error("not yet implemented");
        }
        public get SetMethod(): MethodInfo {
            throw new Error("not yet implemented");
        }

        protected constructor() {
            throw new Error("not yet implemented");
        }

        public GetIndexParameters(): ParameterInfo[];
        public GetAccessors(): MethodInfo[] {
            throw new Error("not yet implemented");
        }
        public GetAccessors(nonPublic: boolean): MethodInfo[];
        public GetGetMethod(): MethodInfo {
            throw new Error("not yet implemented");
        }
        public GetGetMethod(nonPublic: boolean): MethodInfo;
        public GetSetMethod(): MethodInfo {
            throw new Error("not yet implemented");
        }
        public GetSetMethod(nonPublic: boolean): MethodInfo;
        public GetModifiedPropertyType(): Type {
            throw new Error("not yet implemented");
        }
        public GetOptionalCustomModifiers(): Type[] {
            throw new Error("not yet implemented");
        }
        public GetRequiredCustomModifiers(): Type[] {
            throw new Error("not yet implemented");
        }
        public GetValue(obj: any): any {
            throw new Error("not yet implemented");
        }
        public GetValue(obj: any, index: any[]): any {
            throw new Error("not yet implemented");
        }
        public GetValue(obj: any, invokeAttr: BindingFlags, binder: Binder, index: any[], culture: CultureInfo): any;
        public GetConstantValue(): any {
            throw new Error("not yet implemented");
        }
        public GetRawConstantValue(): any {
            throw new Error("not yet implemented");
        }
        public SetValue(obj: any, value: any) {
            throw new Error("not yet implemented");
        }
        public SetValue(obj: any, value: any, index: any[]) {
            throw new Error("not yet implemented");
        }
        public SetValue(obj: any, value: any, invokeAttr: BindingFlags, binder: Binder, index: any[], culture: CultureInfo): void;
        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
    }
    export abstract class Binder {
        protected constructor() {
            throw new Error("not yet implemented");
        }

        public BindToField(bindingAttr: BindingFlags, match: FieldInfo[], value: any, culture: CultureInfo): FieldInfo;
        public BindToMethod(bindingAttr: BindingFlags, match: MethodBase[], ref args: any[], modifiers: ParameterModifier[], culture: CultureInfo, names: string[], out state: any): MethodBase;
        public ChangeType(value: any, type: Type, culture: CultureInfo): any;
        public ReorderArgumentArray(ref args: any[], state: any): void;
        public SelectMethod(bindingAttr: BindingFlags, match: MethodBase[], types: Type[], modifiers: ParameterModifier[]): MethodBase;
        public SelectProperty(bindingAttr: BindingFlags, match: PropertyInfo[], returnType: Type, indexes: Type[], modifiers: ParameterModifier[]): PropertyInfo;
    }
    export abstract class ConstructorInfo extends MethodBase implements ICustomAttributeProvider {
        public static readonly ConstructorName: string;
        public static readonly TypeConstructorName: string;

        public get MemberType(): MemberTypes {
            throw new Error("not yet implemented");
        }

        protected constructor() {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

        private GetReturnType(): Type {
            throw new Error("not yet implemented");
        }
        public Invoke(parameters: any[]): any {
            throw new Error("not yet implemented");
        }
        public Invoke(invokeAttr: BindingFlags, binder: Binder, parameters: any[], culture: CultureInfo): any;
        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
    }
    export enum AssemblyNameFlags {
        None = 0x0,
        PublicKey = 0x1,
        Retargetable = 0x100,
        EnableJITcompileOptimizer = 0x4000,
        EnableJITcompileTracking = 0x8000,
    }
    export enum ProcessorArchitecture {
        None = 0,
        MSIL = 1,
        X86 = 2,
        IA64 = 3,
        Amd64 = 4,
        Arm = 5,
    }
    export enum AssemblyContentType {
        Default = 0,
        WindowsRuntime = 1,
    }
    export class StrongNameKeyPair implements IDeserializationCallback, ISerializable {
        public get PublicKey(): number[] {
            throw new Error("not yet implemented");
        }

        public constructor(keyPairFile: FileStream) {
            throw new Error("not yet implemented");
        }
        public constructor(keyPairArray: number[]) {
            throw new Error("not yet implemented");
        }
        protected constructor(info: SerializationInfo, context: StreamingContext) {
            throw new Error("not yet implemented");
        }
        public constructor(keyPairContainer: string) {
            throw new Error("not yet implemented");
        }

        private __explicit__ISerializable_GetObjectData(info: SerializationInfo, context: StreamingContext) {
            throw new Error("not yet implemented");
        }
        public GetObjectData(info: SerializationInfo, context: StreamingContext) {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__IDeserializationCallback_OnDeserialization(sender: any) {
            throw new Error("not yet implemented");
        }
        public OnDeserialization(sender: any) {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
    }
    export class NativeAssemblyNameParts extends ValueType {
        public _pName: string*;
        public _major: number;
        public _minor: number;
        public _build: number;
        public _revision: number;
        public _pCultureName: string*;
        public _pPublicKeyOrToken: number*;
        public _cbPublicKeyOrToken: number;
        public _flags: AssemblyNameFlags;

        public SetVersion(version: Version, defaultValue: number) {
            throw new Error("not yet implemented");
        }
        public GetVersion(): Version {
            throw new Error("not yet implemented");
        }
    }
    export enum PortableExecutableKinds {
        NotAPortableExecutableImage = 0x0,
        ILOnly = 0x1,
        Required32Bit = 0x2,
        PE32Plus = 0x4,
        Unmanaged32Bit = 0x8,
        Preferred32Bit = 0x10,
    }
    export enum ImageFileMachine {
        I386 = 332,
        ARM = 452,
        IA64 = 512,
        AMD64 = 34404,
    }
    export class AssemblyName implements ICloneable, IDeserializationCallback, ISerializable {
        private static s_getAssemblyName: Func<string, AssemblyName>;

        private _name: string;
        private _publicKey: number[];
        private _publicKeyToken: number[];
        private _cultureInfo: CultureInfo;
        private _codeBase: string;
        private _version: Version;
        private _hashAlgorithm: AssemblyHashAlgorithm;
        private _versionCompatibility: AssemblyVersionCompatibility;
        private _flags: AssemblyNameFlags;

        private get RawPublicKey(): number[] {
            throw new Error("not yet implemented");
        }
        private get RawPublicKeyToken(): number[] {
            throw new Error("not yet implemented");
        }
        private get RawFlags(): AssemblyNameFlags {
            throw new Error("not yet implemented");
        }
        private set RawFlags(value: AssemblyNameFlags) {
            throw new Error("not yet implemented");
        }
        public get Name(): string {
            throw new Error("not yet implemented");
        }
        public set Name(value: string) {
            throw new Error("not yet implemented");
        }
        public get Version(): Version {
            throw new Error("not yet implemented");
        }
        public set Version(value: Version) {
            throw new Error("not yet implemented");
        }
        public get CultureInfo(): CultureInfo {
            throw new Error("not yet implemented");
        }
        public set CultureInfo(value: CultureInfo) {
            throw new Error("not yet implemented");
        }
        public get CultureName(): string {
            throw new Error("not yet implemented");
        }
        public set CultureName(value: string) {
            throw new Error("not yet implemented");
        }
        public get CodeBase(): string {
            throw new Error("not yet implemented");
        }
        public set CodeBase(value: string) {
            throw new Error("not yet implemented");
        }
        public get EscapedCodeBase(): string {
            throw new Error("not yet implemented");
        }
        public get ProcessorArchitecture(): ProcessorArchitecture {
            throw new Error("not yet implemented");
        }
        public set ProcessorArchitecture(value: ProcessorArchitecture) {
            throw new Error("not yet implemented");
        }
        public get ContentType(): AssemblyContentType {
            throw new Error("not yet implemented");
        }
        public set ContentType(value: AssemblyContentType) {
            throw new Error("not yet implemented");
        }
        public get Flags(): AssemblyNameFlags {
            throw new Error("not yet implemented");
        }
        public set Flags(value: AssemblyNameFlags) {
            throw new Error("not yet implemented");
        }
        public get HashAlgorithm(): AssemblyHashAlgorithm {
            throw new Error("not yet implemented");
        }
        public set HashAlgorithm(value: AssemblyHashAlgorithm) {
            throw new Error("not yet implemented");
        }
        public get VersionCompatibility(): AssemblyVersionCompatibility {
            throw new Error("not yet implemented");
        }
        public set VersionCompatibility(value: AssemblyVersionCompatibility) {
            throw new Error("not yet implemented");
        }
        public get KeyPair(): StrongNameKeyPair {
            throw new Error("not yet implemented");
        }
        public set KeyPair(value: StrongNameKeyPair) {
            throw new Error("not yet implemented");
        }
        public get FullName(): string {
            throw new Error("not yet implemented");
        }

        protected constructor(pParts: NativeAssemblyNameParts*) {
            throw new Error("not yet implemented");
        }
        public constructor(assemblyName: string) {
            throw new Error("not yet implemented");
        }
        public constructor() {
            throw new Error("not yet implemented");
        }

        private SetProcArchIndex(pek: PortableExecutableKinds, ifm: ImageFileMachine) {
            throw new Error("not yet implemented");
        }
        private static CalculateProcArch(pek: PortableExecutableKinds, ifm: ImageFileMachine, aFlags: AssemblyNameFlags): ProcessorArchitecture {
            throw new Error("not yet implemented");
        }
        private static ParseAsAssemblySpec(pAssemblyName: string*, pAssemblySpec: void*) {
            throw new Error("not yet implemented");
        }
        private static InitializeAssemblySpec(pAssemblyNameParts: NativeAssemblyNameParts*, pAssemblySpec: void*) {
            throw new Error("not yet implemented");
        }
        public Clone(): any {
            throw new Error("not yet implemented");
        }
        private static InitGetAssemblyName(): Func<string, AssemblyName> {
            throw new Error("not yet implemented");
        }
        public static GetAssemblyName(assemblyFile: string): AssemblyName {
            throw new Error("not yet implemented");
        }
        public GetPublicKey(): number[] {
            throw new Error("not yet implemented");
        }
        public SetPublicKey(publicKey: number[]) {
            throw new Error("not yet implemented");
        }
        public GetPublicKeyToken(): number[] {
            throw new Error("not yet implemented");
        }
        public SetPublicKeyToken(publicKeyToken: number[]) {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
        public GetObjectData(info: SerializationInfo, context: StreamingContext) {
            throw new Error("not yet implemented");
        }
        public OnDeserialization(sender: any) {
            throw new Error("not yet implemented");
        }
        public static ReferenceMatchesDefinition(reference: AssemblyName, definition: AssemblyName): boolean {
            throw new Error("not yet implemented");
        }
        private static EscapeCodeBase(codebase: string): string {
            throw new Error("not yet implemented");
        }
        private static EscapeString(input: string, start: number, end: number, dest: string[], ref destPos: number, isUriString: boolean, force1: string, force2: string, rsvd: string): string[] {
            throw new Error("not yet implemented");
        }
        private static EnsureDestinationSize(pStr: string*, dest: string[], currentInputPos: number, charsToAdd: number, minReallocateChars: number, ref destPos: number, prevInputPos: number): string[] {
            throw new Error("not yet implemented");
        }
        private static EscapeAsciiChar(ch: string, to: string[], ref pos: number) {
            throw new Error("not yet implemented");
        }
        private static IsReservedUnreservedOrHash(c: string): boolean {
            throw new Error("not yet implemented");
        }
        private static IsUnreserved(c: string): boolean {
            throw new Error("not yet implemented");
        }
    }
    export enum TypeAttributes {
        NotPublic = 0x0,
        AutoLayout = 0x0,
        AnsiClass = 0x0,
        Class = 0x0,
        Public = 0x1,
        NestedPublic = 0x2,
        NestedPrivate = 0x3,
        NestedFamily = 0x4,
        NestedAssembly = 0x5,
        NestedFamANDAssem = 0x6,
        VisibilityMask = 0x7,
        NestedFamORAssem = 0x7,
        SequentialLayout = 0x8,
        ExplicitLayout = 0x10,
        LayoutMask = 0x18,
        Interface = 0x20,
        ClassSemanticsMask = 0x20,
        Abstract = 0x80,
        Sealed = 0x100,
        SpecialName = 0x400,
        RTSpecialName = 0x800,
        Import = 0x1000,
        Serializable = 0x2000,
        WindowsRuntime = 0x4000,
        UnicodeClass = 0x10000,
        AutoClass = 0x20000,
        StringFormatMask = 0x30000,
        CustomFormatClass = 0x30000,
        HasSecurity = 0x40000,
        ReservedMask = 0x40800,
        BeforeFieldInit = 0x100000,
        CustomFormatMask = 0xc00000,
    }
    export enum MdSigCallingConvention {
        Default = 0x0,
        C = 0x1,
        StdCall = 0x2,
        ThisCall = 0x3,
        FastCall = 0x4,
        Vararg = 0x5,
        Field = 0x6,
        LocalSig = 0x7,
        Property = 0x8,
        Unmanaged = 0x9,
        GenericInst = 0xa,
        CallConvMask = 0xf,
        Generic = 0x10,
        HasThis = 0x20,
        ExplicitThis = 0x40,
    }
    export class LocalVariableInfo {
        public get LocalType(): Type {
            throw new Error("not yet implemented");
        }
        public get LocalIndex(): number {
            throw new Error("not yet implemented");
        }
        public get IsPinned(): boolean {
            throw new Error("not yet implemented");
        }

        protected constructor() {
            throw new Error("not yet implemented");
        }

        public ToString(): string {
            throw new Error("not yet implemented");
        }
    }
    export enum SignatureCallingConvention {
        Default = 0,
        Cdecl = 1,
        StdCall = 2,
        ThisCall = 3,
        FastCall = 4,
        Unmanaged = 9,
    }
    export class InvokeFunc_ObjSpanArgs extends MulticastDelegate implements ICloneable, ISerializable {
        public constructor(object: any, method: number) {
            throw new Error("not yet implemented");
        }

        public Invoke(obj: any, arguments: Span<any>): any {
            throw new Error("not yet implemented");
        }
    }
    export class InvokeFunc_RefArgs extends MulticastDelegate implements ICloneable, ISerializable {
        public constructor(object: any, method: number) {
            throw new Error("not yet implemented");
        }

        public Invoke(obj: any, refArguments: number*): any {
            throw new Error("not yet implemented");
        }
    }
    export enum InvokerStrategy {
        HasBeenInvoked_ObjSpanArgs = 0x1,
        StrategyDetermined_ObjSpanArgs = 0x2,
        HasBeenInvoked_Obj4Args = 0x4,
        StrategyDetermined_Obj4Args = 0x8,
        HasBeenInvoked_RefArgs = 0x10,
        StrategyDetermined_RefArgs = 0x20,
    }
    export enum InvocationFlags {
        Unknown = 0x0,
        Initialized = 0x1,
        NoInvoke = 0x2,
        RunClassConstructor = 0x4,
        NoConstructorInvoke = 0x8,
        IsConstructor = 0x10,
        SpecialField = 0x10,
        FieldSpecialCast = 0x20,
        IsDelegateConstructor = 0x80,
        ContainsStackPointers = 0x100,
    }
    export enum InvokerArgFlags {
        IsValueType = 0x1,
        IsValueType_ByRef_Or_Pointer = 0x2,
        IsNullableOfT = 0x4,
    }
    export class MethodBaseInvoker {
        private _signature: Signature;
        private _invokeFunc_ObjSpanArgs: InvokeFunc_ObjSpanArgs;
        private _invokeFunc_RefArgs: InvokeFunc_RefArgs;
        private _strategy: InvokerStrategy;
        private _invocationFlags: InvocationFlags;
        private _invokerArgFlags: InvokerArgFlags[];
        private _argTypes: RuntimeType[];
        private _method: MethodBase;
        private _argCount: number;
        private _needsByRefStrategy: boolean;

        protected constructor(method: RuntimeMethodInfo) {
            throw new Error("not yet implemented");
        }
        protected constructor(constructor: RuntimeConstructorInfo) {
            throw new Error("not yet implemented");
        }
        protected constructor(method: DynamicMethod, signature: Signature) {
            throw new Error("not yet implemented");
        }
        private constructor(method: MethodBase, argumentTypes: RuntimeType[]) {
            throw new Error("not yet implemented");
        }

        private InterpretedInvoke_Constructor(obj: any, args: number*): any {
            throw new Error("not yet implemented");
        }
        private InterpretedInvoke_Method(obj: any, args: number*): any {
            throw new Error("not yet implemented");
        }
        private static ThrowTargetParameterCountException() {
            throw new Error("not yet implemented");
        }
        private InvokeWithNoArgs(obj: any, invokeAttr: BindingFlags): any {
            throw new Error("not yet implemented");
        }
        private InvokeWithOneArg(obj: any, invokeAttr: BindingFlags, binder: Binder, parameters: any[], culture: CultureInfo): any {
            throw new Error("not yet implemented");
        }
        private InvokeWithFewArgs(obj: any, invokeAttr: BindingFlags, binder: Binder, parameters: any[], culture: CultureInfo): any {
            throw new Error("not yet implemented");
        }
        private InvokeDirectByRefWithFewArgs(obj: any, copyOfArgs: Span<any>, invokeAttr: BindingFlags): any {
            throw new Error("not yet implemented");
        }
        private InvokeWithManyArgs(obj: any, invokeAttr: BindingFlags, binder: Binder, parameters: any[], culture: CultureInfo): any {
            throw new Error("not yet implemented");
        }
        private InvokePropertySetter(obj: any, invokeAttr: BindingFlags, binder: Binder, parameter: any, culture: CultureInfo) {
            throw new Error("not yet implemented");
        }
        private CopyBack(dest: any[], copyOfParameters: Span<any>, shouldCopyBack: Span<boolean>) {
            throw new Error("not yet implemented");
        }
        private CheckArguments(parameters: ReadOnlySpan<any>, copyOfParameters: Span<any>, shouldCopyBack: Span<boolean>, binder: Binder, culture: CultureInfo, invokeAttr: BindingFlags) {
            throw new Error("not yet implemented");
        }
        private static TryByRefFastPath(type: RuntimeType, ref arg: any): boolean {
            throw new Error("not yet implemented");
        }
        private InvokeConstructorWithoutAlloc(obj: any, invokeAttr: BindingFlags, binder: Binder, parameters: any[], culture: CultureInfo): any {
            throw new Error("not yet implemented");
        }
        private InvokeConstructorWithoutAlloc(obj: any, wrapInTargetInvocationException: boolean): any {
            throw new Error("not yet implemented");
        }
    }
    export class MethodBody {
        public get LocalSignatureMetadataToken(): number {
            throw new Error("not yet implemented");
        }
        public get LocalVariables(): IList<LocalVariableInfo> {
            throw new Error("not yet implemented");
        }
        public get MaxStackSize(): number {
            throw new Error("not yet implemented");
        }
        public get InitLocals(): boolean {
            throw new Error("not yet implemented");
        }
        public get ExceptionHandlingClauses(): IList<ExceptionHandlingClause> {
            throw new Error("not yet implemented");
        }

        protected constructor() {
            throw new Error("not yet implemented");
        }

        public GetILAsByteArray(): number[] {
            throw new Error("not yet implemented");
        }
    }
    export class RuntimeConstructorInfo extends ConstructorInfo implements ICustomAttributeProvider, IRuntimeMethodInfo {
        private m_declaringType: RuntimeType;
        private m_reflectedTypeCache: RuntimeTypeCache;
        private m_toString: string;
        private m_parameters: ParameterInfo[];
        private _empty1: any;
        private _empty2: any;
        private _empty3: any;
        private m_handle: number;
        private m_methodAttributes: MethodAttributes;
        private m_bindingFlags: BindingFlags;
        private m_signature: Signature;
        private m_invoker: MethodBaseInvoker;

        private get InvocationFlags(): InvocationFlags {
            throw new Error("not yet implemented");
        }
        private get Invoker(): MethodBaseInvoker {
            throw new Error("not yet implemented");
        }
        private get __explicit__IRuntimeMethodInfo_Value(): RuntimeMethodHandleInternal {
            throw new Error("not yet implemented");
        }
        public get Value(): RuntimeMethodHandleInternal {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private get Signature(): Signature {
            throw new Error("not yet implemented");
        }
        private get ReflectedTypeInternal(): RuntimeType {
            throw new Error("not yet implemented");
        }
        private get BindingFlags(): BindingFlags {
            throw new Error("not yet implemented");
        }
        public get Name(): string {
            throw new Error("not yet implemented");
        }
        public get MemberType(): MemberTypes {
            throw new Error("not yet implemented");
        }
        public get DeclaringType(): Type {
            throw new Error("not yet implemented");
        }
        public get ReflectedType(): Type {
            throw new Error("not yet implemented");
        }
        public get MetadataToken(): number {
            throw new Error("not yet implemented");
        }
        public get Module(): Module {
            throw new Error("not yet implemented");
        }
        public get MethodHandle(): RuntimeMethodHandle {
            throw new Error("not yet implemented");
        }
        public get Attributes(): MethodAttributes {
            throw new Error("not yet implemented");
        }
        public get CallingConvention(): CallingConventions {
            throw new Error("not yet implemented");
        }
        private get ArgumentTypes(): RuntimeType[] {
            throw new Error("not yet implemented");
        }
        public get IsSecurityCritical(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsSecuritySafeCritical(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsSecurityTransparent(): boolean {
            throw new Error("not yet implemented");
        }
        public get ContainsGenericParameters(): boolean {
            throw new Error("not yet implemented");
        }

        protected constructor(handle: RuntimeMethodHandleInternal, declaringType: RuntimeType, reflectedTypeCache: RuntimeTypeCache, methodAttributes: MethodAttributes, bindingFlags: BindingFlags) {
            throw new Error("not yet implemented");
        }

        private CacheEquals(o: any): boolean {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public GetCustomAttributes(inherit: boolean): any[] {
            throw new Error("not yet implemented");
        }
        public GetCustomAttributes(attributeType: Type, inherit: boolean): any[] {
            throw new Error("not yet implemented");
        }
        public IsDefined(attributeType: Type, inherit: boolean): boolean {
            throw new Error("not yet implemented");
        }
        public GetCustomAttributesData(): IList<CustomAttributeData> {
            throw new Error("not yet implemented");
        }
        public HasSameMetadataDefinitionAs(other: MemberInfo): boolean {
            throw new Error("not yet implemented");
        }
        private GetRuntimeType(): RuntimeType {
            throw new Error("not yet implemented");
        }
        private GetRuntimeModule(): RuntimeModule {
            throw new Error("not yet implemented");
        }
        private GetReturnType(): Type {
            throw new Error("not yet implemented");
        }
        private GetParametersNoCopy(): ParameterInfo[] {
            throw new Error("not yet implemented");
        }
        public GetParameters(): ParameterInfo[] {
            throw new Error("not yet implemented");
        }
        public GetMethodImplementationFlags(): MethodImplAttributes {
            throw new Error("not yet implemented");
        }
        private InvokeClassConstructor() {
            throw new Error("not yet implemented");
        }
        public GetMethodBody(): MethodBody {
            throw new Error("not yet implemented");
        }
        private ComputeAndUpdateInvocationFlags(): InvocationFlags {
            throw new Error("not yet implemented");
        }
        private static CheckCanCreateInstance(declaringType: Type, isVarArg: boolean) {
            throw new Error("not yet implemented");
        }
        private ThrowNoInvokeException() {
            throw new Error("not yet implemented");
        }
        public Invoke(obj: any, invokeAttr: BindingFlags, binder: Binder, parameters: any[], culture: CultureInfo): any {
            throw new Error("not yet implemented");
        }
        public Invoke(invokeAttr: BindingFlags, binder: Binder, parameters: any[], culture: CultureInfo): any {
            throw new Error("not yet implemented");
        }
        private __get_Signature__g__LazyCreateSignature_21_0(): Signature {
            throw new Error("not yet implemented");
        }

        public readonly ExplicitAsICustomAttributeProvider: ICustomAttributeProvider = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Value') {
                    return target.__explicit__IRuntimeMethodInfo_Value;
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIRuntimeMethodInfo: IRuntimeMethodInfo = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Value') {
                    return target.__explicit__IRuntimeMethodInfo_Value;
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
    }
    export class RuntimePropertyInfo extends PropertyInfo implements ICustomAttributeProvider {
        private m_token: number;
        private m_name: string;
        private m_utf8name: void*;
        private m_flags: PropertyAttributes;
        private m_reflectedTypeCache: RuntimeTypeCache;
        private m_getterMethod: RuntimeMethodInfo;
        private m_setterMethod: RuntimeMethodInfo;
        private m_otherMethod: MethodInfo[];
        private m_declaringType: RuntimeType;
        private m_bindingFlags: BindingFlags;
        private m_signature: Signature;
        private m_parameters: ParameterInfo[];

        private get Signature(): Signature {
            throw new Error("not yet implemented");
        }
        private get BindingFlags(): BindingFlags {
            throw new Error("not yet implemented");
        }
        public get MemberType(): MemberTypes {
            throw new Error("not yet implemented");
        }
        public get Name(): string {
            throw new Error("not yet implemented");
        }
        public get DeclaringType(): Type {
            throw new Error("not yet implemented");
        }
        public get ReflectedType(): Type {
            throw new Error("not yet implemented");
        }
        private get ReflectedTypeInternal(): RuntimeType {
            throw new Error("not yet implemented");
        }
        public get MetadataToken(): number {
            throw new Error("not yet implemented");
        }
        public get Module(): Module {
            throw new Error("not yet implemented");
        }
        public get IsCollectible(): boolean {
            throw new Error("not yet implemented");
        }
        public get PropertyType(): Type {
            throw new Error("not yet implemented");
        }
        public get Attributes(): PropertyAttributes {
            throw new Error("not yet implemented");
        }
        public get CanRead(): boolean {
            throw new Error("not yet implemented");
        }
        public get CanWrite(): boolean {
            throw new Error("not yet implemented");
        }

        protected constructor(tkProperty: number, declaredType: RuntimeType, reflectedTypeCache: RuntimeTypeCache, isPrivate: boolean) {
            throw new Error("not yet implemented");
        }

        private CacheEquals(o: any): boolean {
            throw new Error("not yet implemented");
        }
        private EqualsSig(target: RuntimePropertyInfo): boolean {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
        public GetCustomAttributes(inherit: boolean): any[] {
            throw new Error("not yet implemented");
        }
        public GetCustomAttributes(attributeType: Type, inherit: boolean): any[] {
            throw new Error("not yet implemented");
        }
        public IsDefined(attributeType: Type, inherit: boolean): boolean {
            throw new Error("not yet implemented");
        }
        public GetCustomAttributesData(): IList<CustomAttributeData> {
            throw new Error("not yet implemented");
        }
        public HasSameMetadataDefinitionAs(other: MemberInfo): boolean {
            throw new Error("not yet implemented");
        }
        private GetRuntimeModule(): RuntimeModule {
            throw new Error("not yet implemented");
        }
        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public GetRequiredCustomModifiers(): Type[] {
            throw new Error("not yet implemented");
        }
        public GetOptionalCustomModifiers(): Type[] {
            throw new Error("not yet implemented");
        }
        public GetModifiedPropertyType(): Type {
            throw new Error("not yet implemented");
        }
        private GetConstantValue(raw: boolean): any {
            throw new Error("not yet implemented");
        }
        public GetConstantValue(): any {
            throw new Error("not yet implemented");
        }
        public GetRawConstantValue(): any {
            throw new Error("not yet implemented");
        }
        public GetAccessors(nonPublic: boolean): MethodInfo[] {
            throw new Error("not yet implemented");
        }
        public GetGetMethod(nonPublic: boolean): RuntimeMethodInfo {
            throw new Error("not yet implemented");
        }
        public GetSetMethod(nonPublic: boolean): RuntimeMethodInfo {
            throw new Error("not yet implemented");
        }
        public GetIndexParameters(): ParameterInfo[] {
            throw new Error("not yet implemented");
        }
        private GetIndexParametersNoCopy(): ParameterInfo[] {
            throw new Error("not yet implemented");
        }
        public GetValue(obj: any, index: any[]): any {
            throw new Error("not yet implemented");
        }
        public GetValue(obj: any, invokeAttr: BindingFlags, binder: Binder, index: any[], culture: CultureInfo): any {
            throw new Error("not yet implemented");
        }
        public SetValue(obj: any, value: any, index: any[]) {
            throw new Error("not yet implemented");
        }
        public SetValue(obj: any, value: any, invokeAttr: BindingFlags, binder: Binder, index: any[], culture: CultureInfo) {
            throw new Error("not yet implemented");
        }
    }
    export class CustomAttributeData {
        public get AttributeType(): Type {
            throw new Error("not yet implemented");
        }
        public get Constructor(): ConstructorInfo {
            throw new Error("not yet implemented");
        }
        public get ConstructorArguments(): IList<CustomAttributeTypedArgument> {
            throw new Error("not yet implemented");
        }
        public get NamedArguments(): IList<CustomAttributeNamedArgument> {
            throw new Error("not yet implemented");
        }

        protected constructor() {
            throw new Error("not yet implemented");
        }

        public static GetCustomAttributes(target: MemberInfo): IList<CustomAttributeData> {
            throw new Error("not yet implemented");
        }
        public static GetCustomAttributes(target: Module): IList<CustomAttributeData> {
            throw new Error("not yet implemented");
        }
        public static GetCustomAttributes(target: Assembly): IList<CustomAttributeData> {
            throw new Error("not yet implemented");
        }
        public static GetCustomAttributes(target: ParameterInfo): IList<CustomAttributeData> {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
    }
    export class RuntimeParameterInfo extends ParameterInfo implements ICustomAttributeProvider, IObjectReference {
        private m_tkParamDef: number;
        private m_scope: MetadataImport;
        private m_signature: Signature;
        private m_nameIsCached: boolean;
        private m_noMetadata: boolean;
        private m_noDefaultValue: boolean;
        private m_originalMember: MethodBase;

        public get ParameterType(): Type {
            throw new Error("not yet implemented");
        }
        public get Name(): string {
            throw new Error("not yet implemented");
        }
        public get HasDefaultValue(): boolean {
            throw new Error("not yet implemented");
        }
        public get DefaultValue(): any {
            throw new Error("not yet implemented");
        }
        public get RawDefaultValue(): any {
            throw new Error("not yet implemented");
        }
        public get MetadataToken(): number {
            throw new Error("not yet implemented");
        }

        protected constructor(accessor: RuntimeParameterInfo, property: RuntimePropertyInfo) {
            throw new Error("not yet implemented");
        }
        private constructor(accessor: RuntimeParameterInfo, member: MemberInfo) {
            throw new Error("not yet implemented");
        }
        private constructor(signature: Signature, scope: MetadataImport, tkParamDef: number, position: number, attributes: ParameterAttributes, member: MemberInfo) {
            throw new Error("not yet implemented");
        }
        protected constructor(owner: MethodInfo, name: string, parameterType: Type, position: number) {
            throw new Error("not yet implemented");
        }

        private static GetParameters(method: IRuntimeMethodInfo, member: MemberInfo, sig: Signature): ParameterInfo[] {
            throw new Error("not yet implemented");
        }
        private static GetReturnParameter(method: IRuntimeMethodInfo, member: MemberInfo, sig: Signature): ParameterInfo {
            throw new Error("not yet implemented");
        }
        private static GetParameters(methodHandle: IRuntimeMethodInfo, member: MemberInfo, sig: Signature, out returnParameter: ParameterInfo, fetchReturnParameter: boolean): ParameterInfo[] {
            throw new Error("not yet implemented");
        }
        private SetName(name: string) {
            throw new Error("not yet implemented");
        }
        private SetAttributes(attributes: ParameterAttributes) {
            throw new Error("not yet implemented");
        }
        private GetDefaultValue(raw: boolean): any {
            throw new Error("not yet implemented");
        }
        private GetDefaultValueFromCustomAttributeData(): any {
            throw new Error("not yet implemented");
        }
        private GetDefaultValueFromCustomAttributes(): any {
            throw new Error("not yet implemented");
        }
        private TryGetDefaultValueInternal(raw: boolean, out defaultValue: any): boolean {
            throw new Error("not yet implemented");
        }
        private static GetRawDecimalConstant(attr: CustomAttributeData): number {
            throw new Error("not yet implemented");
        }
        private static GetRawDateTimeConstant(attr: CustomAttributeData): DateTime {
            throw new Error("not yet implemented");
        }
        private static GetRawConstant(attr: CustomAttributeData): any {
            throw new Error("not yet implemented");
        }
        private GetRuntimeModule(): RuntimeModule {
            throw new Error("not yet implemented");
        }
        public GetRequiredCustomModifiers(): Type[] {
            throw new Error("not yet implemented");
        }
        public GetOptionalCustomModifiers(): Type[] {
            throw new Error("not yet implemented");
        }
        public GetModifiedParameterType(): Type {
            throw new Error("not yet implemented");
        }
        public GetCustomAttributes(inherit: boolean): any[] {
            throw new Error("not yet implemented");
        }
        public GetCustomAttributes(attributeType: Type, inherit: boolean): any[] {
            throw new Error("not yet implemented");
        }
        public IsDefined(attributeType: Type, inherit: boolean): boolean {
            throw new Error("not yet implemented");
        }
        public GetCustomAttributesData(): IList<CustomAttributeData> {
            throw new Error("not yet implemented");
        }
        private static __GetRawDecimalConstant__g__GetConstructorArgument_32_0(args: IList<CustomAttributeTypedArgument>, index: number): number {
            throw new Error("not yet implemented");
        }
    }
    export enum ResourceLocation {
        Embedded = 0x1,
        ContainedInAnotherAssembly = 0x2,
        ContainedInManifestFile = 0x4,
    }
    export class ManifestResourceInfo {
        private __ReferencedAssembly__k__BackingField: Assembly;
        private __FileName__k__BackingField: string;
        private __ResourceLocation__k__BackingField: ResourceLocation;

        public get ReferencedAssembly(): Assembly {
            throw new Error("not yet implemented");
        }
        public get FileName(): string {
            throw new Error("not yet implemented");
        }
        public get ResourceLocation(): ResourceLocation {
            throw new Error("not yet implemented");
        }

        public constructor(containingAssembly: Assembly, containingFileName: string, resourceLocation: ResourceLocation) {
            throw new Error("not yet implemented");
        }

    }
    export class RuntimeModule extends Module implements ICustomAttributeProvider, ISerializable {
        private m_runtimeType: RuntimeType;
        private m_runtimeAssembly: RuntimeAssembly;
        private m_pRefClass: number;
        private m_pData: number;
        private m_pGlobals: number;
        private m_pFields: number;

        public get MDStreamVersion(): number {
            throw new Error("not yet implemented");
        }
        private get RuntimeType(): RuntimeType {
            throw new Error("not yet implemented");
        }
        private get MetadataImport(): MetadataImport {
            throw new Error("not yet implemented");
        }
        public get FullyQualifiedName(): string {
            throw new Error("not yet implemented");
        }
        public get ModuleVersionId(): Guid {
            throw new Error("not yet implemented");
        }
        public get MetadataToken(): number {
            throw new Error("not yet implemented");
        }
        public get ScopeName(): string {
            throw new Error("not yet implemented");
        }
        public get Name(): string {
            throw new Error("not yet implemented");
        }
        public get Assembly(): Assembly {
            throw new Error("not yet implemented");
        }

        protected constructor() {
            throw new Error("not yet implemented");
        }

        private static GetScopeName(module: QCallModule, retString: StringHandleOnStack) {
            throw new Error("not yet implemented");
        }
        private static GetFullyQualifiedName(module: QCallModule, retString: StringHandleOnStack) {
            throw new Error("not yet implemented");
        }
        private static GetTypes(module: RuntimeModule): RuntimeType[] {
            throw new Error("not yet implemented");
        }
        private GetDefinedTypes(): RuntimeType[] {
            throw new Error("not yet implemented");
        }
        private static ConvertToTypeHandleArray(genericArguments: Type[]): RuntimeTypeHandle[] {
            throw new Error("not yet implemented");
        }
        public ResolveSignature(metadataToken: number): number[] {
            throw new Error("not yet implemented");
        }
        public ResolveMethod(metadataToken: number, genericTypeArguments: Type[], genericMethodArguments: Type[]): MethodBase {
            throw new Error("not yet implemented");
        }
        private ResolveLiteralField(metadataToken: number, genericTypeArguments: Type[], genericMethodArguments: Type[]): FieldInfo {
            throw new Error("not yet implemented");
        }
        public ResolveField(metadataToken: number, genericTypeArguments: Type[], genericMethodArguments: Type[]): FieldInfo {
            throw new Error("not yet implemented");
        }
        public ResolveType(metadataToken: number, genericTypeArguments: Type[], genericMethodArguments: Type[]): Type {
            throw new Error("not yet implemented");
        }
        public ResolveMember(metadataToken: number, genericTypeArguments: Type[], genericMethodArguments: Type[]): MemberInfo {
            throw new Error("not yet implemented");
        }
        public ResolveString(metadataToken: number): string {
            throw new Error("not yet implemented");
        }
        public GetPEKind(out peKind: PortableExecutableKinds, out machine: ImageFileMachine) {
            throw new Error("not yet implemented");
        }
        private GetMethodImpl(name: string, bindingAttr: BindingFlags, binder: Binder, callConvention: CallingConventions, types: Type[], modifiers: ParameterModifier[]): MethodInfo {
            throw new Error("not yet implemented");
        }
        private GetMethodInternal(name: string, bindingAttr: BindingFlags, binder: Binder, callConvention: CallingConventions, types: Type[], modifiers: ParameterModifier[]): MethodInfo {
            throw new Error("not yet implemented");
        }
        public GetCustomAttributes(inherit: boolean): any[] {
            throw new Error("not yet implemented");
        }
        public GetCustomAttributes(attributeType: Type, inherit: boolean): any[] {
            throw new Error("not yet implemented");
        }
        public IsDefined(attributeType: Type, inherit: boolean): boolean {
            throw new Error("not yet implemented");
        }
        public GetCustomAttributesData(): IList<CustomAttributeData> {
            throw new Error("not yet implemented");
        }
        public GetObjectData(info: SerializationInfo, context: StreamingContext) {
            throw new Error("not yet implemented");
        }
        public GetType(className: string, throwOnError: boolean, ignoreCase: boolean): Type {
            throw new Error("not yet implemented");
        }
        private GetFullyQualifiedName(): string {
            throw new Error("not yet implemented");
        }
        public GetTypes(): Type[] {
            throw new Error("not yet implemented");
        }
        public IsResource(): boolean {
            throw new Error("not yet implemented");
        }
        public GetFields(bindingFlags: BindingFlags): FieldInfo[] {
            throw new Error("not yet implemented");
        }
        public GetField(name: string, bindingAttr: BindingFlags): FieldInfo {
            throw new Error("not yet implemented");
        }
        public GetMethods(bindingFlags: BindingFlags): MethodInfo[] {
            throw new Error("not yet implemented");
        }
        private GetRuntimeAssembly(): RuntimeAssembly {
            throw new Error("not yet implemented");
        }
        private GetModuleHandleImpl(): ModuleHandle {
            throw new Error("not yet implemented");
        }
        private GetUnderlyingNativeHandle(): number {
            throw new Error("not yet implemented");
        }
    }
    export abstract class Module implements ICustomAttributeProvider, ISerializable {
        public static readonly FilterTypeName: TypeFilter;
        public static readonly FilterTypeNameIgnoreCase: TypeFilter;

        public get Assembly(): Assembly {
            throw new Error("not yet implemented");
        }
        public get FullyQualifiedName(): string {
            throw new Error("not yet implemented");
        }
        public get Name(): string {
            throw new Error("not yet implemented");
        }
        public get MDStreamVersion(): number {
            throw new Error("not yet implemented");
        }
        public get ModuleVersionId(): Guid {
            throw new Error("not yet implemented");
        }
        public get ScopeName(): string {
            throw new Error("not yet implemented");
        }
        public get ModuleHandle(): ModuleHandle {
            throw new Error("not yet implemented");
        }
        public get CustomAttributes(): IEnumerable<CustomAttributeData> {
            throw new Error("not yet implemented");
        }
        public get MetadataToken(): number {
            throw new Error("not yet implemented");
        }

        protected constructor() {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

        private GetModuleHandleImpl(): ModuleHandle {
            throw new Error("not yet implemented");
        }
        public GetPEKind(out peKind: PortableExecutableKinds, out machine: ImageFileMachine) {
            throw new Error("not yet implemented");
        }
        public IsResource(): boolean {
            throw new Error("not yet implemented");
        }
        public IsDefined(attributeType: Type, inherit: boolean): boolean {
            throw new Error("not yet implemented");
        }
        public GetCustomAttributesData(): IList<CustomAttributeData> {
            throw new Error("not yet implemented");
        }
        public GetCustomAttributes(inherit: boolean): any[] {
            throw new Error("not yet implemented");
        }
        public GetCustomAttributes(attributeType: Type, inherit: boolean): any[] {
            throw new Error("not yet implemented");
        }
        public GetMethod(name: string): MethodInfo {
            throw new Error("not yet implemented");
        }
        public GetMethod(name: string, types: Type[]): MethodInfo {
            throw new Error("not yet implemented");
        }
        public GetMethod(name: string, bindingAttr: BindingFlags, binder: Binder, callConvention: CallingConventions, types: Type[], modifiers: ParameterModifier[]): MethodInfo {
            throw new Error("not yet implemented");
        }
        private GetMethodImpl(name: string, bindingAttr: BindingFlags, binder: Binder, callConvention: CallingConventions, types: Type[], modifiers: ParameterModifier[]): MethodInfo {
            throw new Error("not yet implemented");
        }
        public GetMethods(): MethodInfo[] {
            throw new Error("not yet implemented");
        }
        public GetMethods(bindingFlags: BindingFlags): MethodInfo[] {
            throw new Error("not yet implemented");
        }
        public GetField(name: string): FieldInfo {
            throw new Error("not yet implemented");
        }
        public GetField(name: string, bindingAttr: BindingFlags): FieldInfo {
            throw new Error("not yet implemented");
        }
        public GetFields(): FieldInfo[] {
            throw new Error("not yet implemented");
        }
        public GetFields(bindingFlags: BindingFlags): FieldInfo[] {
            throw new Error("not yet implemented");
        }
        public GetTypes(): Type[] {
            throw new Error("not yet implemented");
        }
        public GetType(className: string): Type {
            throw new Error("not yet implemented");
        }
        public GetType(className: string, ignoreCase: boolean): Type {
            throw new Error("not yet implemented");
        }
        public GetType(className: string, throwOnError: boolean, ignoreCase: boolean): Type {
            throw new Error("not yet implemented");
        }
        public FindTypes(filter: TypeFilter, filterCriteria: any): Type[] {
            throw new Error("not yet implemented");
        }
        public ResolveField(metadataToken: number): FieldInfo {
            throw new Error("not yet implemented");
        }
        public ResolveField(metadataToken: number, genericTypeArguments: Type[], genericMethodArguments: Type[]): FieldInfo {
            throw new Error("not yet implemented");
        }
        public ResolveMember(metadataToken: number): MemberInfo {
            throw new Error("not yet implemented");
        }
        public ResolveMember(metadataToken: number, genericTypeArguments: Type[], genericMethodArguments: Type[]): MemberInfo {
            throw new Error("not yet implemented");
        }
        public ResolveMethod(metadataToken: number): MethodBase {
            throw new Error("not yet implemented");
        }
        public ResolveMethod(metadataToken: number, genericTypeArguments: Type[], genericMethodArguments: Type[]): MethodBase {
            throw new Error("not yet implemented");
        }
        public ResolveSignature(metadataToken: number): number[] {
            throw new Error("not yet implemented");
        }
        public ResolveString(metadataToken: number): string {
            throw new Error("not yet implemented");
        }
        public ResolveType(metadataToken: number): Type {
            throw new Error("not yet implemented");
        }
        public ResolveType(metadataToken: number, genericTypeArguments: Type[], genericMethodArguments: Type[]): Type {
            throw new Error("not yet implemented");
        }
        public GetObjectData(info: SerializationInfo, context: StreamingContext) {
            throw new Error("not yet implemented");
        }
        public Equals(o: any): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
        private static FilterTypeNameImpl(cls: Type, filterCriteria: any, comparison: StringComparison): boolean {
            throw new Error("not yet implemented");
        }
    }
    export namespace Module {
        export class ____c {
            public static readonly ____9: ____c;

            private static staticctor_initialize = (() => {
                throw new Error("not yet implemented");
            })();
            private constructor() { }
            public constructor() {
                throw new Error("not yet implemented");
            }

            private ___cctor__b__62_0(m: Type, c: any): boolean {
                throw new Error("not yet implemented");
            }
            private ___cctor__b__62_1(m: Type, c: any): boolean {
                throw new Error("not yet implemented");
            }
        }
    }
    export abstract class RuntimeFieldInfo extends FieldInfo implements ICustomAttributeProvider {
        private m_bindingFlags: BindingFlags;
        private m_reflectedTypeCache: RuntimeTypeCache;
        private m_declaringType: RuntimeType;

        private get BindingFlags(): BindingFlags {
            throw new Error("not yet implemented");
        }
        private get ReflectedTypeInternal(): RuntimeType {
            throw new Error("not yet implemented");
        }
        public get MemberType(): MemberTypes {
            throw new Error("not yet implemented");
        }
        public get ReflectedType(): Type {
            throw new Error("not yet implemented");
        }
        public get DeclaringType(): Type {
            throw new Error("not yet implemented");
        }
        public get Module(): Module {
            throw new Error("not yet implemented");
        }
        public get IsCollectible(): boolean {
            throw new Error("not yet implemented");
        }

        protected constructor(reflectedTypeCache: RuntimeTypeCache, declaringType: RuntimeType, bindingFlags: BindingFlags) {
            throw new Error("not yet implemented");
        }

        private GetDeclaringTypeInternal(): RuntimeType {
            throw new Error("not yet implemented");
        }
        private GetRuntimeType(): RuntimeType {
            throw new Error("not yet implemented");
        }
        private GetRuntimeModule(): RuntimeModule;
        public HasSameMetadataDefinitionAs(other: MemberInfo): boolean {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
        public GetCustomAttributes(inherit: boolean): any[] {
            throw new Error("not yet implemented");
        }
        public GetCustomAttributes(attributeType: Type, inherit: boolean): any[] {
            throw new Error("not yet implemented");
        }
        public IsDefined(attributeType: Type, inherit: boolean): boolean {
            throw new Error("not yet implemented");
        }
        public GetCustomAttributesData(): IList<CustomAttributeData> {
            throw new Error("not yet implemented");
        }
    }
    export class RtFieldInfo extends RuntimeFieldInfo implements ICustomAttributeProvider, IRuntimeFieldInfo {
        private m_fieldHandle: number;
        private m_fieldAttributes: FieldAttributes;
        private m_name: string;
        private m_fieldType: RuntimeType;
        private m_invocationFlags: InvocationFlags;

        private get InvocationFlags(): InvocationFlags {
            throw new Error("not yet implemented");
        }
        private get __explicit__IRuntimeFieldInfo_Value(): RuntimeFieldHandleInternal {
            throw new Error("not yet implemented");
        }
        public get Value(): RuntimeFieldHandleInternal {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        public get Name(): string {
            throw new Error("not yet implemented");
        }
        public get MetadataToken(): number {
            throw new Error("not yet implemented");
        }
        public get FieldHandle(): RuntimeFieldHandle {
            throw new Error("not yet implemented");
        }
        public get Attributes(): FieldAttributes {
            throw new Error("not yet implemented");
        }
        public get FieldType(): Type {
            throw new Error("not yet implemented");
        }

        protected constructor(handle: RuntimeFieldHandleInternal, declaringType: RuntimeType, reflectedTypeCache: RuntimeTypeCache, bindingFlags: BindingFlags) {
            throw new Error("not yet implemented");
        }

        private InitializeInvocationFlags(): InvocationFlags {
            throw new Error("not yet implemented");
        }
        private CheckConsistency(target: any) {
            throw new Error("not yet implemented");
        }
        private CacheEquals(o: any): boolean {
            throw new Error("not yet implemented");
        }
        private GetRuntimeModule(): RuntimeModule {
            throw new Error("not yet implemented");
        }
        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public GetValue(obj: any): any {
            throw new Error("not yet implemented");
        }
        public GetRawConstantValue(): any {
            throw new Error("not yet implemented");
        }
        public GetValueDirect(obj: TypedReference): any {
            throw new Error("not yet implemented");
        }
        public SetValue(obj: any, value: any, invokeAttr: BindingFlags, binder: Binder, culture: CultureInfo) {
            throw new Error("not yet implemented");
        }
        public SetValueDirect(obj: TypedReference, value: any) {
            throw new Error("not yet implemented");
        }
        private GetFieldHandle(): number {
            throw new Error("not yet implemented");
        }
        private InitializeFieldType(): RuntimeType {
            throw new Error("not yet implemented");
        }
        public GetRequiredCustomModifiers(): Type[] {
            throw new Error("not yet implemented");
        }
        public GetOptionalCustomModifiers(): Type[] {
            throw new Error("not yet implemented");
        }
        private GetSignature(): Signature {
            throw new Error("not yet implemented");
        }
        public GetModifiedFieldType(): Type {
            throw new Error("not yet implemented");
        }

        public readonly ExplicitAsICustomAttributeProvider: ICustomAttributeProvider = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Value') {
                    return target.__explicit__IRuntimeFieldInfo_Value;
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIRuntimeFieldInfo: IRuntimeFieldInfo = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Value') {
                    return target.__explicit__IRuntimeFieldInfo_Value;
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
    }
    export class LoaderAllocatorScout {
        private m_nativeLoaderAllocator: number;

        public constructor() {
            throw new Error("not yet implemented");
        }

        private static Destroy(nativeLoaderAllocator: number): boolean {
            throw new Error("not yet implemented");
        }
        private Finalize() {
            throw new Error("not yet implemented");
        }
        private static __Destroy__g____PInvoke_1_0(__nativeLoaderAllocator_native: number): number {
            throw new Error("not yet implemented");
        }
    }
    export class LoaderAllocator {
        private m_scout: LoaderAllocatorScout;
        private m_slots: any[];
        private m_methodInstantiations: CerHashtable<RuntimeMethodInfo, RuntimeMethodInfo>;
        private m_slotsUsed: number;

        private constructor() {
            throw new Error("not yet implemented");
        }

    }
    export abstract class FieldInfo extends MemberInfo implements ICustomAttributeProvider {
        public get MemberType(): MemberTypes {
            throw new Error("not yet implemented");
        }
        public get Attributes(): FieldAttributes;
        public get FieldType(): Type;
        public get IsInitOnly(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsLiteral(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsNotSerialized(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsPinvokeImpl(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsSpecialName(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsStatic(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsAssembly(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsFamily(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsFamilyAndAssembly(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsFamilyOrAssembly(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsPrivate(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsPublic(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsSecurityCritical(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsSecuritySafeCritical(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsSecurityTransparent(): boolean {
            throw new Error("not yet implemented");
        }
        public get FieldHandle(): RuntimeFieldHandle;

        protected constructor() {
            throw new Error("not yet implemented");
        }

        public static GetFieldFromHandle(handle: RuntimeFieldHandle): FieldInfo {
            throw new Error("not yet implemented");
        }
        public static GetFieldFromHandle(handle: RuntimeFieldHandle, declaringType: RuntimeTypeHandle): FieldInfo {
            throw new Error("not yet implemented");
        }
        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public GetValue(obj: any): any;
        public SetValue(obj: any, value: any) {
            throw new Error("not yet implemented");
        }
        public SetValue(obj: any, value: any, invokeAttr: BindingFlags, binder: Binder, culture: CultureInfo): void;
        public SetValueDirect(obj: TypedReference, value: any) {
            throw new Error("not yet implemented");
        }
        public GetValueDirect(obj: TypedReference): any {
            throw new Error("not yet implemented");
        }
        public GetRawConstantValue(): any {
            throw new Error("not yet implemented");
        }
        public GetModifiedFieldType(): Type {
            throw new Error("not yet implemented");
        }
        public GetOptionalCustomModifiers(): Type[] {
            throw new Error("not yet implemented");
        }
        public GetRequiredCustomModifiers(): Type[] {
            throw new Error("not yet implemented");
        }
    }
    export abstract class EventInfo extends MemberInfo implements ICustomAttributeProvider {
        public get MemberType(): MemberTypes {
            throw new Error("not yet implemented");
        }
        public get Attributes(): EventAttributes;
        public get IsSpecialName(): boolean {
            throw new Error("not yet implemented");
        }
        public get AddMethod(): MethodInfo {
            throw new Error("not yet implemented");
        }
        public get RemoveMethod(): MethodInfo {
            throw new Error("not yet implemented");
        }
        public get RaiseMethod(): MethodInfo {
            throw new Error("not yet implemented");
        }
        public get IsMulticast(): boolean {
            throw new Error("not yet implemented");
        }
        public get EventHandlerType(): Type {
            throw new Error("not yet implemented");
        }

        protected constructor() {
            throw new Error("not yet implemented");
        }

        public GetOtherMethods(): MethodInfo[] {
            throw new Error("not yet implemented");
        }
        public GetOtherMethods(nonPublic: boolean): MethodInfo[] {
            throw new Error("not yet implemented");
        }
        public GetAddMethod(): MethodInfo {
            throw new Error("not yet implemented");
        }
        public GetRemoveMethod(): MethodInfo {
            throw new Error("not yet implemented");
        }
        public GetRaiseMethod(): MethodInfo {
            throw new Error("not yet implemented");
        }
        public GetAddMethod(nonPublic: boolean): MethodInfo;
        public GetRemoveMethod(nonPublic: boolean): MethodInfo;
        public GetRaiseMethod(nonPublic: boolean): MethodInfo;
        public AddEventHandler(target: any, handler: Delegate) {
            throw new Error("not yet implemented");
        }
        public RemoveEventHandler(target: any, handler: Delegate) {
            throw new Error("not yet implemented");
        }
        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
    }
    export class RuntimeEventInfo extends EventInfo implements ICustomAttributeProvider {
        private m_token: number;
        private m_flags: EventAttributes;
        private m_name: string;
        private m_utf8name: void*;
        private m_reflectedTypeCache: RuntimeTypeCache;
        private m_addMethod: RuntimeMethodInfo;
        private m_removeMethod: RuntimeMethodInfo;
        private m_raiseMethod: RuntimeMethodInfo;
        private m_otherMethod: MethodInfo[];
        private m_declaringType: RuntimeType;
        private m_bindingFlags: BindingFlags;

        private get BindingFlags(): BindingFlags {
            throw new Error("not yet implemented");
        }
        public get MemberType(): MemberTypes {
            throw new Error("not yet implemented");
        }
        public get Name(): string {
            throw new Error("not yet implemented");
        }
        public get DeclaringType(): Type {
            throw new Error("not yet implemented");
        }
        public get ReflectedType(): Type {
            throw new Error("not yet implemented");
        }
        private get ReflectedTypeInternal(): RuntimeType {
            throw new Error("not yet implemented");
        }
        public get MetadataToken(): number {
            throw new Error("not yet implemented");
        }
        public get Module(): Module {
            throw new Error("not yet implemented");
        }
        public get Attributes(): EventAttributes {
            throw new Error("not yet implemented");
        }

        protected constructor(tkEvent: number, declaredType: RuntimeType, reflectedTypeCache: RuntimeTypeCache, isPrivate: boolean) {
            throw new Error("not yet implemented");
        }

        private CacheEquals(o: any): boolean {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public GetCustomAttributes(inherit: boolean): any[] {
            throw new Error("not yet implemented");
        }
        public GetCustomAttributes(attributeType: Type, inherit: boolean): any[] {
            throw new Error("not yet implemented");
        }
        public IsDefined(attributeType: Type, inherit: boolean): boolean {
            throw new Error("not yet implemented");
        }
        public GetCustomAttributesData(): IList<CustomAttributeData> {
            throw new Error("not yet implemented");
        }
        public HasSameMetadataDefinitionAs(other: MemberInfo): boolean {
            throw new Error("not yet implemented");
        }
        private GetRuntimeModule(): RuntimeModule {
            throw new Error("not yet implemented");
        }
        public GetOtherMethods(nonPublic: boolean): MethodInfo[] {
            throw new Error("not yet implemented");
        }
        public GetAddMethod(nonPublic: boolean): MethodInfo {
            throw new Error("not yet implemented");
        }
        public GetRemoveMethod(nonPublic: boolean): MethodInfo {
            throw new Error("not yet implemented");
        }
        public GetRaiseMethod(nonPublic: boolean): MethodInfo {
            throw new Error("not yet implemented");
        }
    }
    export class RuntimeMethodInfo extends MethodInfo implements ICustomAttributeProvider, IRuntimeMethodInfo {
        private m_handle: number;
        private m_reflectedTypeCache: RuntimeTypeCache;
        private m_name: string;
        private m_toString: string;
        private m_parameters: ParameterInfo[];
        private m_returnParameter: ParameterInfo;
        private m_bindingFlags: BindingFlags;
        private m_methodAttributes: MethodAttributes;
        private m_signature: Signature;
        private m_declaringType: RuntimeType;
        private m_keepalive: any;
        private m_invoker: MethodBaseInvoker;

        private get InvocationFlags(): InvocationFlags {
            throw new Error("not yet implemented");
        }
        private get Invoker(): MethodBaseInvoker {
            throw new Error("not yet implemented");
        }
        private get __explicit__IRuntimeMethodInfo_Value(): RuntimeMethodHandleInternal {
            throw new Error("not yet implemented");
        }
        public get Value(): RuntimeMethodHandleInternal {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private get ReflectedTypeInternal(): RuntimeType {
            throw new Error("not yet implemented");
        }
        private get Signature(): Signature {
            throw new Error("not yet implemented");
        }
        private get BindingFlags(): BindingFlags {
            throw new Error("not yet implemented");
        }
        private get GenericParameterCount(): number {
            throw new Error("not yet implemented");
        }
        public get Name(): string {
            throw new Error("not yet implemented");
        }
        public get DeclaringType(): Type {
            throw new Error("not yet implemented");
        }
        public get ReflectedType(): Type {
            throw new Error("not yet implemented");
        }
        public get MemberType(): MemberTypes {
            throw new Error("not yet implemented");
        }
        public get MetadataToken(): number {
            throw new Error("not yet implemented");
        }
        public get Module(): Module {
            throw new Error("not yet implemented");
        }
        public get IsSecurityCritical(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsSecuritySafeCritical(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsSecurityTransparent(): boolean {
            throw new Error("not yet implemented");
        }
        public get MethodHandle(): RuntimeMethodHandle {
            throw new Error("not yet implemented");
        }
        public get Attributes(): MethodAttributes {
            throw new Error("not yet implemented");
        }
        public get CallingConvention(): CallingConventions {
            throw new Error("not yet implemented");
        }
        private get ArgumentTypes(): RuntimeType[] {
            throw new Error("not yet implemented");
        }
        public get ReturnType(): Type {
            throw new Error("not yet implemented");
        }
        public get ReturnTypeCustomAttributes(): ICustomAttributeProvider {
            throw new Error("not yet implemented");
        }
        public get ReturnParameter(): ParameterInfo {
            throw new Error("not yet implemented");
        }
        public get IsCollectible(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsGenericMethod(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsGenericMethodDefinition(): boolean {
            throw new Error("not yet implemented");
        }
        public get ContainsGenericParameters(): boolean {
            throw new Error("not yet implemented");
        }

        protected constructor(handle: RuntimeMethodHandleInternal, declaringType: RuntimeType, reflectedTypeCache: RuntimeTypeCache, methodAttributes: MethodAttributes, bindingFlags: BindingFlags, keepalive: any) {
            throw new Error("not yet implemented");
        }

        private FetchNonReturnParameters(): ParameterInfo[] {
            throw new Error("not yet implemented");
        }
        private FetchReturnParameter(): ParameterInfo {
            throw new Error("not yet implemented");
        }
        private CacheEquals(o: any): boolean {
            throw new Error("not yet implemented");
        }
        private GetParentDefinition(): RuntimeMethodInfo {
            throw new Error("not yet implemented");
        }
        private GetDeclaringTypeInternal(): RuntimeType {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public GetCustomAttributes(inherit: boolean): any[] {
            throw new Error("not yet implemented");
        }
        public GetCustomAttributes(attributeType: Type, inherit: boolean): any[] {
            throw new Error("not yet implemented");
        }
        public IsDefined(attributeType: Type, inherit: boolean): boolean {
            throw new Error("not yet implemented");
        }
        public GetCustomAttributesData(): IList<CustomAttributeData> {
            throw new Error("not yet implemented");
        }
        public HasSameMetadataDefinitionAs(other: MemberInfo): boolean {
            throw new Error("not yet implemented");
        }
        private GetRuntimeType(): RuntimeType {
            throw new Error("not yet implemented");
        }
        private GetRuntimeModule(): RuntimeModule {
            throw new Error("not yet implemented");
        }
        private GetParametersNoCopy(): ParameterInfo[] {
            throw new Error("not yet implemented");
        }
        public GetParameters(): ParameterInfo[] {
            throw new Error("not yet implemented");
        }
        public GetMethodImplementationFlags(): MethodImplAttributes {
            throw new Error("not yet implemented");
        }
        public GetMethodBody(): MethodBody {
            throw new Error("not yet implemented");
        }
        private InvokePropertySetter(obj: any, invokeAttr: BindingFlags, binder: Binder, parameter: any, culture: CultureInfo) {
            throw new Error("not yet implemented");
        }
        public GetBaseDefinition(): MethodInfo {
            throw new Error("not yet implemented");
        }
        public CreateDelegate(delegateType: Type): Delegate {
            throw new Error("not yet implemented");
        }
        public CreateDelegate(delegateType: Type, target: any): Delegate {
            throw new Error("not yet implemented");
        }
        private CreateDelegateInternal(delegateType: Type, firstArgument: any, bindingFlags: DelegateBindingFlags): Delegate {
            throw new Error("not yet implemented");
        }
        public MakeGenericMethod(methodInstantiation: Type[]): MethodInfo {
            throw new Error("not yet implemented");
        }
        private GetGenericArgumentsInternal(): RuntimeType[] {
            throw new Error("not yet implemented");
        }
        public GetGenericArguments(): Type[] {
            throw new Error("not yet implemented");
        }
        public GetGenericMethodDefinition(): MethodInfo {
            throw new Error("not yet implemented");
        }
        private static InternalGetCurrentMethod(ref stackMark: StackCrawlMark): MethodBase {
            throw new Error("not yet implemented");
        }
        private ComputeAndUpdateInvocationFlags(): InvocationFlags {
            throw new Error("not yet implemented");
        }
        private ThrowNoInvokeException() {
            throw new Error("not yet implemented");
        }
        public Invoke(obj: any, invokeAttr: BindingFlags, binder: Binder, parameters: any[], culture: CultureInfo): any {
            throw new Error("not yet implemented");
        }
        private __get_Signature__g__LazyCreateSignature_25_0(): Signature {
            throw new Error("not yet implemented");
        }
        private static __ComputeAndUpdateInvocationFlags__g__IsDisallowedByRefType_97_0(type: Type): boolean {
            throw new Error("not yet implemented");
        }

        public readonly ExplicitAsICustomAttributeProvider: ICustomAttributeProvider = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Value') {
                    return target.__explicit__IRuntimeMethodInfo_Value;
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIRuntimeMethodInfo: IRuntimeMethodInfo = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Value') {
                    return target.__explicit__IRuntimeMethodInfo_Value;
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
    }
    export class ModuleResolveEventHandler extends MulticastDelegate implements ICloneable, ISerializable {
        public constructor(object: any, method: number) {
            throw new Error("not yet implemented");
        }

        public Invoke(sender: any, e: ResolveEventArgs): Module {
            throw new Error("not yet implemented");
        }
        public BeginInvoke(sender: any, e: ResolveEventArgs, callback: AsyncCallback, object: any): IAsyncResult {
            throw new Error("not yet implemented");
        }
        public EndInvoke(result: IAsyncResult): Module {
            throw new Error("not yet implemented");
        }
    }
    export abstract class Assembly implements ICustomAttributeProvider, ISerializable {
        private static readonly s_loadfile: Dictionary<string, Assembly>;
        private static readonly s_loadFromAssemblyList: List<string>;
        private static s_loadFromHandlerSet: boolean;
        private static s_cachedSerializationSwitch: number;
        private static s_overriddenEntryAssembly: any;

        public get DefinedTypes(): IEnumerable<TypeInfo> {
            throw new Error("not yet implemented");
        }
        public get ExportedTypes(): IEnumerable<Type> {
            throw new Error("not yet implemented");
        }
        public get CodeBase(): string {
            throw new Error("not yet implemented");
        }
        public get EntryPoint(): MethodInfo {
            throw new Error("not yet implemented");
        }
        public get FullName(): string {
            throw new Error("not yet implemented");
        }
        public get ImageRuntimeVersion(): string {
            throw new Error("not yet implemented");
        }
        public get IsDynamic(): boolean {
            throw new Error("not yet implemented");
        }
        public get Location(): string {
            throw new Error("not yet implemented");
        }
        public get ReflectionOnly(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsCollectible(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsFullyTrusted(): boolean {
            throw new Error("not yet implemented");
        }
        public get CustomAttributes(): IEnumerable<CustomAttributeData> {
            throw new Error("not yet implemented");
        }
        public get EscapedCodeBase(): string {
            throw new Error("not yet implemented");
        }
        public get ManifestModule(): Module {
            throw new Error("not yet implemented");
        }
        public get Modules(): IEnumerable<Module> {
            throw new Error("not yet implemented");
        }
        public get GlobalAssemblyCache(): boolean {
            throw new Error("not yet implemented");
        }
        public get HostContext(): number {
            throw new Error("not yet implemented");
        }
        public get SecurityRuleSet(): SecurityRuleSet {
            throw new Error("not yet implemented");
        }

        protected constructor() {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

        public static Load(assemblyString: string): Assembly {
            throw new Error("not yet implemented");
        }
        public static LoadWithPartialName(partialName: string): Assembly {
            throw new Error("not yet implemented");
        }
        public static Load(assemblyRef: AssemblyName): Assembly {
            throw new Error("not yet implemented");
        }
        private static GetExecutingAssemblyNative(stackMark: StackCrawlMarkHandle, retAssembly: ObjectHandleOnStack) {
            throw new Error("not yet implemented");
        }
        private static GetExecutingAssembly(ref stackMark: StackCrawlMark): RuntimeAssembly {
            throw new Error("not yet implemented");
        }
        public static GetExecutingAssembly(): Assembly {
            throw new Error("not yet implemented");
        }
        public static GetCallingAssembly(): Assembly {
            throw new Error("not yet implemented");
        }
        private static GetEntryAssemblyNative(retAssembly: ObjectHandleOnStack) {
            throw new Error("not yet implemented");
        }
        private static GetEntryAssemblyInternal(): RuntimeAssembly {
            throw new Error("not yet implemented");
        }
        private static GetAssemblyCount(): number {
            throw new Error("not yet implemented");
        }
        public GetTypes(): Type[] {
            throw new Error("not yet implemented");
        }
        public GetExportedTypes(): Type[] {
            throw new Error("not yet implemented");
        }
        public GetForwardedTypes(): Type[] {
            throw new Error("not yet implemented");
        }
        public GetManifestResourceInfo(resourceName: string): ManifestResourceInfo {
            throw new Error("not yet implemented");
        }
        public GetManifestResourceNames(): string[] {
            throw new Error("not yet implemented");
        }
        public GetManifestResourceStream(name: string): Stream {
            throw new Error("not yet implemented");
        }
        public GetManifestResourceStream(type: Type, name: string): Stream {
            throw new Error("not yet implemented");
        }
        public GetName(): AssemblyName {
            throw new Error("not yet implemented");
        }
        public GetName(copiedName: boolean): AssemblyName {
            throw new Error("not yet implemented");
        }
        public GetType(name: string): Type {
            throw new Error("not yet implemented");
        }
        public GetType(name: string, throwOnError: boolean): Type {
            throw new Error("not yet implemented");
        }
        public GetType(name: string, throwOnError: boolean, ignoreCase: boolean): Type {
            throw new Error("not yet implemented");
        }
        public IsDefined(attributeType: Type, inherit: boolean): boolean {
            throw new Error("not yet implemented");
        }
        public GetCustomAttributesData(): IList<CustomAttributeData> {
            throw new Error("not yet implemented");
        }
        public GetCustomAttributes(inherit: boolean): any[] {
            throw new Error("not yet implemented");
        }
        public GetCustomAttributes(attributeType: Type, inherit: boolean): any[] {
            throw new Error("not yet implemented");
        }
        public CreateInstance(typeName: string): any {
            throw new Error("not yet implemented");
        }
        public CreateInstance(typeName: string, ignoreCase: boolean): any {
            throw new Error("not yet implemented");
        }
        public CreateInstance(typeName: string, ignoreCase: boolean, bindingAttr: BindingFlags, binder: Binder, args: any[], culture: CultureInfo, activationAttributes: any[]): any {
            throw new Error("not yet implemented");
        }
        public GetModule(name: string): Module {
            throw new Error("not yet implemented");
        }
        public GetModules(): Module[] {
            throw new Error("not yet implemented");
        }
        public GetModules(getResourceModules: boolean): Module[] {
            throw new Error("not yet implemented");
        }
        public GetLoadedModules(): Module[] {
            throw new Error("not yet implemented");
        }
        public GetLoadedModules(getResourceModules: boolean): Module[] {
            throw new Error("not yet implemented");
        }
        public GetReferencedAssemblies(): AssemblyName[] {
            throw new Error("not yet implemented");
        }
        public GetSatelliteAssembly(culture: CultureInfo): Assembly {
            throw new Error("not yet implemented");
        }
        public GetSatelliteAssembly(culture: CultureInfo, version: Version): Assembly {
            throw new Error("not yet implemented");
        }
        public GetFile(name: string): FileStream {
            throw new Error("not yet implemented");
        }
        public GetFiles(): FileStream[] {
            throw new Error("not yet implemented");
        }
        public GetFiles(getResourceModules: boolean): FileStream[] {
            throw new Error("not yet implemented");
        }
        public GetObjectData(info: SerializationInfo, context: StreamingContext) {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
        public Equals(o: any): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public static CreateQualifiedName(assemblyName: string, typeName: string): string {
            throw new Error("not yet implemented");
        }
        public static GetAssembly(type: Type): Assembly {
            throw new Error("not yet implemented");
        }
        public static SetEntryAssembly(assembly: Assembly) {
            throw new Error("not yet implemented");
        }
        public static GetEntryAssembly(): Assembly {
            throw new Error("not yet implemented");
        }
        public static Load(rawAssembly: number[]): Assembly {
            throw new Error("not yet implemented");
        }
        public static Load(rawAssembly: number[], rawSymbolStore: number[]): Assembly {
            throw new Error("not yet implemented");
        }
        public static LoadFile(path: string): Assembly {
            throw new Error("not yet implemented");
        }
        private static LoadFromResolveHandler(sender: any, args: ResolveEventArgs): Assembly {
            throw new Error("not yet implemented");
        }
        public static LoadFrom(assemblyFile: string): Assembly {
            throw new Error("not yet implemented");
        }
        public static LoadFrom(assemblyFile: string, hashValue: number[], hashAlgorithm: AssemblyHashAlgorithm): Assembly {
            throw new Error("not yet implemented");
        }
        public static UnsafeLoadFrom(assemblyFile: string): Assembly {
            throw new Error("not yet implemented");
        }
        public LoadModule(moduleName: string, rawModule: number[]): Module {
            throw new Error("not yet implemented");
        }
        public LoadModule(moduleName: string, rawModule: number[], rawSymbolStore: number[]): Module {
            throw new Error("not yet implemented");
        }
        public static ReflectionOnlyLoad(rawAssembly: number[]): Assembly {
            throw new Error("not yet implemented");
        }
        public static ReflectionOnlyLoad(assemblyString: string): Assembly {
            throw new Error("not yet implemented");
        }
        public static ReflectionOnlyLoadFrom(assemblyFile: string): Assembly {
            throw new Error("not yet implemented");
        }
    }
    export namespace Assembly {
        export class ____O {
            public static __0____LoadFromResolveHandler: ResolveEventHandler;

        }
    }
    export class RuntimeAssembly extends Assembly implements ICustomAttributeProvider, ISerializable {
        private _ModuleResolve: ModuleResolveEventHandler;
        private m_fullname: string;
        private m_syncRoot: any;
        private m_assembly: number;

        private get SyncRoot(): any {
            throw new Error("not yet implemented");
        }
        public get CodeBase(): string {
            throw new Error("not yet implemented");
        }
        public get FullName(): string {
            throw new Error("not yet implemented");
        }
        public get EntryPoint(): MethodInfo {
            throw new Error("not yet implemented");
        }
        public get DefinedTypes(): IEnumerable<TypeInfo> {
            throw new Error("not yet implemented");
        }
        public get IsCollectible(): boolean {
            throw new Error("not yet implemented");
        }
        public get ManifestModule(): Module {
            throw new Error("not yet implemented");
        }
        public get ReflectionOnly(): boolean {
            throw new Error("not yet implemented");
        }
        public get Location(): string {
            throw new Error("not yet implemented");
        }
        public get ImageRuntimeVersion(): string {
            throw new Error("not yet implemented");
        }
        public get GlobalAssemblyCache(): boolean {
            throw new Error("not yet implemented");
        }
        public get HostContext(): number {
            throw new Error("not yet implemented");
        }
        public get IsDynamic(): boolean {
            throw new Error("not yet implemented");
        }

        protected constructor() {
            throw new Error("not yet implemented");
        }

        private GetUnderlyingNativeHandle(): number {
            throw new Error("not yet implemented");
        }
        private static GetCodeBase(assembly: QCallAssembly, retString: StringHandleOnStack): boolean {
            throw new Error("not yet implemented");
        }
        private GetCodeBase(): string {
            throw new Error("not yet implemented");
        }
        private GetNativeHandle(): RuntimeAssembly {
            throw new Error("not yet implemented");
        }
        public GetName(copiedName: boolean): AssemblyName {
            throw new Error("not yet implemented");
        }
        private static GetFullName(assembly: QCallAssembly, retString: StringHandleOnStack) {
            throw new Error("not yet implemented");
        }
        private static GetEntryPoint(assembly: QCallAssembly, retMethod: ObjectHandleOnStack) {
            throw new Error("not yet implemented");
        }
        private static GetTypeCore(assembly: QCallAssembly, typeName: string, nestedTypeNames: ReadOnlySpan<string>, nestedTypeNamesLength: number, retType: ObjectHandleOnStack) {
            throw new Error("not yet implemented");
        }
        private static GetTypeCoreIgnoreCase(assembly: QCallAssembly, typeName: string, nestedTypeNames: ReadOnlySpan<string>, nestedTypeNamesLength: number, retType: ObjectHandleOnStack) {
            throw new Error("not yet implemented");
        }
        private GetTypeCore(typeName: string, nestedTypeNames: ReadOnlySpan<string>, throwOnError: boolean, ignoreCase: boolean): Type {
            throw new Error("not yet implemented");
        }
        public GetType(name: string, throwOnError: boolean, ignoreCase: boolean): Type {
            throw new Error("not yet implemented");
        }
        private static GetExportedTypes(assembly: QCallAssembly, retTypes: ObjectHandleOnStack) {
            throw new Error("not yet implemented");
        }
        public GetExportedTypes(): Type[] {
            throw new Error("not yet implemented");
        }
        private static GetIsCollectible(assembly: QCallAssembly): BOOL {
            throw new Error("not yet implemented");
        }
        private static GetResource(assembly: QCallAssembly, resourceName: string, out length: number): number* {
            throw new Error("not yet implemented");
        }
        public GetManifestResourceStream(type: Type, name: string): Stream {
            throw new Error("not yet implemented");
        }
        public GetManifestResourceStream(name: string): Stream {
            throw new Error("not yet implemented");
        }
        public GetObjectData(info: SerializationInfo, context: StreamingContext) {
            throw new Error("not yet implemented");
        }
        public GetCustomAttributes(inherit: boolean): any[] {
            throw new Error("not yet implemented");
        }
        public GetCustomAttributes(attributeType: Type, inherit: boolean): any[] {
            throw new Error("not yet implemented");
        }
        public IsDefined(attributeType: Type, inherit: boolean): boolean {
            throw new Error("not yet implemented");
        }
        public GetCustomAttributesData(): IList<CustomAttributeData> {
            throw new Error("not yet implemented");
        }
        private static InternalLoad(assemblyName: string, ref stackMark: StackCrawlMark, assemblyLoadContext: AssemblyLoadContext): RuntimeAssembly {
            throw new Error("not yet implemented");
        }
        private static InternalLoad(assemblyName: AssemblyName, ref stackMark: StackCrawlMark, assemblyLoadContext: AssemblyLoadContext, requestingAssembly: RuntimeAssembly, throwOnFileNotFound: boolean): RuntimeAssembly {
            throw new Error("not yet implemented");
        }
        private static InternalLoad(pAssemblyNameParts: NativeAssemblyNameParts*, requestingAssembly: ObjectHandleOnStack, stackMark: StackCrawlMarkHandle, throwOnFileNotFound: boolean, assemblyLoadContext: ObjectHandleOnStack, retAssembly: ObjectHandleOnStack) {
            throw new Error("not yet implemented");
        }
        private static GetModule(assembly: QCallAssembly, name: string, retModule: ObjectHandleOnStack) {
            throw new Error("not yet implemented");
        }
        public GetModule(name: string): Module {
            throw new Error("not yet implemented");
        }
        public GetFile(name: string): FileStream {
            throw new Error("not yet implemented");
        }
        public GetFiles(getResourceModules: boolean): FileStream[] {
            throw new Error("not yet implemented");
        }
        private static GetManifestResourceNames(assembly: RuntimeAssembly): string[] {
            throw new Error("not yet implemented");
        }
        public GetManifestResourceNames(): string[] {
            throw new Error("not yet implemented");
        }
        private static GetReferencedAssemblies(assembly: RuntimeAssembly): AssemblyName[] {
            throw new Error("not yet implemented");
        }
        public GetReferencedAssemblies(): AssemblyName[] {
            throw new Error("not yet implemented");
        }
        private static GetManifestResourceInfo(assembly: QCallAssembly, resourceName: string, assemblyRef: ObjectHandleOnStack, retFileName: StringHandleOnStack): number {
            throw new Error("not yet implemented");
        }
        public GetManifestResourceInfo(resourceName: string): ManifestResourceInfo {
            throw new Error("not yet implemented");
        }
        private static GetLocation(assembly: QCallAssembly, retString: StringHandleOnStack) {
            throw new Error("not yet implemented");
        }
        private static GetImageRuntimeVersion(assembly: QCallAssembly, retString: StringHandleOnStack) {
            throw new Error("not yet implemented");
        }
        private static GetVersion(assembly: QCallAssembly, out majVer: number, out minVer: number, out buildNum: number, out revNum: number) {
            throw new Error("not yet implemented");
        }
        private GetVersion(): Version {
            throw new Error("not yet implemented");
        }
        private static GetLocale(assembly: QCallAssembly, retString: StringHandleOnStack) {
            throw new Error("not yet implemented");
        }
        private GetLocale(): CultureInfo {
            throw new Error("not yet implemented");
        }
        private static FCallIsDynamic(assembly: RuntimeAssembly): boolean {
            throw new Error("not yet implemented");
        }
        private static GetSimpleName(assembly: QCallAssembly, retSimpleName: StringHandleOnStack) {
            throw new Error("not yet implemented");
        }
        private GetSimpleName(): string {
            throw new Error("not yet implemented");
        }
        private static GetHashAlgorithm(assembly: QCallAssembly): AssemblyHashAlgorithm {
            throw new Error("not yet implemented");
        }
        private GetHashAlgorithm(): AssemblyHashAlgorithm {
            throw new Error("not yet implemented");
        }
        private static GetFlags(assembly: QCallAssembly): AssemblyNameFlags {
            throw new Error("not yet implemented");
        }
        private GetFlags(): AssemblyNameFlags {
            throw new Error("not yet implemented");
        }
        private static GetPublicKey(assembly: QCallAssembly, retPublicKey: ObjectHandleOnStack) {
            throw new Error("not yet implemented");
        }
        private GetPublicKey(): number[] {
            throw new Error("not yet implemented");
        }
        public GetSatelliteAssembly(culture: CultureInfo): Assembly {
            throw new Error("not yet implemented");
        }
        public GetSatelliteAssembly(culture: CultureInfo, version: Version): Assembly {
            throw new Error("not yet implemented");
        }
        private InternalGetSatelliteAssembly(culture: CultureInfo, version: Version, throwOnFileNotFound: boolean): Assembly {
            throw new Error("not yet implemented");
        }
        private static GetModules(assembly: QCallAssembly, loadIfNotFound: boolean, getResourceModules: boolean, retModuleHandles: ObjectHandleOnStack) {
            throw new Error("not yet implemented");
        }
        private GetModulesInternal(loadIfNotFound: boolean, getResourceModules: boolean): RuntimeModule[] {
            throw new Error("not yet implemented");
        }
        public GetModules(getResourceModules: boolean): Module[] {
            throw new Error("not yet implemented");
        }
        public GetLoadedModules(getResourceModules: boolean): Module[] {
            throw new Error("not yet implemented");
        }
        private static GetManifestModule(assembly: RuntimeAssembly): RuntimeModule {
            throw new Error("not yet implemented");
        }
        private static GetToken(assembly: RuntimeAssembly): number {
            throw new Error("not yet implemented");
        }
        public GetForwardedTypes(): Type[] {
            throw new Error("not yet implemented");
        }
        private static AddPublicNestedTypes(type: Type, types: List<Type>, exceptions: List<Exception>) {
            throw new Error("not yet implemented");
        }
        private static GetForwardedType(assembly: QCallAssembly, mdtExternalType: MetadataToken, type: ObjectHandleOnStack) {
            throw new Error("not yet implemented");
        }
        private static __GetCodeBase__g____PInvoke_14_0(__assembly_native: QCallAssembly, __retString_native: StringHandleOnStack): number {
            throw new Error("not yet implemented");
        }
        private static __GetTypeCore__g____PInvoke_26_0(__assembly_native: QCallAssembly, __typeName_native: number*, __nestedTypeNames_native: number*, __nestedTypeNamesLength_native: number, __retType_native: ObjectHandleOnStack) {
            throw new Error("not yet implemented");
        }
        private static __GetTypeCoreIgnoreCase__g____PInvoke_27_0(__assembly_native: QCallAssembly, __typeName_native: number*, __nestedTypeNames_native: number*, __nestedTypeNamesLength_native: number, __retType_native: ObjectHandleOnStack) {
            throw new Error("not yet implemented");
        }
        private static __GetResource__g____PInvoke_37_0(__assembly_native: QCallAssembly, __resourceName_native: number*, __length_native: number*): number* {
            throw new Error("not yet implemented");
        }
        private static __InternalLoad__g____PInvoke_49_0(__pAssemblyNameParts_native: NativeAssemblyNameParts*, __requestingAssembly_native: ObjectHandleOnStack, __stackMark_native: StackCrawlMarkHandle, __throwOnFileNotFound_native: number, __assemblyLoadContext_native: ObjectHandleOnStack, __retAssembly_native: ObjectHandleOnStack) {
            throw new Error("not yet implemented");
        }
        private static __GetModule__g____PInvoke_52_0(__assembly_native: QCallAssembly, __name_native: number*, __retModule_native: ObjectHandleOnStack) {
            throw new Error("not yet implemented");
        }
        private static __GetManifestResourceInfo__g____PInvoke_60_0(__assembly_native: QCallAssembly, __resourceName_native: number*, __assemblyRef_native: ObjectHandleOnStack, __retFileName_native: StringHandleOnStack): number {
            throw new Error("not yet implemented");
        }
        private static __GetVersion__g____PInvoke_72_0(__assembly_native: QCallAssembly, __majVer_native: number*, __minVer_native: number*, __buildNum_native: number*, __revNum_native: number*) {
            throw new Error("not yet implemented");
        }
        private static __GetModules__g____PInvoke_90_0(__assembly_native: QCallAssembly, __loadIfNotFound_native: number, __getResourceModules_native: number, __retModuleHandles_native: ObjectHandleOnStack) {
            throw new Error("not yet implemented");
        }
    }
    export namespace RuntimeAssembly {
        export class ManifestResourceStream extends UnmanagedMemoryStream implements IDisposable, IAsyncDisposable {
            private _manifestAssembly: RuntimeAssembly;

            protected constructor(manifestAssembly: RuntimeAssembly, pointer: number*, length: number, capacity: number, access: FileAccess) {
                throw new Error("not yet implemented");
            }

            public Read(buffer: Span<number>): number {
                throw new Error("not yet implemented");
            }
        }
    }
    export enum ExceptionHandlingClauseOptions {
        Clause = 0x0,
        Filter = 0x1,
        Finally = 0x2,
        Fault = 0x4,
    }
    export class ExceptionHandlingClause {
        public get Flags(): ExceptionHandlingClauseOptions {
            throw new Error("not yet implemented");
        }
        public get TryOffset(): number {
            throw new Error("not yet implemented");
        }
        public get TryLength(): number {
            throw new Error("not yet implemented");
        }
        public get HandlerOffset(): number {
            throw new Error("not yet implemented");
        }
        public get HandlerLength(): number {
            throw new Error("not yet implemented");
        }
        public get FilterOffset(): number {
            throw new Error("not yet implemented");
        }
        public get CatchType(): Type {
            throw new Error("not yet implemented");
        }

        protected constructor() {
            throw new Error("not yet implemented");
        }

        public ToString(): string {
            throw new Error("not yet implemented");
        }
    }
    export class RuntimeMethodBody extends MethodBody {
        private _IL: number[];
        private _exceptionHandlingClauses: ExceptionHandlingClause[];
        private _localVariables: LocalVariableInfo[];
        private _methodBase: MethodBase;
        private _localSignatureMetadataToken: number;
        private _maxStackSize: number;
        private _initLocals: boolean;

        public get LocalSignatureMetadataToken(): number {
            throw new Error("not yet implemented");
        }
        public get LocalVariables(): IList<LocalVariableInfo> {
            throw new Error("not yet implemented");
        }
        public get MaxStackSize(): number {
            throw new Error("not yet implemented");
        }
        public get InitLocals(): boolean {
            throw new Error("not yet implemented");
        }
        public get ExceptionHandlingClauses(): IList<ExceptionHandlingClause> {
            throw new Error("not yet implemented");
        }

        private constructor() {
            throw new Error("not yet implemented");
        }

        public GetILAsByteArray(): number[] {
            throw new Error("not yet implemented");
        }
    }
    export abstract class MethodBase extends MemberInfo implements ICustomAttributeProvider {
        public get Attributes(): MethodAttributes;
        public get MethodImplementationFlags(): MethodImplAttributes {
            throw new Error("not yet implemented");
        }
        public get CallingConvention(): CallingConventions {
            throw new Error("not yet implemented");
        }
        public get IsAbstract(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsConstructor(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsFinal(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsHideBySig(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsSpecialName(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsStatic(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsVirtual(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsAssembly(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsFamily(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsFamilyAndAssembly(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsFamilyOrAssembly(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsPrivate(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsPublic(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsConstructedGenericMethod(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsGenericMethod(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsGenericMethodDefinition(): boolean {
            throw new Error("not yet implemented");
        }
        public get ContainsGenericParameters(): boolean {
            throw new Error("not yet implemented");
        }
        public get MethodHandle(): RuntimeMethodHandle;
        public get IsSecurityCritical(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsSecuritySafeCritical(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsSecurityTransparent(): boolean {
            throw new Error("not yet implemented");
        }

        protected constructor() {
            throw new Error("not yet implemented");
        }

        public static GetMethodFromHandle(handle: RuntimeMethodHandle): MethodBase {
            throw new Error("not yet implemented");
        }
        public static GetMethodFromHandle(handle: RuntimeMethodHandle, declaringType: RuntimeTypeHandle): MethodBase {
            throw new Error("not yet implemented");
        }
        public static GetCurrentMethod(): MethodBase {
            throw new Error("not yet implemented");
        }
        private GetMethodDesc(): number {
            throw new Error("not yet implemented");
        }
        private GetParametersNoCopy(): ParameterInfo[] {
            throw new Error("not yet implemented");
        }
        public GetParameters(): ParameterInfo[];
        public GetMethodImplementationFlags(): MethodImplAttributes;
        public GetMethodBody(): MethodBody {
            throw new Error("not yet implemented");
        }
        public GetGenericArguments(): Type[] {
            throw new Error("not yet implemented");
        }
        public Invoke(obj: any, parameters: any[]): any {
            throw new Error("not yet implemented");
        }
        public Invoke(obj: any, invokeAttr: BindingFlags, binder: Binder, parameters: any[], culture: CultureInfo): any;
        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        private static AppendParameters(ref sbParamList: ValueStringBuilder, parameterTypes: Type[], callingConvention: CallingConventions) {
            throw new Error("not yet implemented");
        }
        private GetParameterTypes(): Type[] {
            throw new Error("not yet implemented");
        }
        private static HandleTypeMissing(paramInfo: ParameterInfo, sigType: RuntimeType): any {
            throw new Error("not yet implemented");
        }
    }
    export namespace MethodBase {
        export enum InvokerStrategy {
            HasBeenInvoked_ObjSpanArgs = 0x1,
            StrategyDetermined_ObjSpanArgs = 0x2,
            HasBeenInvoked_Obj4Args = 0x4,
            StrategyDetermined_Obj4Args = 0x8,
            HasBeenInvoked_RefArgs = 0x10,
            StrategyDetermined_RefArgs = 0x20,
        }

        export enum InvokerArgFlags {
            IsValueType = 0x1,
            IsValueType_ByRef_Or_Pointer = 0x2,
            IsNullableOfT = 0x4,
        }

        export class ArgumentData<T> extends ValueType {
            private _arg0: T;

            public AsSpan(length: number): Span<T> {
                throw new Error("not yet implemented");
            }
            public Set(index: number, value: T) {
                throw new Error("not yet implemented");
            }
        }

        export class StackAllocatedArguments extends ValueType {
            private _args: ArgumentData<any>;

            public constructor(obj1: any, obj2: any, obj3: any, obj4: any) {
                throw new Error("not yet implemented");
            }

        }

        export class StackAllocatedArgumentsWithCopyBack extends ValueType {
            private _args: ArgumentData<any>;
            private _shouldCopyBack: ArgumentData<boolean>;

        }

        export class StackAllocatedByRefs extends ValueType {
            private _arg0: number;

        }
    }
    export abstract class MethodInfo extends MethodBase implements ICustomAttributeProvider {
        public get MemberType(): MemberTypes {
            throw new Error("not yet implemented");
        }
        public get ReturnParameter(): ParameterInfo {
            throw new Error("not yet implemented");
        }
        public get ReturnType(): Type {
            throw new Error("not yet implemented");
        }
        public get ReturnTypeCustomAttributes(): ICustomAttributeProvider;
        private get GenericParameterCount(): number {
            throw new Error("not yet implemented");
        }

        protected constructor() {
            throw new Error("not yet implemented");
        }

        public GetGenericArguments(): Type[] {
            throw new Error("not yet implemented");
        }
        public GetGenericMethodDefinition(): MethodInfo {
            throw new Error("not yet implemented");
        }
        public MakeGenericMethod(typeArguments: Type[]): MethodInfo {
            throw new Error("not yet implemented");
        }
        public GetBaseDefinition(): MethodInfo;
        public CreateDelegate(delegateType: Type): Delegate {
            throw new Error("not yet implemented");
        }
        public CreateDelegate(delegateType: Type, target: any): Delegate {
            throw new Error("not yet implemented");
        }
        public CreateDelegate(): T {
            throw new Error("not yet implemented");
        }
        public CreateDelegate(target: any): T {
            throw new Error("not yet implemented");
        }
        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
    }
    export interface IReflect {
        get UnderlyingSystemType(): Type;

        GetMethod(name: string, bindingAttr: BindingFlags, binder: Binder, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
        GetMethod(name: string, bindingAttr: BindingFlags): MethodInfo;
        GetMethods(bindingAttr: BindingFlags): MethodInfo[];
        GetField(name: string, bindingAttr: BindingFlags): FieldInfo;
        GetFields(bindingAttr: BindingFlags): FieldInfo[];
        GetProperty(name: string, bindingAttr: BindingFlags): PropertyInfo;
        GetProperty(name: string, bindingAttr: BindingFlags, binder: Binder, returnType: Type, types: Type[], modifiers: ParameterModifier[]): PropertyInfo;
        GetProperties(bindingAttr: BindingFlags): PropertyInfo[];
        GetMember(name: string, bindingAttr: BindingFlags): MemberInfo[];
        GetMembers(bindingAttr: BindingFlags): MemberInfo[];
        InvokeMember(name: string, invokeAttr: BindingFlags, binder: Binder, target: any, args: any[], modifiers: ParameterModifier[], culture: CultureInfo, namedParameters: string[]): any;
    }
    export abstract class TypeInfo extends Type implements ICustomAttributeProvider, IReflect, IReflectableType {
        public get GenericTypeParameters(): Type[] {
            throw new Error("not yet implemented");
        }
        public get DeclaredConstructors(): IEnumerable<ConstructorInfo> {
            throw new Error("not yet implemented");
        }
        public get DeclaredEvents(): IEnumerable<EventInfo> {
            throw new Error("not yet implemented");
        }
        public get DeclaredFields(): IEnumerable<FieldInfo> {
            throw new Error("not yet implemented");
        }
        public get DeclaredMembers(): IEnumerable<MemberInfo> {
            throw new Error("not yet implemented");
        }
        public get DeclaredMethods(): IEnumerable<MethodInfo> {
            throw new Error("not yet implemented");
        }
        public get DeclaredNestedTypes(): IEnumerable<TypeInfo> {
            throw new Error("not yet implemented");
        }
        public get DeclaredProperties(): IEnumerable<PropertyInfo> {
            throw new Error("not yet implemented");
        }
        public get ImplementedInterfaces(): IEnumerable<Type> {
            throw new Error("not yet implemented");
        }

        protected constructor() {
            throw new Error("not yet implemented");
        }

        private __explicit__IReflectableType_GetTypeInfo(): TypeInfo {
            throw new Error("not yet implemented");
        }
        public GetTypeInfo(): TypeInfo {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        public AsType(): Type {
            throw new Error("not yet implemented");
        }
        public GetDeclaredEvent(name: string): EventInfo {
            throw new Error("not yet implemented");
        }
        public GetDeclaredField(name: string): FieldInfo {
            throw new Error("not yet implemented");
        }
        public GetDeclaredMethod(name: string): MethodInfo {
            throw new Error("not yet implemented");
        }
        public GetDeclaredNestedType(name: string): TypeInfo {
            throw new Error("not yet implemented");
        }
        public GetDeclaredProperty(name: string): PropertyInfo {
            throw new Error("not yet implemented");
        }
        public GetDeclaredMethods(name: string): IEnumerable<MethodInfo> {
            throw new Error("not yet implemented");
        }
        public IsAssignableFrom(typeInfo: TypeInfo): boolean {
            throw new Error("not yet implemented");
        }
        private static GetRankString(rank: number): string {
            throw new Error("not yet implemented");
        }
        private static __GetDeclaredMethods__g__GetDeclaredOnlyMethods_10_0(type: Type): MethodInfo[] {
            throw new Error("not yet implemented");
        }
        private static __get_DeclaredNestedTypes__g__GetDeclaredOnlyNestedTypes_22_0(type: Type): Type[] {
            throw new Error("not yet implemented");
        }
    }
    export namespace TypeInfo {
        export class __GetDeclaredMethods__d__10 implements IEnumerable<MethodInfo>, IEnumerable, IEnumerator<MethodInfo>, IDisposable, IEnumerator {
            private ____1__state: number;
            private ____2__current: MethodInfo;
            private ____l__initialThreadId: number;
            public ____4__this: TypeInfo;
            private name: string;
            public ____3__name: string;
            private ____7__wrap1: MethodInfo[];
            private ____7__wrap2: number;

            private get __explicit__MethodInfo___Current(): MethodInfo {
                throw new Error("not yet implemented");
            }
            public get Current(): MethodInfo {
                throw new Error("Invalid call (use ExplicitAs property)");
            }
            private get __explicit__IEnumerator_Current(): any {
                throw new Error("not yet implemented");
            }
            public get Current(): any {
                throw new Error("Invalid call (use ExplicitAs property)");
            }

            public constructor(____1__state: number) {
                throw new Error("not yet implemented");
            }

            private __explicit__IDisposable_Dispose() {
                throw new Error("not yet implemented");
            }
            public Dispose() {
                throw new Error("Invalid call (use ExplicitAs property)");
            }
            private __explicit__MoveNext(): boolean {
                throw new Error("not yet implemented");
            }
            private __explicit__IEnumerator_Reset() {
                throw new Error("not yet implemented");
            }
            public Reset() {
                throw new Error("Invalid call (use ExplicitAs property)");
            }
            private __explicit__MethodInfo___GetEnumerator(): IEnumerator<MethodInfo> {
                throw new Error("not yet implemented");
            }
            public GetEnumerator(): IEnumerator<MethodInfo> {
                throw new Error("Invalid call (use ExplicitAs property)");
            }
            private __explicit__IEnumerable_GetEnumerator(): IEnumerator {
                throw new Error("not yet implemented");
            }
            public GetEnumerator(): IEnumerator {
                throw new Error("Invalid call (use ExplicitAs property)");
            }

            public readonly ExplicitAsIEnumerable__MethodInfo__: IEnumerable<MethodInfo> = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'Current') {
                        return target.__explicit__MethodInfo___Current;
                    }
                    if (prop === 'Current') {
                        return target.__explicit__IEnumerator_Current;
                    }
            
                    if (prop === 'Dispose') {
                        return target.__explicit__IDisposable_Dispose.bind(target);
                    }
                    if (prop === 'MoveNext') {
                        return target.__explicit__MoveNext.bind(target);
                    }
                    if (prop === 'Reset') {
                        return target.__explicit__IEnumerator_Reset.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__MethodInfo___GetEnumerator.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
            public readonly ExplicitAsIEnumerable: IEnumerable = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'Current') {
                        return target.__explicit__MethodInfo___Current;
                    }
                    if (prop === 'Current') {
                        return target.__explicit__IEnumerator_Current;
                    }
            
                    if (prop === 'Dispose') {
                        return target.__explicit__IDisposable_Dispose.bind(target);
                    }
                    if (prop === 'MoveNext') {
                        return target.__explicit__MoveNext.bind(target);
                    }
                    if (prop === 'Reset') {
                        return target.__explicit__IEnumerator_Reset.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__MethodInfo___GetEnumerator.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
            public readonly ExplicitAsIEnumerator__MethodInfo__: IEnumerator<MethodInfo> = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'Current') {
                        return target.__explicit__MethodInfo___Current;
                    }
                    if (prop === 'Current') {
                        return target.__explicit__IEnumerator_Current;
                    }
            
                    if (prop === 'Dispose') {
                        return target.__explicit__IDisposable_Dispose.bind(target);
                    }
                    if (prop === 'MoveNext') {
                        return target.__explicit__MoveNext.bind(target);
                    }
                    if (prop === 'Reset') {
                        return target.__explicit__IEnumerator_Reset.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__MethodInfo___GetEnumerator.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
            public readonly ExplicitAsIDisposable: IDisposable = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'Current') {
                        return target.__explicit__MethodInfo___Current;
                    }
                    if (prop === 'Current') {
                        return target.__explicit__IEnumerator_Current;
                    }
            
                    if (prop === 'Dispose') {
                        return target.__explicit__IDisposable_Dispose.bind(target);
                    }
                    if (prop === 'MoveNext') {
                        return target.__explicit__MoveNext.bind(target);
                    }
                    if (prop === 'Reset') {
                        return target.__explicit__IEnumerator_Reset.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__MethodInfo___GetEnumerator.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
            public readonly ExplicitAsIEnumerator: IEnumerator = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'Current') {
                        return target.__explicit__MethodInfo___Current;
                    }
                    if (prop === 'Current') {
                        return target.__explicit__IEnumerator_Current;
                    }
            
                    if (prop === 'Dispose') {
                        return target.__explicit__IDisposable_Dispose.bind(target);
                    }
                    if (prop === 'MoveNext') {
                        return target.__explicit__MoveNext.bind(target);
                    }
                    if (prop === 'Reset') {
                        return target.__explicit__IEnumerator_Reset.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__MethodInfo___GetEnumerator.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
        }

        export class __get_DeclaredNestedTypes__d__22 implements IEnumerable<TypeInfo>, IEnumerable, IEnumerator<TypeInfo>, IDisposable, IEnumerator {
            private ____1__state: number;
            private ____2__current: TypeInfo;
            private ____l__initialThreadId: number;
            public ____4__this: TypeInfo;
            private ____7__wrap1: Type[];
            private ____7__wrap2: number;

            private get __explicit__TypeInfo___Current(): TypeInfo {
                throw new Error("not yet implemented");
            }
            public get Current(): TypeInfo {
                throw new Error("Invalid call (use ExplicitAs property)");
            }
            private get __explicit__IEnumerator_Current(): any {
                throw new Error("not yet implemented");
            }
            public get Current(): any {
                throw new Error("Invalid call (use ExplicitAs property)");
            }

            public constructor(____1__state: number) {
                throw new Error("not yet implemented");
            }

            private __explicit__IDisposable_Dispose() {
                throw new Error("not yet implemented");
            }
            public Dispose() {
                throw new Error("Invalid call (use ExplicitAs property)");
            }
            private __explicit__MoveNext(): boolean {
                throw new Error("not yet implemented");
            }
            private __explicit__IEnumerator_Reset() {
                throw new Error("not yet implemented");
            }
            public Reset() {
                throw new Error("Invalid call (use ExplicitAs property)");
            }
            private __explicit__TypeInfo___GetEnumerator(): IEnumerator<TypeInfo> {
                throw new Error("not yet implemented");
            }
            public GetEnumerator(): IEnumerator<TypeInfo> {
                throw new Error("Invalid call (use ExplicitAs property)");
            }
            private __explicit__IEnumerable_GetEnumerator(): IEnumerator {
                throw new Error("not yet implemented");
            }
            public GetEnumerator(): IEnumerator {
                throw new Error("Invalid call (use ExplicitAs property)");
            }

            public readonly ExplicitAsIEnumerable__TypeInfo__: IEnumerable<TypeInfo> = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'Current') {
                        return target.__explicit__TypeInfo___Current;
                    }
                    if (prop === 'Current') {
                        return target.__explicit__IEnumerator_Current;
                    }
            
                    if (prop === 'Dispose') {
                        return target.__explicit__IDisposable_Dispose.bind(target);
                    }
                    if (prop === 'MoveNext') {
                        return target.__explicit__MoveNext.bind(target);
                    }
                    if (prop === 'Reset') {
                        return target.__explicit__IEnumerator_Reset.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__TypeInfo___GetEnumerator.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
            public readonly ExplicitAsIEnumerable: IEnumerable = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'Current') {
                        return target.__explicit__TypeInfo___Current;
                    }
                    if (prop === 'Current') {
                        return target.__explicit__IEnumerator_Current;
                    }
            
                    if (prop === 'Dispose') {
                        return target.__explicit__IDisposable_Dispose.bind(target);
                    }
                    if (prop === 'MoveNext') {
                        return target.__explicit__MoveNext.bind(target);
                    }
                    if (prop === 'Reset') {
                        return target.__explicit__IEnumerator_Reset.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__TypeInfo___GetEnumerator.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
            public readonly ExplicitAsIEnumerator__TypeInfo__: IEnumerator<TypeInfo> = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'Current') {
                        return target.__explicit__TypeInfo___Current;
                    }
                    if (prop === 'Current') {
                        return target.__explicit__IEnumerator_Current;
                    }
            
                    if (prop === 'Dispose') {
                        return target.__explicit__IDisposable_Dispose.bind(target);
                    }
                    if (prop === 'MoveNext') {
                        return target.__explicit__MoveNext.bind(target);
                    }
                    if (prop === 'Reset') {
                        return target.__explicit__IEnumerator_Reset.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__TypeInfo___GetEnumerator.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
            public readonly ExplicitAsIDisposable: IDisposable = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'Current') {
                        return target.__explicit__TypeInfo___Current;
                    }
                    if (prop === 'Current') {
                        return target.__explicit__IEnumerator_Current;
                    }
            
                    if (prop === 'Dispose') {
                        return target.__explicit__IDisposable_Dispose.bind(target);
                    }
                    if (prop === 'MoveNext') {
                        return target.__explicit__MoveNext.bind(target);
                    }
                    if (prop === 'Reset') {
                        return target.__explicit__IEnumerator_Reset.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__TypeInfo___GetEnumerator.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
            public readonly ExplicitAsIEnumerator: IEnumerator = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'Current') {
                        return target.__explicit__TypeInfo___Current;
                    }
                    if (prop === 'Current') {
                        return target.__explicit__IEnumerator_Current;
                    }
            
                    if (prop === 'Dispose') {
                        return target.__explicit__IDisposable_Dispose.bind(target);
                    }
                    if (prop === 'MoveNext') {
                        return target.__explicit__MoveNext.bind(target);
                    }
                    if (prop === 'Reset') {
                        return target.__explicit__IEnumerator_Reset.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__TypeInfo___GetEnumerator.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
        }
    }
    export class InterfaceMapping extends ValueType {
        public TargetType: Type;
        public InterfaceType: Type;
        public TargetMethods: MethodInfo[];
        public InterfaceMethods: MethodInfo[];

    }
    export enum MemberTypes {
        Constructor = 0x1,
        Event = 0x2,
        Field = 0x4,
        Method = 0x8,
        Property = 0x10,
        TypeInfo = 0x20,
        Custom = 0x40,
        NestedType = 0x80,
        All = 0xbf,
    }
    export abstract class MemberInfo implements ICustomAttributeProvider {
        public get MemberType(): MemberTypes;
        public get Name(): string;
        public get DeclaringType(): Type;
        public get ReflectedType(): Type;
        public get Module(): Module {
            throw new Error("not yet implemented");
        }
        public get CustomAttributes(): IEnumerable<CustomAttributeData> {
            throw new Error("not yet implemented");
        }
        public get IsCollectible(): boolean {
            throw new Error("not yet implemented");
        }
        public get MetadataToken(): number {
            throw new Error("not yet implemented");
        }

        protected constructor() {
            throw new Error("not yet implemented");
        }

        private CacheEquals(o: any): boolean {
            throw new Error("not yet implemented");
        }
        private HasSameMetadataDefinitionAsCore(other: MemberInfo): boolean {
            throw new Error("not yet implemented");
        }
        public HasSameMetadataDefinitionAs(other: MemberInfo): boolean {
            throw new Error("not yet implemented");
        }
        public IsDefined(attributeType: Type, inherit: boolean): boolean;
        public GetCustomAttributes(inherit: boolean): any[];
        public GetCustomAttributes(attributeType: Type, inherit: boolean): any[];
        public GetCustomAttributesData(): IList<CustomAttributeData> {
            throw new Error("not yet implemented");
        }
        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
    }
    export class MemberFilter extends MulticastDelegate implements ICloneable, ISerializable {
        public constructor(object: any, method: number) {
            throw new Error("not yet implemented");
        }

        public Invoke(m: MemberInfo, filterCriteria: any): boolean {
            throw new Error("not yet implemented");
        }
        public BeginInvoke(m: MemberInfo, filterCriteria: any, callback: AsyncCallback, object: any): IAsyncResult {
            throw new Error("not yet implemented");
        }
        public EndInvoke(result: IAsyncResult): boolean {
            throw new Error("not yet implemented");
        }
    }
}
export namespace System.Reflection.Emit {
    export class CustomAttributeBuilder {
        private m_con: ConstructorInfo;
        private m_constructorArgs: any[];
        private m_blob: number[];

        private get Ctor(): ConstructorInfo {
            throw new Error("not yet implemented");
        }
        private get Data(): number[] {
            throw new Error("not yet implemented");
        }

        public constructor(con: ConstructorInfo, constructorArgs: any[]) {
            throw new Error("not yet implemented");
        }
        public constructor(con: ConstructorInfo, constructorArgs: any[], namedProperties: PropertyInfo[], propertyValues: any[]) {
            throw new Error("not yet implemented");
        }
        public constructor(con: ConstructorInfo, constructorArgs: any[], namedFields: FieldInfo[], fieldValues: any[]) {
            throw new Error("not yet implemented");
        }
        public constructor(con: ConstructorInfo, constructorArgs: any[], namedProperties: PropertyInfo[], propertyValues: any[], namedFields: FieldInfo[], fieldValues: any[]) {
            throw new Error("not yet implemented");
        }

        private static ValidateType(t: Type): boolean {
            throw new Error("not yet implemented");
        }
        private static VerifyTypeAndPassedObjectType(type: Type, passedType: Type, paramName: string) {
            throw new Error("not yet implemented");
        }
        private static EmitType(writer: BinaryWriter, type: Type) {
            throw new Error("not yet implemented");
        }
        private static EmitString(writer: BinaryWriter, str: string) {
            throw new Error("not yet implemented");
        }
        private static EmitValue(writer: BinaryWriter, type: Type, value: any) {
            throw new Error("not yet implemented");
        }
        private CreateCustomAttribute(mod: RuntimeModuleBuilder, tkOwner: number) {
            throw new Error("not yet implemented");
        }
    }
    export abstract class FieldBuilder extends FieldInfo implements ICustomAttributeProvider {
        protected constructor() {
            throw new Error("not yet implemented");
        }

        public SetConstant(defaultValue: any) {
            throw new Error("not yet implemented");
        }
        private SetConstantCore(defaultValue: any): void;
        public SetCustomAttribute(con: ConstructorInfo, binaryAttribute: number[]) {
            throw new Error("not yet implemented");
        }
        private SetCustomAttributeCore(con: ConstructorInfo, binaryAttribute: ReadOnlySpan<number>): void;
        public SetCustomAttribute(customBuilder: CustomAttributeBuilder) {
            throw new Error("not yet implemented");
        }
        public SetOffset(iOffset: number) {
            throw new Error("not yet implemented");
        }
        private SetOffsetCore(iOffset: number): void;
    }
    export abstract class EnumBuilder extends TypeInfo implements ICustomAttributeProvider, IReflect, IReflectableType {
        public get UnderlyingField(): FieldBuilder {
            throw new Error("not yet implemented");
        }
        private get UnderlyingFieldCore(): FieldBuilder;

        protected constructor() {
            throw new Error("not yet implemented");
        }

        public CreateType(): Type {
            throw new Error("not yet implemented");
        }
        public CreateTypeInfo(): TypeInfo {
            throw new Error("not yet implemented");
        }
        private CreateTypeInfoCore(): TypeInfo;
        public DefineLiteral(literalName: string, literalValue: any): FieldBuilder {
            throw new Error("not yet implemented");
        }
        private DefineLiteralCore(literalName: string, literalValue: any): FieldBuilder;
        public SetCustomAttribute(con: ConstructorInfo, binaryAttribute: number[]) {
            throw new Error("not yet implemented");
        }
        private SetCustomAttributeCore(con: ConstructorInfo, binaryAttribute: ReadOnlySpan<number>): void;
        public SetCustomAttribute(customBuilder: CustomAttributeBuilder) {
            throw new Error("not yet implemented");
        }
        public MakePointerType(): Type {
            throw new Error("not yet implemented");
        }
        public MakeByRefType(): Type {
            throw new Error("not yet implemented");
        }
        public MakeArrayType(): Type {
            throw new Error("not yet implemented");
        }
        public MakeArrayType(rank: number): Type {
            throw new Error("not yet implemented");
        }
    }
    export abstract class GenericTypeParameterBuilder extends TypeInfo implements ICustomAttributeProvider, IReflect, IReflectableType {
        protected constructor() {
            throw new Error("not yet implemented");
        }

        public SetCustomAttribute(con: ConstructorInfo, binaryAttribute: number[]) {
            throw new Error("not yet implemented");
        }
        private SetCustomAttributeCore(con: ConstructorInfo, binaryAttribute: ReadOnlySpan<number>): void;
        public SetCustomAttribute(customBuilder: CustomAttributeBuilder) {
            throw new Error("not yet implemented");
        }
        public SetBaseTypeConstraint(baseTypeConstraint: Type) {
            throw new Error("not yet implemented");
        }
        private SetBaseTypeConstraintCore(baseTypeConstraint: Type): void;
        public SetInterfaceConstraints(interfaceConstraints: Type[]) {
            throw new Error("not yet implemented");
        }
        private SetInterfaceConstraintsCore(interfaceConstraints: Type[]): void;
        public SetGenericParameterAttributes(genericParameterAttributes: GenericParameterAttributes) {
            throw new Error("not yet implemented");
        }
        private SetGenericParameterAttributesCore(genericParameterAttributes: GenericParameterAttributes): void;
    }
    export abstract class ParameterBuilder {
        public get Attributes(): number {
            throw new Error("not yet implemented");
        }
        public get IsIn(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsOptional(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsOut(): boolean {
            throw new Error("not yet implemented");
        }
        public get Name(): string {
            throw new Error("not yet implemented");
        }
        public get Position(): number {
            throw new Error("not yet implemented");
        }

        protected constructor() {
            throw new Error("not yet implemented");
        }

        public SetConstant(defaultValue: any) {
            throw new Error("not yet implemented");
        }
        public SetCustomAttribute(con: ConstructorInfo, binaryAttribute: number[]) {
            throw new Error("not yet implemented");
        }
        private SetCustomAttributeCore(con: ConstructorInfo, binaryAttribute: ReadOnlySpan<number>): void;
        public SetCustomAttribute(customBuilder: CustomAttributeBuilder) {
            throw new Error("not yet implemented");
        }
    }
    export enum OpCodeValues {
        Nop = 0,
        Break = 1,
        Ldarg_0 = 2,
        Ldarg_1 = 3,
        Ldarg_2 = 4,
        Ldarg_3 = 5,
        Ldloc_0 = 6,
        Ldloc_1 = 7,
        Ldloc_2 = 8,
        Ldloc_3 = 9,
        Stloc_0 = 10,
        Stloc_1 = 11,
        Stloc_2 = 12,
        Stloc_3 = 13,
        Ldarg_S = 14,
        Ldarga_S = 15,
        Starg_S = 16,
        Ldloc_S = 17,
        Ldloca_S = 18,
        Stloc_S = 19,
        Ldnull = 20,
        Ldc_I4_M1 = 21,
        Ldc_I4_0 = 22,
        Ldc_I4_1 = 23,
        Ldc_I4_2 = 24,
        Ldc_I4_3 = 25,
        Ldc_I4_4 = 26,
        Ldc_I4_5 = 27,
        Ldc_I4_6 = 28,
        Ldc_I4_7 = 29,
        Ldc_I4_8 = 30,
        Ldc_I4_S = 31,
        Ldc_I4 = 32,
        Ldc_I8 = 33,
        Ldc_R4 = 34,
        Ldc_R8 = 35,
        Dup = 37,
        Pop = 38,
        Jmp = 39,
        Call = 40,
        Calli = 41,
        Ret = 42,
        Br_S = 43,
        Brfalse_S = 44,
        Brtrue_S = 45,
        Beq_S = 46,
        Bge_S = 47,
        Bgt_S = 48,
        Ble_S = 49,
        Blt_S = 50,
        Bne_Un_S = 51,
        Bge_Un_S = 52,
        Bgt_Un_S = 53,
        Ble_Un_S = 54,
        Blt_Un_S = 55,
        Br = 56,
        Brfalse = 57,
        Brtrue = 58,
        Beq = 59,
        Bge = 60,
        Bgt = 61,
        Ble = 62,
        Blt = 63,
        Bne_Un = 64,
        Bge_Un = 65,
        Bgt_Un = 66,
        Ble_Un = 67,
        Blt_Un = 68,
        Switch = 69,
        Ldind_I1 = 70,
        Ldind_U1 = 71,
        Ldind_I2 = 72,
        Ldind_U2 = 73,
        Ldind_I4 = 74,
        Ldind_U4 = 75,
        Ldind_I8 = 76,
        Ldind_I = 77,
        Ldind_R4 = 78,
        Ldind_R8 = 79,
        Ldind_Ref = 80,
        Stind_Ref = 81,
        Stind_I1 = 82,
        Stind_I2 = 83,
        Stind_I4 = 84,
        Stind_I8 = 85,
        Stind_R4 = 86,
        Stind_R8 = 87,
        Add = 88,
        Sub = 89,
        Mul = 90,
        Div = 91,
        Div_Un = 92,
        Rem = 93,
        Rem_Un = 94,
        And = 95,
        Or = 96,
        Xor = 97,
        Shl = 98,
        Shr = 99,
        Shr_Un = 100,
        Neg = 101,
        Not = 102,
        Conv_I1 = 103,
        Conv_I2 = 104,
        Conv_I4 = 105,
        Conv_I8 = 106,
        Conv_R4 = 107,
        Conv_R8 = 108,
        Conv_U4 = 109,
        Conv_U8 = 110,
        Callvirt = 111,
        Cpobj = 112,
        Ldobj = 113,
        Ldstr = 114,
        Newobj = 115,
        Castclass = 116,
        Isinst = 117,
        Conv_R_Un = 118,
        Unbox = 121,
        Throw = 122,
        Ldfld = 123,
        Ldflda = 124,
        Stfld = 125,
        Ldsfld = 126,
        Ldsflda = 127,
        Stsfld = 128,
        Stobj = 129,
        Conv_Ovf_I1_Un = 130,
        Conv_Ovf_I2_Un = 131,
        Conv_Ovf_I4_Un = 132,
        Conv_Ovf_I8_Un = 133,
        Conv_Ovf_U1_Un = 134,
        Conv_Ovf_U2_Un = 135,
        Conv_Ovf_U4_Un = 136,
        Conv_Ovf_U8_Un = 137,
        Conv_Ovf_I_Un = 138,
        Conv_Ovf_U_Un = 139,
        Box = 140,
        Newarr = 141,
        Ldlen = 142,
        Ldelema = 143,
        Ldelem_I1 = 144,
        Ldelem_U1 = 145,
        Ldelem_I2 = 146,
        Ldelem_U2 = 147,
        Ldelem_I4 = 148,
        Ldelem_U4 = 149,
        Ldelem_I8 = 150,
        Ldelem_I = 151,
        Ldelem_R4 = 152,
        Ldelem_R8 = 153,
        Ldelem_Ref = 154,
        Stelem_I = 155,
        Stelem_I1 = 156,
        Stelem_I2 = 157,
        Stelem_I4 = 158,
        Stelem_I8 = 159,
        Stelem_R4 = 160,
        Stelem_R8 = 161,
        Stelem_Ref = 162,
        Ldelem = 163,
        Stelem = 164,
        Unbox_Any = 165,
        Conv_Ovf_I1 = 179,
        Conv_Ovf_U1 = 180,
        Conv_Ovf_I2 = 181,
        Conv_Ovf_U2 = 182,
        Conv_Ovf_I4 = 183,
        Conv_Ovf_U4 = 184,
        Conv_Ovf_I8 = 185,
        Conv_Ovf_U8 = 186,
        Refanyval = 194,
        Ckfinite = 195,
        Mkrefany = 198,
        Ldtoken = 208,
        Conv_U2 = 209,
        Conv_U1 = 210,
        Conv_I = 211,
        Conv_Ovf_I = 212,
        Conv_Ovf_U = 213,
        Add_Ovf = 214,
        Add_Ovf_Un = 215,
        Mul_Ovf = 216,
        Mul_Ovf_Un = 217,
        Sub_Ovf = 218,
        Sub_Ovf_Un = 219,
        Endfinally = 220,
        Leave = 221,
        Leave_S = 222,
        Stind_I = 223,
        Conv_U = 224,
        Prefix7 = 248,
        Prefix6 = 249,
        Prefix5 = 250,
        Prefix4 = 251,
        Prefix3 = 252,
        Prefix2 = 253,
        Prefix1 = 254,
        Prefixref = 255,
        Arglist = 65024,
        Ceq = 65025,
        Cgt = 65026,
        Cgt_Un = 65027,
        Clt = 65028,
        Clt_Un = 65029,
        Ldftn = 65030,
        Ldvirtftn = 65031,
        Ldarg = 65033,
        Ldarga = 65034,
        Starg = 65035,
        Ldloc = 65036,
        Ldloca = 65037,
        Stloc = 65038,
        Localloc = 65039,
        Endfilter = 65041,
        Unaligned_ = 65042,
        Volatile_ = 65043,
        Tail_ = 65044,
        Initobj = 65045,
        Constrained_ = 65046,
        Cpblk = 65047,
        Initblk = 65048,
        Rethrow = 65050,
        Sizeof = 65052,
        Refanytype = 65053,
        Readonly_ = 65054,
    }
    export enum OperandType {
        InlineBrTarget = 0,
        InlineField = 1,
        InlineI = 2,
        InlineI8 = 3,
        InlineMethod = 4,
        InlineNone = 5,
        InlinePhi = 6,
        InlineR = 7,
        InlineSig = 9,
        InlineString = 10,
        InlineSwitch = 11,
        InlineTok = 12,
        InlineType = 13,
        InlineVar = 14,
        ShortInlineBrTarget = 15,
        ShortInlineI = 16,
        ShortInlineR = 17,
        ShortInlineVar = 18,
    }
    export enum FlowControl {
        Branch = 0,
        Break = 1,
        Call = 2,
        Cond_Branch = 3,
        Meta = 4,
        Next = 5,
        Phi = 6,
        Return = 7,
        Throw = 8,
    }
    export enum OpCodeType {
        Annotation = 0,
        Macro = 1,
        Nternal = 2,
        Objmodel = 3,
        Prefix = 4,
        Primitive = 5,
    }
    export enum StackBehaviour {
        Pop0 = 0,
        Pop1 = 1,
        Pop1_pop1 = 2,
        Popi = 3,
        Popi_pop1 = 4,
        Popi_popi = 5,
        Popi_popi8 = 6,
        Popi_popi_popi = 7,
        Popi_popr4 = 8,
        Popi_popr8 = 9,
        Popref = 10,
        Popref_pop1 = 11,
        Popref_popi = 12,
        Popref_popi_popi = 13,
        Popref_popi_popi8 = 14,
        Popref_popi_popr4 = 15,
        Popref_popi_popr8 = 16,
        Popref_popi_popref = 17,
        Push0 = 18,
        Push1 = 19,
        Push1_push1 = 20,
        Pushi = 21,
        Pushi8 = 22,
        Pushr4 = 23,
        Pushr8 = 24,
        Pushref = 25,
        Varpop = 26,
        Varpush = 27,
        Popref_popi_pop1 = 28,
    }
    export class OpCode extends ValueType implements IEquatable<OpCode> {
        private static g_nameCache: string[];

        private m_value: OpCodeValues;
        private m_flags: number;

        public get OperandType(): OperandType {
            throw new Error("not yet implemented");
        }
        public get FlowControl(): FlowControl {
            throw new Error("not yet implemented");
        }
        public get OpCodeType(): OpCodeType {
            throw new Error("not yet implemented");
        }
        public get StackBehaviourPop(): StackBehaviour {
            throw new Error("not yet implemented");
        }
        public get StackBehaviourPush(): StackBehaviour {
            throw new Error("not yet implemented");
        }
        public get Size(): number {
            throw new Error("not yet implemented");
        }
        public get Value(): number {
            throw new Error("not yet implemented");
        }
        public get Name(): string {
            throw new Error("not yet implemented");
        }

        protected constructor(value: OpCodeValues, flags: number) {
            throw new Error("not yet implemented");
        }

        private EndsUncondJmpBlk(): boolean {
            throw new Error("not yet implemented");
        }
        private StackChange(): number {
            throw new Error("not yet implemented");
        }
        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public Equals(obj: OpCode): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
    }
    export class __LabelInfo extends ValueType {
        private m_pos: number;
        private m_depth: number;

    }
    export class Label extends ValueType implements IEquatable<Label> {
        private m_label: number;

        protected constructor(label: number) {
            throw new Error("not yet implemented");
        }

        private GetLabelValue(): number {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public Equals(obj: Label): boolean {
            throw new Error("not yet implemented");
        }
    }
    export class __FixupData extends ValueType {
        private m_fixupLabel: Label;
        private m_fixupPos: number;
        private m_fixupInstSize: number;

    }
    export class __ExceptionInfo {
        private m_startAddr: number;
        private m_filterAddr: number[];
        private m_catchAddr: number[];
        private m_catchEndAddr: number[];
        private m_type: number[];
        private m_catchClass: Type[];
        private m_endLabel: Label;
        private m_finallyEndLabel: Label;
        private m_endAddr: number;
        private m_endFinally: number;
        private m_currentCatch: number;
        private m_currentState: number;

        protected constructor(startAddr: number, endLabel: Label) {
            throw new Error("not yet implemented");
        }

        private MarkHelper(catchorfilterAddr: number, catchEndAddr: number, catchClass: Type, type: number) {
            throw new Error("not yet implemented");
        }
        private MarkFilterAddr(filterAddr: number) {
            throw new Error("not yet implemented");
        }
        private MarkFaultAddr(faultAddr: number) {
            throw new Error("not yet implemented");
        }
        private MarkCatchAddr(catchAddr: number, catchException: Type) {
            throw new Error("not yet implemented");
        }
        private MarkFinallyAddr(finallyAddr: number, endCatchAddr: number) {
            throw new Error("not yet implemented");
        }
        private Done(endAddr: number) {
            throw new Error("not yet implemented");
        }
        private GetStartAddress(): number {
            throw new Error("not yet implemented");
        }
        private GetEndAddress(): number {
            throw new Error("not yet implemented");
        }
        private GetFinallyEndAddress(): number {
            throw new Error("not yet implemented");
        }
        private GetEndLabel(): Label {
            throw new Error("not yet implemented");
        }
        private GetFilterAddresses(): number[] {
            throw new Error("not yet implemented");
        }
        private GetCatchAddresses(): number[] {
            throw new Error("not yet implemented");
        }
        private GetCatchEndAddresses(): number[] {
            throw new Error("not yet implemented");
        }
        private GetCatchClass(): Type[] {
            throw new Error("not yet implemented");
        }
        private GetNumberOfCatches(): number {
            throw new Error("not yet implemented");
        }
        private GetExceptionTypes(): number[] {
            throw new Error("not yet implemented");
        }
        private SetFinallyEndLabel(lbl: Label) {
            throw new Error("not yet implemented");
        }
        private IsInner(exc: __ExceptionInfo): boolean {
            throw new Error("not yet implemented");
        }
        private GetCurrentState(): number {
            throw new Error("not yet implemented");
        }
    }
    export enum ScopeAction {
        Close = 1,
        Open = -1,
    }
    export class LocalSymInfo {
        private m_iLocalSymCount: number;
        private m_namespace: string[];
        private m_iNameSpaceCount: number;

        protected constructor() {
            throw new Error("not yet implemented");
        }

        private EnsureCapacityNamespace() {
            throw new Error("not yet implemented");
        }
        private AddUsingNamespace(strNamespace: string) {
            throw new Error("not yet implemented");
        }
    }
    export class ScopeTree {
        private m_iOffsets: number[];
        private m_ScopeActions: ScopeAction[];
        private m_iCount: number;
        private m_iOpenScopeCount: number;
        private m_localSymInfos: LocalSymInfo[];

        protected constructor() {
            throw new Error("not yet implemented");
        }

        private GetCurrentActiveScopeIndex(): number {
            throw new Error("not yet implemented");
        }
        private AddUsingNamespaceToCurrentScope(strNamespace: string) {
            throw new Error("not yet implemented");
        }
        private AddScopeInfo(sa: ScopeAction, iOffset: number) {
            throw new Error("not yet implemented");
        }
        private EnsureCapacity() {
            throw new Error("not yet implemented");
        }
    }
    export class LocalBuilder extends LocalVariableInfo {
        private m_localIndex: number;
        private m_localType: Type;
        private m_methodBuilder: MethodInfo;
        private m_isPinned: boolean;

        public get IsPinned(): boolean {
            throw new Error("not yet implemented");
        }
        public get LocalType(): Type {
            throw new Error("not yet implemented");
        }
        public get LocalIndex(): number {
            throw new Error("not yet implemented");
        }

        protected constructor(localIndex: number, localType: Type, methodBuilder: MethodInfo, isPinned: boolean) {
            throw new Error("not yet implemented");
        }

        private GetLocalIndex(): number {
            throw new Error("not yet implemented");
        }
        private GetMethodBuilder(): MethodInfo {
            throw new Error("not yet implemented");
        }
    }
    export class RuntimeILGenerator extends ILGenerator {
        private m_length: number;
        private m_ILStream: number[];
        private m_labelList: __LabelInfo[];
        private m_labelCount: number;
        private m_fixupData: __FixupData[];
        private m_fixupCount: number;
        private m_RelocFixupList: number[];
        private m_RelocFixupCount: number;
        private m_exceptionCount: number;
        private m_currExcStackCount: number;
        private m_exceptions: __ExceptionInfo[];
        private m_currExcStack: __ExceptionInfo[];
        private m_ScopeTree: ScopeTree;
        private m_methodBuilder: MethodInfo;
        private m_localCount: number;
        private m_localSignature: SignatureHelper;
        private m_curDepth: number;
        private m_targetDepth: number;
        private m_maxDepth: number;
        private m_depthAdjustment: number;

        private get CurrExcStackCount(): number {
            throw new Error("not yet implemented");
        }
        private get CurrExcStack(): __ExceptionInfo[] {
            throw new Error("not yet implemented");
        }
        public get ILOffset(): number {
            throw new Error("not yet implemented");
        }

        protected constructor(methodBuilder: MethodInfo, size: number) {
            throw new Error("not yet implemented");
        }

        private static EnlargeArray(incoming: T[]): T[] {
            throw new Error("not yet implemented");
        }
        private static EnlargeArray(incoming: T[], requiredSize: number): T[] {
            throw new Error("not yet implemented");
        }
        private RecordTokenFixup() {
            throw new Error("not yet implemented");
        }
        private InternalEmit(opcode: OpCode) {
            throw new Error("not yet implemented");
        }
        private UpdateStackSize(opcode: OpCode, stackchange: number) {
            throw new Error("not yet implemented");
        }
        private GetMethodToken(method: MethodBase, optionalParameterTypes: Type[], useMethodDef: boolean): number {
            throw new Error("not yet implemented");
        }
        private GetMemberRefSignature(call: CallingConventions, returnType: Type, parameterTypes: Type[], optionalParameterTypes: Type[]): SignatureHelper {
            throw new Error("not yet implemented");
        }
        private BakeByteArray(): number[] {
            throw new Error("not yet implemented");
        }
        private GetExceptions(): __ExceptionInfo[] {
            throw new Error("not yet implemented");
        }
        private EnsureCapacity(size: number) {
            throw new Error("not yet implemented");
        }
        private IncreaseCapacity(size: number) {
            throw new Error("not yet implemented");
        }
        private PutInteger4(value: number) {
            throw new Error("not yet implemented");
        }
        private GetLabelPos(lbl: Label): number {
            throw new Error("not yet implemented");
        }
        private AddFixup(lbl: Label, pos: number, instSize: number) {
            throw new Error("not yet implemented");
        }
        private GetMaxStackSize(): number {
            throw new Error("not yet implemented");
        }
        private static SortExceptions(exceptions: __ExceptionInfo[]) {
            throw new Error("not yet implemented");
        }
        private GetTokenFixups(): number[] {
            throw new Error("not yet implemented");
        }
        public Emit(opcode: OpCode) {
            throw new Error("not yet implemented");
        }
        public Emit(opcode: OpCode, arg: number) {
            throw new Error("not yet implemented");
        }
        public Emit(opcode: OpCode, arg: number) {
            throw new Error("not yet implemented");
        }
        public Emit(opcode: OpCode, arg: number) {
            throw new Error("not yet implemented");
        }
        public Emit(opcode: OpCode, meth: MethodInfo) {
            throw new Error("not yet implemented");
        }
        public EmitCalli(opcode: OpCode, callingConvention: CallingConventions, returnType: Type, parameterTypes: Type[], optionalParameterTypes: Type[]) {
            throw new Error("not yet implemented");
        }
        public EmitCalli(opcode: OpCode, unmanagedCallConv: CallingConvention, returnType: Type, parameterTypes: Type[]) {
            throw new Error("not yet implemented");
        }
        public EmitCall(opcode: OpCode, methodInfo: MethodInfo, optionalParameterTypes: Type[]) {
            throw new Error("not yet implemented");
        }
        public Emit(opcode: OpCode, signature: SignatureHelper) {
            throw new Error("not yet implemented");
        }
        public Emit(opcode: OpCode, con: ConstructorInfo) {
            throw new Error("not yet implemented");
        }
        public Emit(opcode: OpCode, cls: Type) {
            throw new Error("not yet implemented");
        }
        public Emit(opcode: OpCode, arg: number) {
            throw new Error("not yet implemented");
        }
        public Emit(opcode: OpCode, arg: number) {
            throw new Error("not yet implemented");
        }
        public Emit(opcode: OpCode, arg: number) {
            throw new Error("not yet implemented");
        }
        public Emit(opcode: OpCode, label: Label) {
            throw new Error("not yet implemented");
        }
        public Emit(opcode: OpCode, labels: Label[]) {
            throw new Error("not yet implemented");
        }
        public Emit(opcode: OpCode, field: FieldInfo) {
            throw new Error("not yet implemented");
        }
        public Emit(opcode: OpCode, str: string) {
            throw new Error("not yet implemented");
        }
        public Emit(opcode: OpCode, local: LocalBuilder) {
            throw new Error("not yet implemented");
        }
        public BeginExceptionBlock(): Label {
            throw new Error("not yet implemented");
        }
        public EndExceptionBlock() {
            throw new Error("not yet implemented");
        }
        public BeginExceptFilterBlock() {
            throw new Error("not yet implemented");
        }
        public BeginCatchBlock(exceptionType: Type) {
            throw new Error("not yet implemented");
        }
        public BeginFaultBlock() {
            throw new Error("not yet implemented");
        }
        public BeginFinallyBlock() {
            throw new Error("not yet implemented");
        }
        public DefineLabel(): Label {
            throw new Error("not yet implemented");
        }
        private DefineLabel(depth: number): Label {
            throw new Error("not yet implemented");
        }
        public MarkLabel(loc: Label) {
            throw new Error("not yet implemented");
        }
        public DeclareLocal(localType: Type, pinned: boolean): LocalBuilder {
            throw new Error("not yet implemented");
        }
        public UsingNamespace(usingNamespace: string) {
            throw new Error("not yet implemented");
        }
        public BeginScope() {
            throw new Error("not yet implemented");
        }
        public EndScope() {
            throw new Error("not yet implemented");
        }
    }
    export class DynamicILGenerator extends RuntimeILGenerator {
        private m_scope: DynamicScope;
        private m_methodSigToken: number;

        protected constructor(method: DynamicMethod, methodSignature: number[], size: number) {
            throw new Error("not yet implemented");
        }

        private GetCallableMethod(module: RuntimeModule, dm: DynamicMethod) {
            throw new Error("not yet implemented");
        }
        public DeclareLocal(localType: Type, pinned: boolean): LocalBuilder {
            throw new Error("not yet implemented");
        }
        public Emit(opcode: OpCode, meth: MethodInfo) {
            throw new Error("not yet implemented");
        }
        public Emit(opcode: OpCode, con: ConstructorInfo) {
            throw new Error("not yet implemented");
        }
        public Emit(opcode: OpCode, type: Type) {
            throw new Error("not yet implemented");
        }
        public Emit(opcode: OpCode, field: FieldInfo) {
            throw new Error("not yet implemented");
        }
        public Emit(opcode: OpCode, str: string) {
            throw new Error("not yet implemented");
        }
        public EmitCalli(opcode: OpCode, callingConvention: CallingConventions, returnType: Type, parameterTypes: Type[], optionalParameterTypes: Type[]) {
            throw new Error("not yet implemented");
        }
        public EmitCalli(opcode: OpCode, unmanagedCallConv: CallingConvention, returnType: Type, parameterTypes: Type[]) {
            throw new Error("not yet implemented");
        }
        public EmitCall(opcode: OpCode, methodInfo: MethodInfo, optionalParameterTypes: Type[]) {
            throw new Error("not yet implemented");
        }
        public Emit(opcode: OpCode, signature: SignatureHelper) {
            throw new Error("not yet implemented");
        }
        public BeginExceptFilterBlock() {
            throw new Error("not yet implemented");
        }
        public BeginCatchBlock(exceptionType: Type) {
            throw new Error("not yet implemented");
        }
        public UsingNamespace(ns: string) {
            throw new Error("not yet implemented");
        }
        public BeginScope() {
            throw new Error("not yet implemented");
        }
        public EndScope() {
            throw new Error("not yet implemented");
        }
        private GetMemberRefToken(methodInfo: MethodInfo, optionalParameterTypes: Type[]): number {
            throw new Error("not yet implemented");
        }
        private GetMethodSigHelper(unmanagedCallConv: CallingConvention, returnType: Type, parameterTypes: Type[]): SignatureHelper {
            throw new Error("not yet implemented");
        }
        private GetMethodSigHelper(call: CallingConventions, returnType: Type, parameterTypes: Type[], requiredCustomModifiers: Type[][], optionalCustomModifiers: Type[][], optionalParameterTypes: Type[]): SignatureHelper {
            throw new Error("not yet implemented");
        }
        private AddParameters(sigHelp: SignatureHelper, parameterTypes: Type[], requiredCustomModifiers: Type[][], optionalCustomModifiers: Type[][]) {
            throw new Error("not yet implemented");
        }
        private RecordTokenFixup() {
            throw new Error("not yet implemented");
        }
        private GetTokenFor(rtType: RuntimeType): number {
            throw new Error("not yet implemented");
        }
        private GetTokenFor(runtimeField: RuntimeFieldInfo): number {
            throw new Error("not yet implemented");
        }
        private GetTokenFor(runtimeField: RuntimeFieldInfo, rtType: RuntimeType): number {
            throw new Error("not yet implemented");
        }
        private GetTokenFor(rtMeth: RuntimeConstructorInfo): number {
            throw new Error("not yet implemented");
        }
        private GetTokenFor(rtMeth: RuntimeConstructorInfo, rtType: RuntimeType): number {
            throw new Error("not yet implemented");
        }
        private GetTokenFor(rtMeth: RuntimeMethodInfo): number {
            throw new Error("not yet implemented");
        }
        private GetTokenFor(rtMeth: RuntimeMethodInfo, rtType: RuntimeType): number {
            throw new Error("not yet implemented");
        }
        private GetTokenFor(dm: DynamicMethod): number {
            throw new Error("not yet implemented");
        }
        private GetTokenForVarArgMethod(rtMeth: RuntimeMethodInfo, sig: SignatureHelper): number {
            throw new Error("not yet implemented");
        }
        private GetTokenForVarArgMethod(dm: DynamicMethod, sig: SignatureHelper): number {
            throw new Error("not yet implemented");
        }
        private GetTokenForString(s: string): number {
            throw new Error("not yet implemented");
        }
        private GetTokenForSig(sig: number[]): number {
            throw new Error("not yet implemented");
        }
    }
    export class DynamicILInfo {
        private m_method: DynamicMethod;
        private m_scope: DynamicScope;
        private m_exceptions: number[];
        private m_code: number[];
        private m_localSignature: number[];
        private m_maxStackSize: number;
        private m_methodSignature: number;

        private get LocalSignature(): number[] {
            throw new Error("not yet implemented");
        }
        private get Exceptions(): number[] {
            throw new Error("not yet implemented");
        }
        private get Code(): number[] {
            throw new Error("not yet implemented");
        }
        private get MaxStackSize(): number {
            throw new Error("not yet implemented");
        }
        public get DynamicMethod(): DynamicMethod {
            throw new Error("not yet implemented");
        }
        private get DynamicScope(): DynamicScope {
            throw new Error("not yet implemented");
        }

        protected constructor(method: DynamicMethod, methodSignature: number[]) {
            throw new Error("not yet implemented");
        }

        private GetCallableMethod(module: RuntimeModule, dm: DynamicMethod) {
            throw new Error("not yet implemented");
        }
        public SetCode(code: number[], maxStackSize: number) {
            throw new Error("not yet implemented");
        }
        public SetCode(code: number*, codeSize: number, maxStackSize: number) {
            throw new Error("not yet implemented");
        }
        public SetExceptions(exceptions: number[]) {
            throw new Error("not yet implemented");
        }
        public SetExceptions(exceptions: number*, exceptionsSize: number) {
            throw new Error("not yet implemented");
        }
        public SetLocalSignature(localSignature: number[]) {
            throw new Error("not yet implemented");
        }
        public SetLocalSignature(localSignature: number*, signatureSize: number) {
            throw new Error("not yet implemented");
        }
        public GetTokenFor(method: RuntimeMethodHandle): number {
            throw new Error("not yet implemented");
        }
        public GetTokenFor(method: DynamicMethod): number {
            throw new Error("not yet implemented");
        }
        public GetTokenFor(method: RuntimeMethodHandle, contextType: RuntimeTypeHandle): number {
            throw new Error("not yet implemented");
        }
        public GetTokenFor(field: RuntimeFieldHandle): number {
            throw new Error("not yet implemented");
        }
        public GetTokenFor(field: RuntimeFieldHandle, contextType: RuntimeTypeHandle): number {
            throw new Error("not yet implemented");
        }
        public GetTokenFor(type: RuntimeTypeHandle): number {
            throw new Error("not yet implemented");
        }
        public GetTokenFor(literal: string): number {
            throw new Error("not yet implemented");
        }
        public GetTokenFor(signature: number[]): number {
            throw new Error("not yet implemented");
        }
    }
    export class DynamicResolver extends Resolver {
        private m_exceptions: __ExceptionInfo[];
        private m_exceptionHeader: number[];
        private m_method: DynamicMethod;
        private m_code: number[];
        private m_localSignature: number[];
        private m_stackSize: number;
        private m_scope: DynamicScope;

        protected constructor(ilGenerator: DynamicILGenerator) {
            throw new Error("not yet implemented");
        }
        protected constructor(dynamicILInfo: DynamicILInfo) {
            throw new Error("not yet implemented");
        }

        private Finalize() {
            throw new Error("not yet implemented");
        }
        private GetJitContext(out securityControlFlags: number): RuntimeType {
            throw new Error("not yet implemented");
        }
        private static CalculateNumberOfExceptions(excp: __ExceptionInfo[]): number {
            throw new Error("not yet implemented");
        }
        private GetCodeInfo(out stackSize: number, out initLocals: number, out EHCount: number): number[] {
            throw new Error("not yet implemented");
        }
        private GetLocalsSignature(): number[] {
            throw new Error("not yet implemented");
        }
        private GetRawEHInfo(): number[] {
            throw new Error("not yet implemented");
        }
        private GetEHInfo(excNumber: number, exc: void*) {
            throw new Error("not yet implemented");
        }
        private GetStringLiteral(token: number): string {
            throw new Error("not yet implemented");
        }
        private ResolveToken(token: number, out typeHandle: number, out methodHandle: number, out fieldHandle: number) {
            throw new Error("not yet implemented");
        }
        private ResolveSignature(token: number, fromMethod: number): number[] {
            throw new Error("not yet implemented");
        }
        private GetDynamicMethod(): MethodInfo {
            throw new Error("not yet implemented");
        }
    }
    export namespace DynamicResolver {
        export class DestroyScout {
            private m_methodHandle: RuntimeMethodHandleInternal;

            public constructor() {
                throw new Error("not yet implemented");
            }

            private Finalize() {
                throw new Error("not yet implemented");
            }
        }

        export enum SecurityControlFlags {
            Default = 0x0,
            SkipVisibilityChecks = 0x1,
            RestrictedSkipVisibilityChecks = 0x2,
            HasCreationContext = 0x4,
            CanSkipCSEvaluation = 0x8,
        }
    }
    export class DynamicMethod extends MethodInfo implements ICustomAttributeProvider {
        private static s_anonymouslyHostedDynamicMethodsModule: Module;
        private static readonly s_anonymouslyHostedDynamicMethodsModuleLock: any;

        private _parameterTypes: RuntimeType[];
        private _methodHandle: IRuntimeMethodInfo;
        private _returnType: RuntimeType;
        private _ilGenerator: DynamicILGenerator;
        private _dynamicILInfo: DynamicILInfo;
        private _initLocals: boolean;
        private _module: Module;
        private _skipVisibility: boolean;
        private _typeOwner: RuntimeType;
        private _invoker: MethodBaseInvoker;
        private _signature: Signature;
        private _name: string;
        private _attributes: MethodAttributes;
        private _callingConvention: CallingConventions;
        private _parameters: RuntimeParameterInfo[];
        private _resolver: DynamicResolver;
        private _restrictedSkipVisibility: boolean;

        private get Invoker(): MethodBaseInvoker {
            throw new Error("not yet implemented");
        }
        private get Signature(): Signature {
            throw new Error("not yet implemented");
        }
        public get Name(): string {
            throw new Error("not yet implemented");
        }
        public get DeclaringType(): Type {
            throw new Error("not yet implemented");
        }
        public get ReflectedType(): Type {
            throw new Error("not yet implemented");
        }
        public get Module(): Module {
            throw new Error("not yet implemented");
        }
        public get MethodHandle(): RuntimeMethodHandle {
            throw new Error("not yet implemented");
        }
        public get Attributes(): MethodAttributes {
            throw new Error("not yet implemented");
        }
        public get CallingConvention(): CallingConventions {
            throw new Error("not yet implemented");
        }
        public get IsSecurityCritical(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsSecuritySafeCritical(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsSecurityTransparent(): boolean {
            throw new Error("not yet implemented");
        }
        public get ReturnType(): Type {
            throw new Error("not yet implemented");
        }
        public get ReturnParameter(): ParameterInfo {
            throw new Error("not yet implemented");
        }
        public get ReturnTypeCustomAttributes(): ICustomAttributeProvider {
            throw new Error("not yet implemented");
        }
        public get InitLocals(): boolean {
            throw new Error("not yet implemented");
        }
        public set InitLocals(value: boolean) {
            throw new Error("not yet implemented");
        }

        public constructor(name: string, returnType: Type, parameterTypes: Type[]) {
            throw new Error("not yet implemented");
        }
        public constructor(name: string, returnType: Type, parameterTypes: Type[], restrictedSkipVisibility: boolean) {
            throw new Error("not yet implemented");
        }
        public constructor(name: string, returnType: Type, parameterTypes: Type[], m: Module) {
            throw new Error("not yet implemented");
        }
        public constructor(name: string, returnType: Type, parameterTypes: Type[], m: Module, skipVisibility: boolean) {
            throw new Error("not yet implemented");
        }
        public constructor(name: string, attributes: MethodAttributes, callingConvention: CallingConventions, returnType: Type, parameterTypes: Type[], m: Module, skipVisibility: boolean) {
            throw new Error("not yet implemented");
        }
        public constructor(name: string, returnType: Type, parameterTypes: Type[], owner: Type) {
            throw new Error("not yet implemented");
        }
        public constructor(name: string, returnType: Type, parameterTypes: Type[], owner: Type, skipVisibility: boolean) {
            throw new Error("not yet implemented");
        }
        public constructor(name: string, attributes: MethodAttributes, callingConvention: CallingConventions, returnType: Type, parameterTypes: Type[], owner: Type, skipVisibility: boolean) {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

        public CreateDelegate(delegateType: Type): Delegate {
            throw new Error("not yet implemented");
        }
        public CreateDelegate(delegateType: Type, target: any): Delegate {
            throw new Error("not yet implemented");
        }
        private GetMethodDescriptor(): RuntimeMethodHandle {
            throw new Error("not yet implemented");
        }
        public Invoke(obj: any, invokeAttr: BindingFlags, binder: Binder, parameters: any[], culture: CultureInfo): any {
            throw new Error("not yet implemented");
        }
        public GetDynamicILInfo(): DynamicILInfo {
            throw new Error("not yet implemented");
        }
        public GetILGenerator(streamSize: number): ILGenerator {
            throw new Error("not yet implemented");
        }
        private static GetDynamicMethodsModule(): Module {
            throw new Error("not yet implemented");
        }
        private Init(name: string, attributes: MethodAttributes, callingConvention: CallingConventions, returnType: Type, signature: Type[], owner: Type, m: Module, skipVisibility: boolean, transparentMethod: boolean) {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
        public GetBaseDefinition(): MethodInfo {
            throw new Error("not yet implemented");
        }
        public GetParameters(): ParameterInfo[] {
            throw new Error("not yet implemented");
        }
        private GetParametersNoCopy(): ParameterInfo[] {
            throw new Error("not yet implemented");
        }
        public GetMethodImplementationFlags(): MethodImplAttributes {
            throw new Error("not yet implemented");
        }
        public GetCustomAttributes(attributeType: Type, inherit: boolean): any[] {
            throw new Error("not yet implemented");
        }
        public GetCustomAttributes(inherit: boolean): any[] {
            throw new Error("not yet implemented");
        }
        public IsDefined(attributeType: Type, inherit: boolean): boolean {
            throw new Error("not yet implemented");
        }
        public DefineParameter(position: number, attributes: ParameterAttributes, parameterName: string): ParameterBuilder {
            throw new Error("not yet implemented");
        }
        public GetILGenerator(): ILGenerator {
            throw new Error("not yet implemented");
        }
        private LoadParameters(): RuntimeParameterInfo[] {
            throw new Error("not yet implemented");
        }
        private __get_Signature__g__LazyCreateSignature_23_0(): Signature {
            throw new Error("not yet implemented");
        }
    }
    export class VarArgMethod {
        private m_method: RuntimeMethodInfo;
        private m_dynamicMethod: DynamicMethod;
        private m_signature: SignatureHelper;

        protected constructor(dm: DynamicMethod, signature: SignatureHelper) {
            throw new Error("not yet implemented");
        }
        protected constructor(method: RuntimeMethodInfo, signature: SignatureHelper) {
            throw new Error("not yet implemented");
        }

    }
    export class DynamicScope {
        private m_tokens: List<any>;

        private get Item(): any {
            throw new Error("not yet implemented");
        }

        public constructor() {
            throw new Error("not yet implemented");
        }

        private GetTokenFor(varArgMethod: VarArgMethod): number {
            throw new Error("not yet implemented");
        }
        private GetString(token: number): string {
            throw new Error("not yet implemented");
        }
        private ResolveSignature(token: number, fromMethod: number): number[] {
            throw new Error("not yet implemented");
        }
        public GetTokenFor(method: RuntimeMethodHandle): number {
            throw new Error("not yet implemented");
        }
        public GetTokenFor(method: RuntimeMethodHandle, typeContext: RuntimeTypeHandle): number {
            throw new Error("not yet implemented");
        }
        public GetTokenFor(method: DynamicMethod): number {
            throw new Error("not yet implemented");
        }
        public GetTokenFor(field: RuntimeFieldHandle): number {
            throw new Error("not yet implemented");
        }
        public GetTokenFor(field: RuntimeFieldHandle, typeContext: RuntimeTypeHandle): number {
            throw new Error("not yet implemented");
        }
        public GetTokenFor(type: RuntimeTypeHandle): number {
            throw new Error("not yet implemented");
        }
        public GetTokenFor(literal: string): number {
            throw new Error("not yet implemented");
        }
        public GetTokenFor(signature: number[]): number {
            throw new Error("not yet implemented");
        }
    }
    export class SignatureHelper {
        private m_signature: number[];
        private m_currSig: number;
        private m_sizeLoc: number;
        private m_module: ModuleBuilder;
        private m_sigDone: boolean;
        private m_argCount: number;

        private get ArgumentCount(): number {
            throw new Error("not yet implemented");
        }

        private constructor(mod: Module, callingConvention: MdSigCallingConvention) {
            throw new Error("not yet implemented");
        }
        private constructor(mod: Module, callingConvention: MdSigCallingConvention, cGenericParameters: number, returnType: Type, requiredCustomModifiers: Type[], optionalCustomModifiers: Type[]) {
            throw new Error("not yet implemented");
        }
        private constructor(mod: Module, callingConvention: MdSigCallingConvention, returnType: Type, requiredCustomModifiers: Type[], optionalCustomModifiers: Type[]) {
            throw new Error("not yet implemented");
        }
        private constructor(mod: Module, type: Type) {
            throw new Error("not yet implemented");
        }

        public static GetMethodSigHelper(mod: Module, returnType: Type, parameterTypes: Type[]): SignatureHelper {
            throw new Error("not yet implemented");
        }
        public static GetMethodSigHelper(mod: Module, callingConvention: CallingConventions, returnType: Type): SignatureHelper {
            throw new Error("not yet implemented");
        }
        private static GetMethodSpecSigHelper(scope: Module, inst: Type[]): SignatureHelper {
            throw new Error("not yet implemented");
        }
        private static GetMethodSigHelper(scope: Module, callingConvention: CallingConventions, returnType: Type, requiredReturnTypeCustomModifiers: Type[], optionalReturnTypeCustomModifiers: Type[], parameterTypes: Type[], requiredParameterTypeCustomModifiers: Type[][], optionalParameterTypeCustomModifiers: Type[][]): SignatureHelper {
            throw new Error("not yet implemented");
        }
        private static GetMethodSigHelper(scope: Module, callingConvention: CallingConventions, cGenericParam: number, returnType: Type, requiredReturnTypeCustomModifiers: Type[], optionalReturnTypeCustomModifiers: Type[], parameterTypes: Type[], requiredParameterTypeCustomModifiers: Type[][], optionalParameterTypeCustomModifiers: Type[][]): SignatureHelper {
            throw new Error("not yet implemented");
        }
        private static GetMethodSigHelper(mod: Module, unmanagedCallConv: CallingConvention, returnType: Type): SignatureHelper {
            throw new Error("not yet implemented");
        }
        public static GetLocalVarSigHelper(): SignatureHelper {
            throw new Error("not yet implemented");
        }
        public static GetMethodSigHelper(callingConvention: CallingConventions, returnType: Type): SignatureHelper {
            throw new Error("not yet implemented");
        }
        public static GetLocalVarSigHelper(mod: Module): SignatureHelper {
            throw new Error("not yet implemented");
        }
        public static GetFieldSigHelper(mod: Module): SignatureHelper {
            throw new Error("not yet implemented");
        }
        public static GetPropertySigHelper(mod: Module, returnType: Type, parameterTypes: Type[]): SignatureHelper {
            throw new Error("not yet implemented");
        }
        public static GetPropertySigHelper(mod: Module, returnType: Type, requiredReturnTypeCustomModifiers: Type[], optionalReturnTypeCustomModifiers: Type[], parameterTypes: Type[], requiredParameterTypeCustomModifiers: Type[][], optionalParameterTypeCustomModifiers: Type[][]): SignatureHelper {
            throw new Error("not yet implemented");
        }
        public static GetPropertySigHelper(mod: Module, callingConvention: CallingConventions, returnType: Type, requiredReturnTypeCustomModifiers: Type[], optionalReturnTypeCustomModifiers: Type[], parameterTypes: Type[], requiredParameterTypeCustomModifiers: Type[][], optionalParameterTypeCustomModifiers: Type[][]): SignatureHelper {
            throw new Error("not yet implemented");
        }
        private static GetTypeSigToken(module: Module, type: Type): SignatureHelper {
            throw new Error("not yet implemented");
        }
        private Init(mod: Module) {
            throw new Error("not yet implemented");
        }
        private Init(mod: Module, callingConvention: MdSigCallingConvention) {
            throw new Error("not yet implemented");
        }
        private Init(mod: Module, callingConvention: MdSigCallingConvention, cGenericParam: number) {
            throw new Error("not yet implemented");
        }
        private AddOneArgTypeHelper(argument: Type, pinned: boolean) {
            throw new Error("not yet implemented");
        }
        private AddOneArgTypeHelper(clsArgument: Type, requiredCustomModifiers: Type[], optionalCustomModifiers: Type[]) {
            throw new Error("not yet implemented");
        }
        private AddOneArgTypeHelper(clsArgument: Type) {
            throw new Error("not yet implemented");
        }
        private AddOneArgTypeHelperWorker(clsArgument: Type, lastWasGenericInst: boolean) {
            throw new Error("not yet implemented");
        }
        private AddData(data: number) {
            throw new Error("not yet implemented");
        }
        private AddElementType(cvt: CorElementType) {
            throw new Error("not yet implemented");
        }
        private AddToken(token: number) {
            throw new Error("not yet implemented");
        }
        private InternalAddTypeToken(clsToken: number, CorType: CorElementType) {
            throw new Error("not yet implemented");
        }
        private InternalAddRuntimeType(type: Type) {
            throw new Error("not yet implemented");
        }
        private static ExpandArray(inArray: number[]): number[] {
            throw new Error("not yet implemented");
        }
        private static ExpandArray(inArray: number[], requiredLength: number): number[] {
            throw new Error("not yet implemented");
        }
        private IncrementArgCounts() {
            throw new Error("not yet implemented");
        }
        private SetNumberOfSignatureElements(forceCopy: boolean) {
            throw new Error("not yet implemented");
        }
        private static IsSimpleType(type: CorElementType): boolean {
            throw new Error("not yet implemented");
        }
        private InternalGetSignature(out length: number): number[] {
            throw new Error("not yet implemented");
        }
        private InternalGetSignatureArray(): number[] {
            throw new Error("not yet implemented");
        }
        private AddDynamicArgument(dynamicScope: DynamicScope, clsArgument: Type, requiredCustomModifiers: Type[], optionalCustomModifiers: Type[]) {
            throw new Error("not yet implemented");
        }
        public AddArgument(clsArgument: Type) {
            throw new Error("not yet implemented");
        }
        public AddArgument(argument: Type, pinned: boolean) {
            throw new Error("not yet implemented");
        }
        public AddArguments(arguments: Type[], requiredCustomModifiers: Type[][], optionalCustomModifiers: Type[][]) {
            throw new Error("not yet implemented");
        }
        public AddArgument(argument: Type, requiredCustomModifiers: Type[], optionalCustomModifiers: Type[]) {
            throw new Error("not yet implemented");
        }
        public AddSentinel() {
            throw new Error("not yet implemented");
        }
        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public GetSignature(): number[] {
            throw new Error("not yet implemented");
        }
        private GetSignature(appendEndOfSig: boolean): number[] {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
    }
    export abstract class ILGenerator {
        private static readonly s_parameterTypes: Type[];

        public get ILOffset(): number;

        protected constructor() {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

        public Emit(opcode: OpCode): void;
        public Emit(opcode: OpCode, arg: number): void;
        public Emit(opcode: OpCode, arg: number): void;
        public Emit(opcode: OpCode, arg: number): void;
        public Emit(opcode: OpCode, arg: number): void;
        public Emit(opcode: OpCode, arg: number): void;
        public Emit(opcode: OpCode, arg: number): void;
        public Emit(opcode: OpCode, meth: MethodInfo): void;
        public EmitCalli(opcode: OpCode, callingConvention: CallingConventions, returnType: Type, parameterTypes: Type[], optionalParameterTypes: Type[]): void;
        public EmitCalli(opcode: OpCode, unmanagedCallConv: CallingConvention, returnType: Type, parameterTypes: Type[]): void;
        public EmitCall(opcode: OpCode, methodInfo: MethodInfo, optionalParameterTypes: Type[]): void;
        public Emit(opcode: OpCode, signature: SignatureHelper): void;
        public Emit(opcode: OpCode, con: ConstructorInfo): void;
        public Emit(opcode: OpCode, cls: Type): void;
        public Emit(opcode: OpCode, label: Label): void;
        public Emit(opcode: OpCode, labels: Label[]): void;
        public Emit(opcode: OpCode, field: FieldInfo): void;
        public Emit(opcode: OpCode, str: string): void;
        public Emit(opcode: OpCode, local: LocalBuilder): void;
        public BeginExceptionBlock(): Label;
        public EndExceptionBlock(): void;
        public BeginExceptFilterBlock(): void;
        public BeginCatchBlock(exceptionType: Type): void;
        public BeginFaultBlock(): void;
        public BeginFinallyBlock(): void;
        public DefineLabel(): Label;
        public MarkLabel(loc: Label): void;
        public ThrowException(excType: Type) {
            throw new Error("not yet implemented");
        }
        public EmitWriteLine(value: string) {
            throw new Error("not yet implemented");
        }
        public EmitWriteLine(localBuilder: LocalBuilder) {
            throw new Error("not yet implemented");
        }
        public EmitWriteLine(fld: FieldInfo) {
            throw new Error("not yet implemented");
        }
        public DeclareLocal(localType: Type): LocalBuilder {
            throw new Error("not yet implemented");
        }
        public DeclareLocal(localType: Type, pinned: boolean): LocalBuilder;
        public UsingNamespace(usingNamespace: string): void;
        public BeginScope(): void;
        public EndScope(): void;
        public Emit(opcode: OpCode, arg: number) {
            throw new Error("not yet implemented");
        }
    }
    export abstract class MethodBuilder extends MethodInfo implements ICustomAttributeProvider {
        public get InitLocals(): boolean {
            throw new Error("not yet implemented");
        }
        public set InitLocals(value: boolean) {
            throw new Error("not yet implemented");
        }
        private get InitLocalsCore(): boolean;
        private set InitLocalsCore(value: boolean);

        protected constructor() {
            throw new Error("not yet implemented");
        }

        public DefineGenericParameters(names: string[]): GenericTypeParameterBuilder[] {
            throw new Error("not yet implemented");
        }
        private DefineGenericParametersCore(names: string[]): GenericTypeParameterBuilder[];
        public DefineParameter(position: number, attributes: ParameterAttributes, strParamName: string): ParameterBuilder {
            throw new Error("not yet implemented");
        }
        private DefineParameterCore(position: number, attributes: ParameterAttributes, strParamName: string): ParameterBuilder;
        public GetILGenerator(): ILGenerator {
            throw new Error("not yet implemented");
        }
        public GetILGenerator(size: number): ILGenerator {
            throw new Error("not yet implemented");
        }
        private GetILGeneratorCore(size: number): ILGenerator;
        public SetCustomAttribute(con: ConstructorInfo, binaryAttribute: number[]) {
            throw new Error("not yet implemented");
        }
        private SetCustomAttribute(con: ConstructorInfo, binaryAttribute: ReadOnlySpan<number>) {
            throw new Error("not yet implemented");
        }
        private SetCustomAttributeCore(con: ConstructorInfo, binaryAttribute: ReadOnlySpan<number>): void;
        public SetCustomAttribute(customBuilder: CustomAttributeBuilder) {
            throw new Error("not yet implemented");
        }
        public SetImplementationFlags(attributes: MethodImplAttributes) {
            throw new Error("not yet implemented");
        }
        private SetImplementationFlagsCore(attributes: MethodImplAttributes): void;
        public SetParameters(parameterTypes: Type[]) {
            throw new Error("not yet implemented");
        }
        public SetReturnType(returnType: Type) {
            throw new Error("not yet implemented");
        }
        public SetSignature(returnType: Type, returnTypeRequiredCustomModifiers: Type[], returnTypeOptionalCustomModifiers: Type[], parameterTypes: Type[], parameterTypeRequiredCustomModifiers: Type[][], parameterTypeOptionalCustomModifiers: Type[][]) {
            throw new Error("not yet implemented");
        }
        private SetSignatureCore(returnType: Type, returnTypeRequiredCustomModifiers: Type[], returnTypeOptionalCustomModifiers: Type[], parameterTypes: Type[], parameterTypeRequiredCustomModifiers: Type[][], parameterTypeOptionalCustomModifiers: Type[][]): void;
    }
    export enum PackingSize {
        Unspecified = 0,
        Size1 = 1,
        Size2 = 2,
        Size4 = 4,
        Size8 = 8,
        Size16 = 16,
        Size32 = 32,
        Size64 = 64,
        Size128 = 128,
    }
    export abstract class ConstructorBuilder extends ConstructorInfo implements ICustomAttributeProvider {
        public get InitLocals(): boolean {
            throw new Error("not yet implemented");
        }
        public set InitLocals(value: boolean) {
            throw new Error("not yet implemented");
        }
        private get InitLocalsCore(): boolean;
        private set InitLocalsCore(value: boolean);

        protected constructor() {
            throw new Error("not yet implemented");
        }

        public DefineParameter(iSequence: number, attributes: ParameterAttributes, strParamName: string): ParameterBuilder {
            throw new Error("not yet implemented");
        }
        private DefineParameterCore(iSequence: number, attributes: ParameterAttributes, strParamName: string): ParameterBuilder;
        public GetILGenerator(): ILGenerator {
            throw new Error("not yet implemented");
        }
        public GetILGenerator(streamSize: number): ILGenerator {
            throw new Error("not yet implemented");
        }
        private GetILGeneratorCore(streamSize: number): ILGenerator;
        public SetCustomAttribute(con: ConstructorInfo, binaryAttribute: number[]) {
            throw new Error("not yet implemented");
        }
        private SetCustomAttributeCore(con: ConstructorInfo, binaryAttribute: ReadOnlySpan<number>): void;
        public SetCustomAttribute(customBuilder: CustomAttributeBuilder) {
            throw new Error("not yet implemented");
        }
        public SetImplementationFlags(attributes: MethodImplAttributes) {
            throw new Error("not yet implemented");
        }
        private SetImplementationFlagsCore(attributes: MethodImplAttributes): void;
    }
    export abstract class EventBuilder {
        protected constructor() {
            throw new Error("not yet implemented");
        }

        public AddOtherMethod(mdBuilder: MethodBuilder) {
            throw new Error("not yet implemented");
        }
        private AddOtherMethodCore(mdBuilder: MethodBuilder): void;
        public SetAddOnMethod(mdBuilder: MethodBuilder) {
            throw new Error("not yet implemented");
        }
        private SetAddOnMethodCore(mdBuilder: MethodBuilder): void;
        public SetCustomAttribute(con: ConstructorInfo, binaryAttribute: number[]) {
            throw new Error("not yet implemented");
        }
        private SetCustomAttributeCore(con: ConstructorInfo, binaryAttribute: ReadOnlySpan<number>): void;
        public SetCustomAttribute(customBuilder: CustomAttributeBuilder) {
            throw new Error("not yet implemented");
        }
        public SetRaiseMethod(mdBuilder: MethodBuilder) {
            throw new Error("not yet implemented");
        }
        private SetRaiseMethodCore(mdBuilder: MethodBuilder): void;
        public SetRemoveOnMethod(mdBuilder: MethodBuilder) {
            throw new Error("not yet implemented");
        }
        private SetRemoveOnMethodCore(mdBuilder: MethodBuilder): void;
    }
    export abstract class PropertyBuilder extends PropertyInfo implements ICustomAttributeProvider {
        protected constructor() {
            throw new Error("not yet implemented");
        }

        public AddOtherMethod(mdBuilder: MethodBuilder) {
            throw new Error("not yet implemented");
        }
        private AddOtherMethodCore(mdBuilder: MethodBuilder): void;
        public SetConstant(defaultValue: any) {
            throw new Error("not yet implemented");
        }
        private SetConstantCore(defaultValue: any): void;
        public SetCustomAttribute(con: ConstructorInfo, binaryAttribute: number[]) {
            throw new Error("not yet implemented");
        }
        private SetCustomAttributeCore(con: ConstructorInfo, binaryAttribute: ReadOnlySpan<number>): void;
        public SetCustomAttribute(customBuilder: CustomAttributeBuilder) {
            throw new Error("not yet implemented");
        }
        public SetGetMethod(mdBuilder: MethodBuilder) {
            throw new Error("not yet implemented");
        }
        private SetGetMethodCore(mdBuilder: MethodBuilder): void;
        public SetSetMethod(mdBuilder: MethodBuilder) {
            throw new Error("not yet implemented");
        }
        private SetSetMethodCore(mdBuilder: MethodBuilder): void;
    }
    export abstract class TypeBuilder extends TypeInfo implements ICustomAttributeProvider, IReflect, IReflectableType {
        public static UnspecifiedTypeSize: number;

        public get PackingSize(): PackingSize {
            throw new Error("not yet implemented");
        }
        private get PackingSizeCore(): PackingSize;
        public get Size(): number {
            throw new Error("not yet implemented");
        }
        private get SizeCore(): number;

        protected constructor() {
            throw new Error("not yet implemented");
        }

        public static GetMethod(type: Type, method: MethodInfo): MethodInfo {
            throw new Error("not yet implemented");
        }
        public static GetConstructor(type: Type, constructor: ConstructorInfo): ConstructorInfo {
            throw new Error("not yet implemented");
        }
        public static GetField(type: Type, field: FieldInfo): FieldInfo {
            throw new Error("not yet implemented");
        }
        public AddInterfaceImplementation(interfaceType: Type) {
            throw new Error("not yet implemented");
        }
        private AddInterfaceImplementationCore(interfaceType: Type): void;
        public CreateType(): Type {
            throw new Error("not yet implemented");
        }
        public CreateTypeInfo(): TypeInfo {
            throw new Error("not yet implemented");
        }
        private CreateTypeInfoCore(): TypeInfo;
        public DefineConstructor(attributes: MethodAttributes, callingConvention: CallingConventions, parameterTypes: Type[]): ConstructorBuilder {
            throw new Error("not yet implemented");
        }
        public DefineConstructor(attributes: MethodAttributes, callingConvention: CallingConventions, parameterTypes: Type[], requiredCustomModifiers: Type[][], optionalCustomModifiers: Type[][]): ConstructorBuilder {
            throw new Error("not yet implemented");
        }
        private DefineConstructorCore(attributes: MethodAttributes, callingConvention: CallingConventions, parameterTypes: Type[], requiredCustomModifiers: Type[][], optionalCustomModifiers: Type[][]): ConstructorBuilder;
        public DefineDefaultConstructor(attributes: MethodAttributes): ConstructorBuilder {
            throw new Error("not yet implemented");
        }
        private DefineDefaultConstructorCore(attributes: MethodAttributes): ConstructorBuilder;
        public DefineEvent(name: string, attributes: EventAttributes, eventtype: Type): EventBuilder {
            throw new Error("not yet implemented");
        }
        private DefineEventCore(name: string, attributes: EventAttributes, eventtype: Type): EventBuilder;
        public DefineField(fieldName: string, type: Type, attributes: FieldAttributes): FieldBuilder {
            throw new Error("not yet implemented");
        }
        public DefineField(fieldName: string, type: Type, requiredCustomModifiers: Type[], optionalCustomModifiers: Type[], attributes: FieldAttributes): FieldBuilder {
            throw new Error("not yet implemented");
        }
        private DefineFieldCore(fieldName: string, type: Type, requiredCustomModifiers: Type[], optionalCustomModifiers: Type[], attributes: FieldAttributes): FieldBuilder;
        public DefineGenericParameters(names: string[]): GenericTypeParameterBuilder[] {
            throw new Error("not yet implemented");
        }
        private DefineGenericParametersCore(names: string[]): GenericTypeParameterBuilder[];
        public DefineInitializedData(name: string, data: number[], attributes: FieldAttributes): FieldBuilder {
            throw new Error("not yet implemented");
        }
        private DefineInitializedDataCore(name: string, data: number[], attributes: FieldAttributes): FieldBuilder;
        public DefineMethod(name: string, attributes: MethodAttributes): MethodBuilder {
            throw new Error("not yet implemented");
        }
        public DefineMethod(name: string, attributes: MethodAttributes, callingConvention: CallingConventions): MethodBuilder {
            throw new Error("not yet implemented");
        }
        public DefineMethod(name: string, attributes: MethodAttributes, callingConvention: CallingConventions, returnType: Type, parameterTypes: Type[]): MethodBuilder {
            throw new Error("not yet implemented");
        }
        public DefineMethod(name: string, attributes: MethodAttributes, returnType: Type, parameterTypes: Type[]): MethodBuilder {
            throw new Error("not yet implemented");
        }
        public DefineMethod(name: string, attributes: MethodAttributes, callingConvention: CallingConventions, returnType: Type, returnTypeRequiredCustomModifiers: Type[], returnTypeOptionalCustomModifiers: Type[], parameterTypes: Type[], parameterTypeRequiredCustomModifiers: Type[][], parameterTypeOptionalCustomModifiers: Type[][]): MethodBuilder {
            throw new Error("not yet implemented");
        }
        private DefineMethodCore(name: string, attributes: MethodAttributes, callingConvention: CallingConventions, returnType: Type, returnTypeRequiredCustomModifiers: Type[], returnTypeOptionalCustomModifiers: Type[], parameterTypes: Type[], parameterTypeRequiredCustomModifiers: Type[][], parameterTypeOptionalCustomModifiers: Type[][]): MethodBuilder;
        public DefineMethodOverride(methodInfoBody: MethodInfo, methodInfoDeclaration: MethodInfo) {
            throw new Error("not yet implemented");
        }
        private DefineMethodOverrideCore(methodInfoBody: MethodInfo, methodInfoDeclaration: MethodInfo): void;
        public DefineNestedType(name: string): TypeBuilder {
            throw new Error("not yet implemented");
        }
        public DefineNestedType(name: string, attr: TypeAttributes): TypeBuilder {
            throw new Error("not yet implemented");
        }
        public DefineNestedType(name: string, attr: TypeAttributes, parent: Type): TypeBuilder {
            throw new Error("not yet implemented");
        }
        public DefineNestedType(name: string, attr: TypeAttributes, parent: Type, interfaces: Type[]): TypeBuilder {
            throw new Error("not yet implemented");
        }
        private DefineNestedTypeCore(name: string, attr: TypeAttributes, parent: Type, interfaces: Type[], packSize: PackingSize, typeSize: number): TypeBuilder;
        public DefineNestedType(name: string, attr: TypeAttributes, parent: Type, typeSize: number): TypeBuilder {
            throw new Error("not yet implemented");
        }
        public DefineNestedType(name: string, attr: TypeAttributes, parent: Type, packSize: PackingSize): TypeBuilder {
            throw new Error("not yet implemented");
        }
        public DefineNestedType(name: string, attr: TypeAttributes, parent: Type, packSize: PackingSize, typeSize: number): TypeBuilder {
            throw new Error("not yet implemented");
        }
        public DefinePInvokeMethod(name: string, dllName: string, attributes: MethodAttributes, callingConvention: CallingConventions, returnType: Type, parameterTypes: Type[], nativeCallConv: CallingConvention, nativeCharSet: CharSet): MethodBuilder {
            throw new Error("not yet implemented");
        }
        public DefinePInvokeMethod(name: string, dllName: string, entryName: string, attributes: MethodAttributes, callingConvention: CallingConventions, returnType: Type, parameterTypes: Type[], nativeCallConv: CallingConvention, nativeCharSet: CharSet): MethodBuilder {
            throw new Error("not yet implemented");
        }
        public DefinePInvokeMethod(name: string, dllName: string, entryName: string, attributes: MethodAttributes, callingConvention: CallingConventions, returnType: Type, returnTypeRequiredCustomModifiers: Type[], returnTypeOptionalCustomModifiers: Type[], parameterTypes: Type[], parameterTypeRequiredCustomModifiers: Type[][], parameterTypeOptionalCustomModifiers: Type[][], nativeCallConv: CallingConvention, nativeCharSet: CharSet): MethodBuilder {
            throw new Error("not yet implemented");
        }
        private DefinePInvokeMethodCore(name: string, dllName: string, entryName: string, attributes: MethodAttributes, callingConvention: CallingConventions, returnType: Type, returnTypeRequiredCustomModifiers: Type[], returnTypeOptionalCustomModifiers: Type[], parameterTypes: Type[], parameterTypeRequiredCustomModifiers: Type[][], parameterTypeOptionalCustomModifiers: Type[][], nativeCallConv: CallingConvention, nativeCharSet: CharSet): MethodBuilder;
        public DefineProperty(name: string, attributes: PropertyAttributes, returnType: Type, parameterTypes: Type[]): PropertyBuilder {
            throw new Error("not yet implemented");
        }
        public DefineProperty(name: string, attributes: PropertyAttributes, callingConvention: CallingConventions, returnType: Type, parameterTypes: Type[]): PropertyBuilder {
            throw new Error("not yet implemented");
        }
        public DefineProperty(name: string, attributes: PropertyAttributes, returnType: Type, returnTypeRequiredCustomModifiers: Type[], returnTypeOptionalCustomModifiers: Type[], parameterTypes: Type[], parameterTypeRequiredCustomModifiers: Type[][], parameterTypeOptionalCustomModifiers: Type[][]): PropertyBuilder {
            throw new Error("not yet implemented");
        }
        public DefineProperty(name: string, attributes: PropertyAttributes, callingConvention: CallingConventions, returnType: Type, returnTypeRequiredCustomModifiers: Type[], returnTypeOptionalCustomModifiers: Type[], parameterTypes: Type[], parameterTypeRequiredCustomModifiers: Type[][], parameterTypeOptionalCustomModifiers: Type[][]): PropertyBuilder {
            throw new Error("not yet implemented");
        }
        private DefinePropertyCore(name: string, attributes: PropertyAttributes, callingConvention: CallingConventions, returnType: Type, returnTypeRequiredCustomModifiers: Type[], returnTypeOptionalCustomModifiers: Type[], parameterTypes: Type[], parameterTypeRequiredCustomModifiers: Type[][], parameterTypeOptionalCustomModifiers: Type[][]): PropertyBuilder;
        public DefineTypeInitializer(): ConstructorBuilder {
            throw new Error("not yet implemented");
        }
        private DefineTypeInitializerCore(): ConstructorBuilder;
        public DefineUninitializedData(name: string, size: number, attributes: FieldAttributes): FieldBuilder {
            throw new Error("not yet implemented");
        }
        private DefineUninitializedDataCore(name: string, size: number, attributes: FieldAttributes): FieldBuilder;
        public IsCreated(): boolean {
            throw new Error("not yet implemented");
        }
        private IsCreatedCore(): boolean;
        public SetCustomAttribute(con: ConstructorInfo, binaryAttribute: number[]) {
            throw new Error("not yet implemented");
        }
        private SetCustomAttributeCore(con: ConstructorInfo, binaryAttribute: ReadOnlySpan<number>): void;
        public SetCustomAttribute(customBuilder: CustomAttributeBuilder) {
            throw new Error("not yet implemented");
        }
        public SetParent(parent: Type) {
            throw new Error("not yet implemented");
        }
        private SetParentCore(parent: Type): void;
        public MakePointerType(): Type {
            throw new Error("not yet implemented");
        }
        public MakeByRefType(): Type {
            throw new Error("not yet implemented");
        }
        public MakeArrayType(): Type {
            throw new Error("not yet implemented");
        }
        public MakeArrayType(rank: number): Type {
            throw new Error("not yet implemented");
        }
        public MakeGenericType(typeArguments: Type[]): Type {
            throw new Error("not yet implemented");
        }
    }
    export abstract class ModuleBuilder extends Module implements ICustomAttributeProvider, ISerializable {
        protected constructor() {
            throw new Error("not yet implemented");
        }

        public CreateGlobalFunctions() {
            throw new Error("not yet implemented");
        }
        private CreateGlobalFunctionsCore(): void;
        public DefineEnum(name: string, visibility: TypeAttributes, underlyingType: Type): EnumBuilder {
            throw new Error("not yet implemented");
        }
        private DefineEnumCore(name: string, visibility: TypeAttributes, underlyingType: Type): EnumBuilder;
        public DefineGlobalMethod(name: string, attributes: MethodAttributes, returnType: Type, parameterTypes: Type[]): MethodBuilder {
            throw new Error("not yet implemented");
        }
        public DefineGlobalMethod(name: string, attributes: MethodAttributes, callingConvention: CallingConventions, returnType: Type, parameterTypes: Type[]): MethodBuilder {
            throw new Error("not yet implemented");
        }
        public DefineGlobalMethod(name: string, attributes: MethodAttributes, callingConvention: CallingConventions, returnType: Type, requiredReturnTypeCustomModifiers: Type[], optionalReturnTypeCustomModifiers: Type[], parameterTypes: Type[], requiredParameterTypeCustomModifiers: Type[][], optionalParameterTypeCustomModifiers: Type[][]): MethodBuilder {
            throw new Error("not yet implemented");
        }
        private DefineGlobalMethodCore(name: string, attributes: MethodAttributes, callingConvention: CallingConventions, returnType: Type, requiredReturnTypeCustomModifiers: Type[], optionalReturnTypeCustomModifiers: Type[], parameterTypes: Type[], requiredParameterTypeCustomModifiers: Type[][], optionalParameterTypeCustomModifiers: Type[][]): MethodBuilder;
        public DefineInitializedData(name: string, data: number[], attributes: FieldAttributes): FieldBuilder {
            throw new Error("not yet implemented");
        }
        private DefineInitializedDataCore(name: string, data: number[], attributes: FieldAttributes): FieldBuilder;
        public DefinePInvokeMethod(name: string, dllName: string, attributes: MethodAttributes, callingConvention: CallingConventions, returnType: Type, parameterTypes: Type[], nativeCallConv: CallingConvention, nativeCharSet: CharSet): MethodBuilder {
            throw new Error("not yet implemented");
        }
        public DefinePInvokeMethod(name: string, dllName: string, entryName: string, attributes: MethodAttributes, callingConvention: CallingConventions, returnType: Type, parameterTypes: Type[], nativeCallConv: CallingConvention, nativeCharSet: CharSet): MethodBuilder {
            throw new Error("not yet implemented");
        }
        private DefinePInvokeMethodCore(name: string, dllName: string, entryName: string, attributes: MethodAttributes, callingConvention: CallingConventions, returnType: Type, parameterTypes: Type[], nativeCallConv: CallingConvention, nativeCharSet: CharSet): MethodBuilder;
        public DefineType(name: string): TypeBuilder {
            throw new Error("not yet implemented");
        }
        public DefineType(name: string, attr: TypeAttributes): TypeBuilder {
            throw new Error("not yet implemented");
        }
        public DefineType(name: string, attr: TypeAttributes, parent: Type): TypeBuilder {
            throw new Error("not yet implemented");
        }
        public DefineType(name: string, attr: TypeAttributes, parent: Type, interfaces: Type[]): TypeBuilder {
            throw new Error("not yet implemented");
        }
        public DefineType(name: string, attr: TypeAttributes, parent: Type, typesize: number): TypeBuilder {
            throw new Error("not yet implemented");
        }
        public DefineType(name: string, attr: TypeAttributes, parent: Type, packsize: PackingSize): TypeBuilder {
            throw new Error("not yet implemented");
        }
        public DefineType(name: string, attr: TypeAttributes, parent: Type, packingSize: PackingSize, typesize: number): TypeBuilder {
            throw new Error("not yet implemented");
        }
        private DefineTypeCore(name: string, attr: TypeAttributes, parent: Type, interfaces: Type[], packingSize: PackingSize, typesize: number): TypeBuilder;
        public DefineUninitializedData(name: string, size: number, attributes: FieldAttributes): FieldBuilder {
            throw new Error("not yet implemented");
        }
        private DefineUninitializedDataCore(name: string, size: number, attributes: FieldAttributes): FieldBuilder;
        public GetArrayMethod(arrayClass: Type, methodName: string, callingConvention: CallingConventions, returnType: Type, parameterTypes: Type[]): MethodInfo {
            throw new Error("not yet implemented");
        }
        private GetArrayMethodCore(arrayClass: Type, methodName: string, callingConvention: CallingConventions, returnType: Type, parameterTypes: Type[]): MethodInfo;
        public SetCustomAttribute(con: ConstructorInfo, binaryAttribute: number[]) {
            throw new Error("not yet implemented");
        }
        private SetCustomAttributeCore(con: ConstructorInfo, binaryAttribute: ReadOnlySpan<number>): void;
        public SetCustomAttribute(customBuilder: CustomAttributeBuilder) {
            throw new Error("not yet implemented");
        }
        public GetTypeMetadataToken(type: Type): number;
        public GetFieldMetadataToken(field: FieldInfo): number;
        public GetMethodMetadataToken(method: MethodInfo): number;
        public GetMethodMetadataToken(constructor: ConstructorInfo): number;
        public GetSignatureMetadataToken(signature: SignatureHelper): number;
        public GetStringMetadataToken(stringConstant: string): number;
    }
    export enum AssemblyBuilderAccess {
        Run = 0x1,
        RunAndCollect = 0x9,
    }
    export abstract class AssemblyBuilder extends Assembly implements ICustomAttributeProvider, ISerializable {
        private static t_allowDynamicCode: boolean;

        public get CodeBase(): string {
            throw new Error("not yet implemented");
        }
        public get Location(): string {
            throw new Error("not yet implemented");
        }
        public get EntryPoint(): MethodInfo {
            throw new Error("not yet implemented");
        }
        public get IsDynamic(): boolean {
            throw new Error("not yet implemented");
        }

        protected constructor() {
            throw new Error("not yet implemented");
        }

        public static DefineDynamicAssembly(name: AssemblyName, access: AssemblyBuilderAccess): AssemblyBuilder {
            throw new Error("not yet implemented");
        }
        public static DefineDynamicAssembly(name: AssemblyName, access: AssemblyBuilderAccess, assemblyAttributes: IEnumerable<CustomAttributeBuilder>): AssemblyBuilder {
            throw new Error("not yet implemented");
        }
        private static DefineDynamicAssembly(name: AssemblyName, access: AssemblyBuilderAccess, assemblyAttributes: IEnumerable<CustomAttributeBuilder>, callingAssembly: Assembly): RuntimeAssemblyBuilder {
            throw new Error("not yet implemented");
        }
        public DefineDynamicModule(name: string): ModuleBuilder {
            throw new Error("not yet implemented");
        }
        private DefineDynamicModuleCore(name: string): ModuleBuilder;
        public GetDynamicModule(name: string): ModuleBuilder {
            throw new Error("not yet implemented");
        }
        private GetDynamicModuleCore(name: string): ModuleBuilder;
        public SetCustomAttribute(con: ConstructorInfo, binaryAttribute: number[]) {
            throw new Error("not yet implemented");
        }
        private SetCustomAttributeCore(con: ConstructorInfo, binaryAttribute: ReadOnlySpan<number>): void;
        public SetCustomAttribute(customBuilder: CustomAttributeBuilder) {
            throw new Error("not yet implemented");
        }
        public GetExportedTypes(): Type[] {
            throw new Error("not yet implemented");
        }
        public GetFile(name: string): FileStream {
            throw new Error("not yet implemented");
        }
        public GetFiles(getResourceModules: boolean): FileStream[] {
            throw new Error("not yet implemented");
        }
        public GetManifestResourceInfo(resourceName: string): ManifestResourceInfo {
            throw new Error("not yet implemented");
        }
        public GetManifestResourceNames(): string[] {
            throw new Error("not yet implemented");
        }
        public GetManifestResourceStream(name: string): Stream {
            throw new Error("not yet implemented");
        }
        public GetManifestResourceStream(type: Type, name: string): Stream {
            throw new Error("not yet implemented");
        }
        private static EnsureDynamicCodeSupported() {
            throw new Error("not yet implemented");
        }
        private static ForceAllowDynamicCode(): IDisposable {
            throw new Error("not yet implemented");
        }
        private static ThrowDynamicCodeNotSupported() {
            throw new Error("not yet implemented");
        }
    }
    export namespace AssemblyBuilder {
        export class ForceAllowDynamicCodeScope implements IDisposable {
            private _previous: boolean;

            public constructor() {
                throw new Error("not yet implemented");
            }

            public Dispose() {
                throw new Error("not yet implemented");
            }
        }
    }
    export class RuntimeAssemblyBuilder extends AssemblyBuilder implements ICustomAttributeProvider, ISerializable {
        private static readonly s_assemblyBuilderLock: any;

        private _access: AssemblyBuilderAccess;
        private _internalAssembly: RuntimeAssembly;
        private _manifestModuleBuilder: RuntimeModuleBuilder;
        private _isManifestModuleUsedAsDefinedModule: boolean;

        private get SyncRoot(): any {
            throw new Error("not yet implemented");
        }
        private get InternalAssembly(): RuntimeAssembly {
            throw new Error("not yet implemented");
        }
        public get FullName(): string {
            throw new Error("not yet implemented");
        }
        public get ManifestModule(): Module {
            throw new Error("not yet implemented");
        }
        public get ReflectionOnly(): boolean {
            throw new Error("not yet implemented");
        }
        public get HostContext(): number {
            throw new Error("not yet implemented");
        }
        public get IsCollectible(): boolean {
            throw new Error("not yet implemented");
        }

        protected constructor(name: AssemblyName, access: AssemblyBuilderAccess, assemblyLoadContext: AssemblyLoadContext, assemblyAttributes: IEnumerable<CustomAttributeBuilder>) {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

        private static CreateDynamicAssembly(assemblyLoadContext: ObjectHandleOnStack, pAssemblyName: NativeAssemblyNameParts*, hashAlgId: AssemblyHashAlgorithm, access: AssemblyBuilderAccess, retAssembly: ObjectHandleOnStack) {
            throw new Error("not yet implemented");
        }
        private static CreateDynamicAssembly(assemblyLoadContext: AssemblyLoadContext, name: AssemblyName, access: AssemblyBuilderAccess): RuntimeAssembly {
            throw new Error("not yet implemented");
        }
        private static InternalDefineDynamicAssembly(name: AssemblyName, access: AssemblyBuilderAccess, assemblyLoadContext: AssemblyLoadContext, assemblyAttributes: IEnumerable<CustomAttributeBuilder>): RuntimeAssemblyBuilder {
            throw new Error("not yet implemented");
        }
        private DefineDynamicModuleCore(name: string): ModuleBuilder {
            throw new Error("not yet implemented");
        }
        private CheckTypeNameConflict(strTypeName: string, enclosingType: TypeBuilder) {
            throw new Error("not yet implemented");
        }
        public GetCustomAttributes(inherit: boolean): any[] {
            throw new Error("not yet implemented");
        }
        public GetCustomAttributes(attributeType: Type, inherit: boolean): any[] {
            throw new Error("not yet implemented");
        }
        public IsDefined(attributeType: Type, inherit: boolean): boolean {
            throw new Error("not yet implemented");
        }
        public GetCustomAttributesData(): IList<CustomAttributeData> {
            throw new Error("not yet implemented");
        }
        public GetName(copiedName: boolean): AssemblyName {
            throw new Error("not yet implemented");
        }
        public GetType(name: string, throwOnError: boolean, ignoreCase: boolean): Type {
            throw new Error("not yet implemented");
        }
        public GetModule(name: string): Module {
            throw new Error("not yet implemented");
        }
        public GetReferencedAssemblies(): AssemblyName[] {
            throw new Error("not yet implemented");
        }
        public GetModules(getResourceModules: boolean): Module[] {
            throw new Error("not yet implemented");
        }
        public GetLoadedModules(getResourceModules: boolean): Module[] {
            throw new Error("not yet implemented");
        }
        public GetSatelliteAssembly(culture: CultureInfo): Assembly {
            throw new Error("not yet implemented");
        }
        public GetSatelliteAssembly(culture: CultureInfo, version: Version): Assembly {
            throw new Error("not yet implemented");
        }
        private GetDynamicModuleCore(name: string): ModuleBuilder {
            throw new Error("not yet implemented");
        }
        private SetCustomAttributeCore(con: ConstructorInfo, binaryAttribute: ReadOnlySpan<number>) {
            throw new Error("not yet implemented");
        }
    }
    export class RuntimeModuleBuilder extends ModuleBuilder implements ICustomAttributeProvider, ISerializable {
        private _typeBuilderDict: Dictionary<string, Type>;
        private _globalTypeBuilder: TypeBuilder;
        private _hasGlobalBeenCreated: boolean;
        private _internalModule: RuntimeModule;
        private _assemblyBuilder: RuntimeAssemblyBuilder;

        private get ContainingAssemblyBuilder(): RuntimeAssemblyBuilder {
            throw new Error("not yet implemented");
        }
        private get SyncRoot(): any {
            throw new Error("not yet implemented");
        }
        private get InternalModule(): RuntimeModule {
            throw new Error("not yet implemented");
        }
        public get FullyQualifiedName(): string {
            throw new Error("not yet implemented");
        }
        public get MDStreamVersion(): number {
            throw new Error("not yet implemented");
        }
        public get ModuleVersionId(): Guid {
            throw new Error("not yet implemented");
        }
        public get MetadataToken(): number {
            throw new Error("not yet implemented");
        }
        public get ScopeName(): string {
            throw new Error("not yet implemented");
        }
        public get Name(): string {
            throw new Error("not yet implemented");
        }
        public get Assembly(): Assembly {
            throw new Error("not yet implemented");
        }

        protected constructor(assemblyBuilder: RuntimeAssemblyBuilder, internalModule: RuntimeModule) {
            throw new Error("not yet implemented");
        }

        private static UnmangleTypeName(typeName: string): string {
            throw new Error("not yet implemented");
        }
        private AddType(name: string, type: Type) {
            throw new Error("not yet implemented");
        }
        private CheckTypeNameConflict(strTypeName: string, enclosingType: Type) {
            throw new Error("not yet implemented");
        }
        private static GetType(strFormat: string, baseType: Type): Type {
            throw new Error("not yet implemented");
        }
        private static GetTypeRef(module: QCallModule, strFullName: string, refedModule: QCallModule, tkResolution: number): number {
            throw new Error("not yet implemented");
        }
        private static GetMemberRef(module: QCallModule, refedModule: QCallModule, tr: number, defToken: number): number {
            throw new Error("not yet implemented");
        }
        private GetMemberRef(refedModule: Module, tr: number, defToken: number): number {
            throw new Error("not yet implemented");
        }
        private static GetMemberRefFromSignature(module: QCallModule, tr: number, methodName: string, signature: number[], length: number): number {
            throw new Error("not yet implemented");
        }
        private GetMemberRefFromSignature(tr: number, methodName: string, signature: number[], length: number): number {
            throw new Error("not yet implemented");
        }
        private static GetMemberRefOfMethodInfo(module: QCallModule, tr: number, method: RuntimeMethodHandleInternal): number {
            throw new Error("not yet implemented");
        }
        private GetMemberRefOfMethodInfo(tr: number, method: RuntimeMethodInfo): number {
            throw new Error("not yet implemented");
        }
        private GetMemberRefOfMethodInfo(tr: number, method: RuntimeConstructorInfo): number {
            throw new Error("not yet implemented");
        }
        private static GetMemberRefOfFieldInfo(module: QCallModule, tkType: number, declaringType: QCallTypeHandle, tkField: number): number {
            throw new Error("not yet implemented");
        }
        private GetMemberRefOfFieldInfo(tkType: number, declaringType: RuntimeTypeHandle, runtimeField: RuntimeFieldInfo): number {
            throw new Error("not yet implemented");
        }
        private static GetTokenFromTypeSpec(pModule: QCallModule, signature: number[], length: number): number {
            throw new Error("not yet implemented");
        }
        private GetTokenFromTypeSpec(signature: number[], length: number): number {
            throw new Error("not yet implemented");
        }
        private static GetArrayMethodToken(module: QCallModule, tkTypeSpec: number, methodName: string, signature: number[], sigLength: number): number {
            throw new Error("not yet implemented");
        }
        private static GetStringConstant(module: QCallModule, str: string, length: number): number {
            throw new Error("not yet implemented");
        }
        private static SetFieldRVAContent(module: QCallModule, fdToken: number, data: number[], length: number) {
            throw new Error("not yet implemented");
        }
        private FindTypeBuilderWithName(strTypeName: string, ignoreCase: boolean): Type {
            throw new Error("not yet implemented");
        }
        private GetTypeRefNested(type: Type, refedModule: Module): number {
            throw new Error("not yet implemented");
        }
        public GetMethodMetadataToken(constructor: ConstructorInfo): number {
            throw new Error("not yet implemented");
        }
        private GetModuleHandleImpl(): ModuleHandle {
            throw new Error("not yet implemented");
        }
        private static GetRuntimeModuleFromModule(m: Module): RuntimeModule {
            throw new Error("not yet implemented");
        }
        private GetMemberRefToken(method: MethodBase, optionalParameterTypes: Type[]): number {
            throw new Error("not yet implemented");
        }
        private GetMemberRefSignature(call: CallingConventions, returnType: Type, parameterTypes: Type[], requiredCustomModifiers: Type[][], optionalCustomModifiers: Type[][], optionalParameterTypes: Type[], cGenericParameters: number): SignatureHelper {
            throw new Error("not yet implemented");
        }
        private static GetGenericMethodBaseDefinition(methodBase: MethodBase): MethodBase {
            throw new Error("not yet implemented");
        }
        private GetMemberRefSignature(method: MethodBase, cGenericParameters: number): SignatureHelper {
            throw new Error("not yet implemented");
        }
        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public GetCustomAttributes(inherit: boolean): any[] {
            throw new Error("not yet implemented");
        }
        public GetCustomAttributes(attributeType: Type, inherit: boolean): any[] {
            throw new Error("not yet implemented");
        }
        public IsDefined(attributeType: Type, inherit: boolean): boolean {
            throw new Error("not yet implemented");
        }
        public GetCustomAttributesData(): IList<CustomAttributeData> {
            throw new Error("not yet implemented");
        }
        public GetTypes(): Type[] {
            throw new Error("not yet implemented");
        }
        private GetTypesNoLock(): Type[] {
            throw new Error("not yet implemented");
        }
        public GetType(className: string): Type {
            throw new Error("not yet implemented");
        }
        public GetType(className: string, ignoreCase: boolean): Type {
            throw new Error("not yet implemented");
        }
        public GetType(className: string, throwOnError: boolean, ignoreCase: boolean): Type {
            throw new Error("not yet implemented");
        }
        private GetTypeNoLock(className: string, throwOnError: boolean, ignoreCase: boolean): Type {
            throw new Error("not yet implemented");
        }
        public ResolveSignature(metadataToken: number): number[] {
            throw new Error("not yet implemented");
        }
        public ResolveMethod(metadataToken: number, genericTypeArguments: Type[], genericMethodArguments: Type[]): MethodBase {
            throw new Error("not yet implemented");
        }
        public ResolveField(metadataToken: number, genericTypeArguments: Type[], genericMethodArguments: Type[]): FieldInfo {
            throw new Error("not yet implemented");
        }
        public ResolveType(metadataToken: number, genericTypeArguments: Type[], genericMethodArguments: Type[]): Type {
            throw new Error("not yet implemented");
        }
        public ResolveMember(metadataToken: number, genericTypeArguments: Type[], genericMethodArguments: Type[]): MemberInfo {
            throw new Error("not yet implemented");
        }
        public ResolveString(metadataToken: number): string {
            throw new Error("not yet implemented");
        }
        public GetPEKind(out peKind: PortableExecutableKinds, out machine: ImageFileMachine) {
            throw new Error("not yet implemented");
        }
        public IsResource(): boolean {
            throw new Error("not yet implemented");
        }
        public GetFields(bindingFlags: BindingFlags): FieldInfo[] {
            throw new Error("not yet implemented");
        }
        public GetField(name: string, bindingAttr: BindingFlags): FieldInfo {
            throw new Error("not yet implemented");
        }
        public GetMethods(bindingFlags: BindingFlags): MethodInfo[] {
            throw new Error("not yet implemented");
        }
        private GetMethodImpl(name: string, bindingAttr: BindingFlags, binder: Binder, callConvention: CallingConventions, types: Type[], modifiers: ParameterModifier[]): MethodInfo {
            throw new Error("not yet implemented");
        }
        private DefineTypeCore(name: string, attr: TypeAttributes, parent: Type, interfaces: Type[], packingSize: PackingSize, typesize: number): TypeBuilder {
            throw new Error("not yet implemented");
        }
        private DefineEnumCore(name: string, visibility: TypeAttributes, underlyingType: Type): EnumBuilder {
            throw new Error("not yet implemented");
        }
        private DefinePInvokeMethodCore(name: string, dllName: string, entryName: string, attributes: MethodAttributes, callingConvention: CallingConventions, returnType: Type, parameterTypes: Type[], nativeCallConv: CallingConvention, nativeCharSet: CharSet): MethodBuilder {
            throw new Error("not yet implemented");
        }
        private DefineGlobalMethodCore(name: string, attributes: MethodAttributes, callingConvention: CallingConventions, returnType: Type, requiredReturnTypeCustomModifiers: Type[], optionalReturnTypeCustomModifiers: Type[], parameterTypes: Type[], requiredParameterTypeCustomModifiers: Type[][], optionalParameterTypeCustomModifiers: Type[][]): MethodBuilder {
            throw new Error("not yet implemented");
        }
        private DefineGlobalMethodNoLock(name: string, attributes: MethodAttributes, callingConvention: CallingConventions, returnType: Type, requiredReturnTypeCustomModifiers: Type[], optionalReturnTypeCustomModifiers: Type[], parameterTypes: Type[], requiredParameterTypeCustomModifiers: Type[][], optionalParameterTypeCustomModifiers: Type[][]): MethodBuilder {
            throw new Error("not yet implemented");
        }
        private CreateGlobalFunctionsCore() {
            throw new Error("not yet implemented");
        }
        private DefineInitializedDataCore(name: string, data: number[], attributes: FieldAttributes): FieldBuilder {
            throw new Error("not yet implemented");
        }
        private DefineUninitializedDataCore(name: string, size: number, attributes: FieldAttributes): FieldBuilder {
            throw new Error("not yet implemented");
        }
        private GetTypeTokenInternal(type: Type, getGenericDefinition: boolean): number {
            throw new Error("not yet implemented");
        }
        public GetTypeMetadataToken(type: Type): number {
            throw new Error("not yet implemented");
        }
        private GetTypeTokenWorkerNoLock(type: Type, getGenericDefinition: boolean): number {
            throw new Error("not yet implemented");
        }
        public GetMethodMetadataToken(method: MethodInfo): number {
            throw new Error("not yet implemented");
        }
        private GetMethodTokenNoLock(method: MethodInfo, getGenericTypeDefinition: boolean): number {
            throw new Error("not yet implemented");
        }
        private GetMethodTokenInternal(method: MethodBase, optionalParameterTypes: Type[], useMethodDef: boolean): number {
            throw new Error("not yet implemented");
        }
        private GetArrayMethodToken(arrayClass: Type, methodName: string, callingConvention: CallingConventions, returnType: Type, parameterTypes: Type[]): number {
            throw new Error("not yet implemented");
        }
        private GetArrayMethodTokenNoLock(arrayClass: Type, methodName: string, callingConvention: CallingConventions, returnType: Type, parameterTypes: Type[]): number {
            throw new Error("not yet implemented");
        }
        private GetArrayMethodCore(arrayClass: Type, methodName: string, callingConvention: CallingConventions, returnType: Type, parameterTypes: Type[]): MethodInfo {
            throw new Error("not yet implemented");
        }
        public GetFieldMetadataToken(field: FieldInfo): number {
            throw new Error("not yet implemented");
        }
        private GetFieldTokenNoLock(field: FieldInfo): number {
            throw new Error("not yet implemented");
        }
        public GetStringMetadataToken(stringConstant: string): number {
            throw new Error("not yet implemented");
        }
        public GetSignatureMetadataToken(signature: SignatureHelper): number {
            throw new Error("not yet implemented");
        }
        private SetCustomAttributeCore(con: ConstructorInfo, binaryAttribute: ReadOnlySpan<number>) {
            throw new Error("not yet implemented");
        }
        private static __GetTypeRef__g____PInvoke_13_0(__module_native: QCallModule, __strFullName_native: number*, __refedModule_native: QCallModule, __tkResolution_native: number): number {
            throw new Error("not yet implemented");
        }
        private static __GetMemberRefFromSignature__g____PInvoke_16_0(__module_native: QCallModule, __tr_native: number, __methodName_native: number*, __signature_native: number*, __length_native: number): number {
            throw new Error("not yet implemented");
        }
        private static __GetTokenFromTypeSpec__g____PInvoke_23_0(__pModule_native: QCallModule, __signature_native: number*, __length_native: number): number {
            throw new Error("not yet implemented");
        }
        private static __GetArrayMethodToken__g____PInvoke_25_0(__module_native: QCallModule, __tkTypeSpec_native: number, __methodName_native: number*, __signature_native: number*, __sigLength_native: number): number {
            throw new Error("not yet implemented");
        }
        private static __GetStringConstant__g____PInvoke_26_0(__module_native: QCallModule, __str_native: number*, __length_native: number): number {
            throw new Error("not yet implemented");
        }
        private static __SetFieldRVAContent__g____PInvoke_27_0(__module_native: QCallModule, __fdToken_native: number, __data_native: number*, __length_native: number) {
            throw new Error("not yet implemented");
        }
    }
}
export namespace System.Runtime {
    export class DependentHandle extends ValueType implements IDisposable {
        private _handle: number;

        public get IsAllocated(): boolean {
            throw new Error("not yet implemented");
        }
        public get Target(): any {
            throw new Error("not yet implemented");
        }
        public set Target(value: any) {
            throw new Error("not yet implemented");
        }
        public get Dependent(): any {
            throw new Error("not yet implemented");
        }
        public set Dependent(value: any) {
            throw new Error("not yet implemented");
        }
        public get TargetAndDependent(): ValueTuple<any, any> {
            throw new Error("not yet implemented");
        }

        public constructor(target: any, dependent: any) {
            throw new Error("not yet implemented");
        }

        private UnsafeGetTarget(): any {
            throw new Error("not yet implemented");
        }
        private UnsafeGetTargetAndDependent(out dependent: any): any {
            throw new Error("not yet implemented");
        }
        private UnsafeSetTargetToNull() {
            throw new Error("not yet implemented");
        }
        private UnsafeSetDependent(dependent: any) {
            throw new Error("not yet implemented");
        }
        public Dispose() {
            throw new Error("not yet implemented");
        }
        private static InternalInitialize(target: any, dependent: any): number {
            throw new Error("not yet implemented");
        }
        private static InternalGetTarget(dependentHandle: number): any {
            throw new Error("not yet implemented");
        }
        private static InternalGetDependent(dependentHandle: number): any {
            throw new Error("not yet implemented");
        }
        private static InternalGetTargetAndDependent(dependentHandle: number, out dependent: any): any {
            throw new Error("not yet implemented");
        }
        private static InternalSetDependent(dependentHandle: number, dependent: any) {
            throw new Error("not yet implemented");
        }
        private static InternalSetTargetToNull(dependentHandle: number) {
            throw new Error("not yet implemented");
        }
        private static InternalFree(dependentHandle: number) {
            throw new Error("not yet implemented");
        }
    }
}
export namespace System.Runtime.CompilerServices {
    export class ObjectHandleOnStack extends ValueType {
        private _ptr: void*;

        private constructor(pObject: void*) {
            throw new Error("not yet implemented");
        }

        private static Create(ref o: T): ObjectHandleOnStack {
            throw new Error("not yet implemented");
        }
    }
    export interface ITuple {
        get Length(): number;
        get Item(): any;

    }
    export class Entry extends ValueType {
        public depHnd: DependentHandle;
        public HashCode: number;
        public Next: number;

    }
    export class Container {
        private _parent: ConditionalWeakTable<TKey, TValue>;
        private _buckets: number[];
        private _entries: Entry[];
        private _firstFreeEntry: number;
        private _invalid: boolean;
        private _finalized: boolean;
        private _oldKeepAlive: any;

        private get HasCapacity(): boolean {
            throw new Error("not yet implemented");
        }
        private get FirstFreeEntry(): number {
            throw new Error("not yet implemented");
        }

        protected constructor(parent: ConditionalWeakTable<TKey, TValue>) {
            throw new Error("not yet implemented");
        }
        private constructor(parent: ConditionalWeakTable<TKey, TValue>, buckets: number[], entries: Entry[], firstFreeEntry: number) {
            throw new Error("not yet implemented");
        }

        private CreateEntryNoResize(key: TKey, value: TValue) {
            throw new Error("not yet implemented");
        }
        private TryGetValueWorker(key: TKey, out value: TValue): boolean {
            throw new Error("not yet implemented");
        }
        private FindEntry(key: TKey, out value: any): number {
            throw new Error("not yet implemented");
        }
        private TryGetEntry(index: number, out key: TKey, out value: TValue): boolean {
            throw new Error("not yet implemented");
        }
        private RemoveAllKeys() {
            throw new Error("not yet implemented");
        }
        private Remove(key: TKey): boolean {
            throw new Error("not yet implemented");
        }
        private RemoveIndex(entryIndex: number) {
            throw new Error("not yet implemented");
        }
        private UpdateValue(entryIndex: number, newValue: TValue) {
            throw new Error("not yet implemented");
        }
        private Resize(): Container {
            throw new Error("not yet implemented");
        }
        private Resize(newSize: number): Container {
            throw new Error("not yet implemented");
        }
        private VerifyIntegrity() {
            throw new Error("not yet implemented");
        }
        private Finalize() {
            throw new Error("not yet implemented");
        }
    }
    export class CreateValueCallback extends MulticastDelegate implements ICloneable, ISerializable {
        public constructor(object: any, method: number) {
            throw new Error("not yet implemented");
        }

        public Invoke(key: TKey): TValue {
            throw new Error("not yet implemented");
        }
        public BeginInvoke(key: TKey, callback: AsyncCallback, object: any): IAsyncResult {
            throw new Error("not yet implemented");
        }
        public EndInvoke(result: IAsyncResult): TValue {
            throw new Error("not yet implemented");
        }
    }
    export class ConditionalWeakTable<TKey, TValue> implements IEnumerable<KeyValuePair<TKey, TValue>>, IEnumerable {
        private _lock: any;
        private _container: Container;
        private _activeEnumeratorRefCount: number;

        public constructor() {
            throw new Error("not yet implemented");
        }

        public TryGetValue(key: TKey, out value: TValue): boolean {
            throw new Error("not yet implemented");
        }
        public Add(key: TKey, value: TValue) {
            throw new Error("not yet implemented");
        }
        public TryAdd(key: TKey, value: TValue): boolean {
            throw new Error("not yet implemented");
        }
        public AddOrUpdate(key: TKey, value: TValue) {
            throw new Error("not yet implemented");
        }
        public Remove(key: TKey): boolean {
            throw new Error("not yet implemented");
        }
        public Clear() {
            throw new Error("not yet implemented");
        }
        public GetValue(key: TKey, createValueCallback: CreateValueCallback): TValue {
            throw new Error("not yet implemented");
        }
        private GetValueLocked(key: TKey, createValueCallback: CreateValueCallback): TValue {
            throw new Error("not yet implemented");
        }
        public GetOrCreateValue(key: TKey): TValue {
            throw new Error("not yet implemented");
        }
        private __explicit__KeyValuePair__TKey_TValue_____GetEnumerator(): IEnumerator<KeyValuePair<TKey, TValue>> {
            throw new Error("not yet implemented");
        }
        public GetEnumerator(): IEnumerator<KeyValuePair<TKey, TValue>> {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__IEnumerable_GetEnumerator(): IEnumerator {
            throw new Error("not yet implemented");
        }
        public GetEnumerator(): IEnumerator {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private CreateEntry(key: TKey, value: TValue) {
            throw new Error("not yet implemented");
        }
    }
    export namespace ConditionalWeakTable {
        export class CreateValueCallback extends MulticastDelegate implements ICloneable, ISerializable {
            public constructor(object: any, method: number) {
                throw new Error("not yet implemented");
            }

            public Invoke(key: TKey): TValue {
                throw new Error("not yet implemented");
            }
            public BeginInvoke(key: TKey, callback: AsyncCallback, object: any): IAsyncResult {
                throw new Error("not yet implemented");
            }
            public EndInvoke(result: IAsyncResult): TValue {
                throw new Error("not yet implemented");
            }
        }

        export class Enumerator implements IEnumerator<KeyValuePair<TKey, TValue>>, IDisposable, IEnumerator {
            private _table: ConditionalWeakTable<TKey, TValue>;
            private _maxIndexInclusive: number;
            private _currentIndex: number;
            private _current: KeyValuePair<TKey, TValue>;

            public get Current(): KeyValuePair<TKey, TValue> {
                throw new Error("not yet implemented");
            }
            private get __explicit__IEnumerator_Current(): any {
                throw new Error("not yet implemented");
            }

            public constructor(table: ConditionalWeakTable<TKey, TValue>) {
                throw new Error("not yet implemented");
            }

            private Finalize() {
                throw new Error("not yet implemented");
            }
            public Dispose() {
                throw new Error("not yet implemented");
            }
            public MoveNext(): boolean {
                throw new Error("not yet implemented");
            }
            public Reset() {
                throw new Error("not yet implemented");
            }

            public readonly ExplicitAsIEnumerator__KeyValuePair__TKey__TValue____: IEnumerator<KeyValuePair<TKey, TValue>> = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'Current') {
                        return target.__explicit__IEnumerator_Current;
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
            public readonly ExplicitAsIDisposable: IDisposable = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'Current') {
                        return target.__explicit__IEnumerator_Current;
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
            public readonly ExplicitAsIEnumerator: IEnumerator = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'Current') {
                        return target.__explicit__IEnumerator_Current;
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
        }

        export class Entry extends ValueType {
            public depHnd: DependentHandle;
            public HashCode: number;
            public Next: number;

        }

        export class Container {
            private _parent: ConditionalWeakTable<TKey, TValue>;
            private _buckets: number[];
            private _entries: Entry[];
            private _firstFreeEntry: number;
            private _invalid: boolean;
            private _finalized: boolean;
            private _oldKeepAlive: any;

            private get HasCapacity(): boolean {
                throw new Error("not yet implemented");
            }
            private get FirstFreeEntry(): number {
                throw new Error("not yet implemented");
            }

            protected constructor(parent: ConditionalWeakTable<TKey, TValue>) {
                throw new Error("not yet implemented");
            }
            private constructor(parent: ConditionalWeakTable<TKey, TValue>, buckets: number[], entries: Entry[], firstFreeEntry: number) {
                throw new Error("not yet implemented");
            }

            private CreateEntryNoResize(key: TKey, value: TValue) {
                throw new Error("not yet implemented");
            }
            private TryGetValueWorker(key: TKey, out value: TValue): boolean {
                throw new Error("not yet implemented");
            }
            private FindEntry(key: TKey, out value: any): number {
                throw new Error("not yet implemented");
            }
            private TryGetEntry(index: number, out key: TKey, out value: TValue): boolean {
                throw new Error("not yet implemented");
            }
            private RemoveAllKeys() {
                throw new Error("not yet implemented");
            }
            private Remove(key: TKey): boolean {
                throw new Error("not yet implemented");
            }
            private RemoveIndex(entryIndex: number) {
                throw new Error("not yet implemented");
            }
            private UpdateValue(entryIndex: number, newValue: TValue) {
                throw new Error("not yet implemented");
            }
            private Resize(): Container {
                throw new Error("not yet implemented");
            }
            private Resize(newSize: number): Container {
                throw new Error("not yet implemented");
            }
            private VerifyIntegrity() {
                throw new Error("not yet implemented");
            }
            private Finalize() {
                throw new Error("not yet implemented");
            }
        }

        export class ____c {
            public static readonly ____9: ____c;
            public static ____9__13_0: CreateValueCallback;

            private static staticctor_initialize = (() => {
                throw new Error("not yet implemented");
            })();
            private constructor() { }
            public constructor() {
                throw new Error("not yet implemented");
            }

            private __GetOrCreateValue__b__13_0(_: TKey): TValue {
                throw new Error("not yet implemented");
            }
        }
    }
    export class StringHandleOnStack extends ValueType {
        private _ptr: void*;

        protected constructor(s: string) {
            throw new Error("not yet implemented");
        }

    }
    export interface IStrongBox {
        get Value(): any;
        set Value(value: any);

    }
    export class StrongBox<T> implements IStrongBox {
        public Value: T;

        private get __explicit__IStrongBox_Value(): any {
            throw new Error("not yet implemented");
        }
        private set __explicit__IStrongBox_Value(value: any) {
            throw new Error("not yet implemented");
        }
        public get Value(): any {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        public set Value(value: any) {
            throw new Error("Invalid call (use ExplicitAs property)");
        }

        public constructor() {
            throw new Error("not yet implemented");
        }
        public constructor(value: T) {
            throw new Error("not yet implemented");
        }


        public readonly ExplicitAsIStrongBox: IStrongBox = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Value') {
                    return target.__explicit__IStrongBox_Value;
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
    }
    export interface INotifyCompletion {
        OnCompleted(continuation: Action): void;
    }
    export interface ICriticalNotifyCompletion implements INotifyCompletion {
        UnsafeOnCompleted(continuation: Action): void;
    }
    export interface ITaskAwaiter {
    }
    export class TaskAwaiter<TResult> extends ValueType implements ICriticalNotifyCompletion, INotifyCompletion, ITaskAwaiter {
        private m_task: Task<TResult>;

        public get IsCompleted(): boolean {
            throw new Error("not yet implemented");
        }

        protected constructor(task: Task<TResult>) {
            throw new Error("not yet implemented");
        }

        public OnCompleted(continuation: Action) {
            throw new Error("not yet implemented");
        }
        public UnsafeOnCompleted(continuation: Action) {
            throw new Error("not yet implemented");
        }
        public GetResult(): TResult {
            throw new Error("not yet implemented");
        }
    }
    export interface IConfiguredTaskAwaiter {
    }
    export class ConfiguredTaskAwaiter extends ValueType implements ICriticalNotifyCompletion, INotifyCompletion, IConfiguredTaskAwaiter {
        private m_task: Task<TResult>;
        private m_options: ConfigureAwaitOptions;

        public get IsCompleted(): boolean {
            throw new Error("not yet implemented");
        }

        protected constructor(task: Task<TResult>, options: ConfigureAwaitOptions) {
            throw new Error("not yet implemented");
        }

        public OnCompleted(continuation: Action) {
            throw new Error("not yet implemented");
        }
        public UnsafeOnCompleted(continuation: Action) {
            throw new Error("not yet implemented");
        }
        public GetResult(): TResult {
            throw new Error("not yet implemented");
        }
    }
    export class ConfiguredTaskAwaitable<TResult> extends ValueType {
        private m_configuredTaskAwaiter: ConfiguredTaskAwaiter;

        protected constructor(task: Task<TResult>, options: ConfigureAwaitOptions) {
            throw new Error("not yet implemented");
        }

        public GetAwaiter(): ConfiguredTaskAwaiter {
            throw new Error("not yet implemented");
        }
    }
    export namespace ConfiguredTaskAwaitable {
        export class ConfiguredTaskAwaiter extends ValueType implements ICriticalNotifyCompletion, INotifyCompletion, IConfiguredTaskAwaiter {
            private m_task: Task<TResult>;
            private m_options: ConfigureAwaitOptions;

            public get IsCompleted(): boolean {
                throw new Error("not yet implemented");
            }

            protected constructor(task: Task<TResult>, options: ConfigureAwaitOptions) {
                throw new Error("not yet implemented");
            }

            public OnCompleted(continuation: Action) {
                throw new Error("not yet implemented");
            }
            public UnsafeOnCompleted(continuation: Action) {
                throw new Error("not yet implemented");
            }
            public GetResult(): TResult {
                throw new Error("not yet implemented");
            }
        }
    }
    export interface IAsyncStateMachine {
        MoveNext(): void;
        SetStateMachine(stateMachine: IAsyncStateMachine): void;
    }
    export interface IAsyncStateMachineBox {
        get MoveNextAction(): Action;

        MoveNext(): void;
        GetStateMachineObject(): IAsyncStateMachine;
        ClearStateUponCompletion(): void;
    }
    export interface IStateMachineBoxAwareAwaiter {
        AwaitUnsafeOnCompleted(box: IAsyncStateMachineBox): void;
    }
    export class ValueTaskAwaiter<TResult> extends ValueType implements ICriticalNotifyCompletion, INotifyCompletion, IStateMachineBoxAwareAwaiter {
        private _value: ValueTask<TResult>;

        public get IsCompleted(): boolean {
            throw new Error("not yet implemented");
        }

        protected constructor(value: ValueTask<TResult>) {
            throw new Error("not yet implemented");
        }

        public GetResult(): TResult {
            throw new Error("not yet implemented");
        }
        public OnCompleted(continuation: Action) {
            throw new Error("not yet implemented");
        }
        public UnsafeOnCompleted(continuation: Action) {
            throw new Error("not yet implemented");
        }
        private __explicit__IStateMachineBoxAwareAwaiter_AwaitUnsafeOnCompleted(box: IAsyncStateMachineBox) {
            throw new Error("not yet implemented");
        }
        public AwaitUnsafeOnCompleted(box: IAsyncStateMachineBox) {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
    }
    export class ConfiguredValueTaskAwaiter extends ValueType implements ICriticalNotifyCompletion, INotifyCompletion, IStateMachineBoxAwareAwaiter {
        private _value: ValueTask<TResult>;

        public get IsCompleted(): boolean {
            throw new Error("not yet implemented");
        }

        protected constructor(value: ValueTask<TResult>) {
            throw new Error("not yet implemented");
        }

        public GetResult(): TResult {
            throw new Error("not yet implemented");
        }
        public OnCompleted(continuation: Action) {
            throw new Error("not yet implemented");
        }
        public UnsafeOnCompleted(continuation: Action) {
            throw new Error("not yet implemented");
        }
        private __explicit__IStateMachineBoxAwareAwaiter_AwaitUnsafeOnCompleted(box: IAsyncStateMachineBox) {
            throw new Error("not yet implemented");
        }
        public AwaitUnsafeOnCompleted(box: IAsyncStateMachineBox) {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
    }
    export class ConfiguredValueTaskAwaitable<TResult> extends ValueType {
        private _value: ValueTask<TResult>;

        protected constructor(value: ValueTask<TResult>) {
            throw new Error("not yet implemented");
        }

        public GetAwaiter(): ConfiguredValueTaskAwaiter {
            throw new Error("not yet implemented");
        }
    }
    export namespace ConfiguredValueTaskAwaitable {
        export class ConfiguredValueTaskAwaiter extends ValueType implements ICriticalNotifyCompletion, INotifyCompletion, IStateMachineBoxAwareAwaiter {
            private _value: ValueTask<TResult>;

            public get IsCompleted(): boolean {
                throw new Error("not yet implemented");
            }

            protected constructor(value: ValueTask<TResult>) {
                throw new Error("not yet implemented");
            }

            public GetResult(): TResult {
                throw new Error("not yet implemented");
            }
            public OnCompleted(continuation: Action) {
                throw new Error("not yet implemented");
            }
            public UnsafeOnCompleted(continuation: Action) {
                throw new Error("not yet implemented");
            }
            private __explicit__IStateMachineBoxAwareAwaiter_AwaitUnsafeOnCompleted(box: IAsyncStateMachineBox) {
                throw new Error("not yet implemented");
            }
            public AwaitUnsafeOnCompleted(box: IAsyncStateMachineBox) {
                throw new Error("Invalid call (use ExplicitAs property)");
            }
        }
    }
    export class TaskAwaiter extends ValueType implements ICriticalNotifyCompletion, INotifyCompletion, ITaskAwaiter {
        private m_task: Task;

        public get IsCompleted(): boolean {
            throw new Error("not yet implemented");
        }

        protected constructor(task: Task) {
            throw new Error("not yet implemented");
        }

        public OnCompleted(continuation: Action) {
            throw new Error("not yet implemented");
        }
        public UnsafeOnCompleted(continuation: Action) {
            throw new Error("not yet implemented");
        }
        public GetResult() {
            throw new Error("not yet implemented");
        }
        private static ValidateEnd(task: Task, options: ConfigureAwaitOptions) {
            throw new Error("not yet implemented");
        }
        private static HandleNonSuccessAndDebuggerNotification(task: Task, options: ConfigureAwaitOptions) {
            throw new Error("not yet implemented");
        }
        private static ThrowForNonSuccess(task: Task) {
            throw new Error("not yet implemented");
        }
        private static OnCompletedInternal(task: Task, continuation: Action, continueOnCapturedContext: boolean, flowExecutionContext: boolean) {
            throw new Error("not yet implemented");
        }
        private static UnsafeOnCompletedInternal(task: Task, stateMachineBox: IAsyncStateMachineBox, continueOnCapturedContext: boolean) {
            throw new Error("not yet implemented");
        }
        private static OutputWaitEtwEvents(task: Task, continuation: Action): Action {
            throw new Error("not yet implemented");
        }
    }
    export namespace TaskAwaiter {
        export class ____c {
            public static readonly ____9: ____c;
            public static ____9__12_0: Action<Action, Task>;

            private static staticctor_initialize = (() => {
                throw new Error("not yet implemented");
            })();
            private constructor() { }
            public constructor() {
                throw new Error("not yet implemented");
            }

            private __OutputWaitEtwEvents__b__12_0(innerContinuation: Action, innerTask: Task) {
                throw new Error("not yet implemented");
            }
        }
    }
    export class ConfiguredTaskAwaitable extends ValueType {
        private m_configuredTaskAwaiter: ConfiguredTaskAwaiter;

        protected constructor(task: Task, options: ConfigureAwaitOptions) {
            throw new Error("not yet implemented");
        }

        public GetAwaiter(): ConfiguredTaskAwaiter {
            throw new Error("not yet implemented");
        }
    }
    export namespace ConfiguredTaskAwaitable {
        export class ConfiguredTaskAwaiter extends ValueType implements ICriticalNotifyCompletion, INotifyCompletion, IConfiguredTaskAwaiter {
            private m_task: Task;
            private m_options: ConfigureAwaitOptions;

            public get IsCompleted(): boolean {
                throw new Error("not yet implemented");
            }

            protected constructor(task: Task, options: ConfigureAwaitOptions) {
                throw new Error("not yet implemented");
            }

            public OnCompleted(continuation: Action) {
                throw new Error("not yet implemented");
            }
            public UnsafeOnCompleted(continuation: Action) {
                throw new Error("not yet implemented");
            }
            public GetResult() {
                throw new Error("not yet implemented");
            }
        }
    }
    export class YieldAwaiter extends ValueType implements ICriticalNotifyCompletion, INotifyCompletion, IStateMachineBoxAwareAwaiter {
        private static readonly s_waitCallbackRunAction: WaitCallback;
        private static readonly s_sendOrPostCallbackRunAction: SendOrPostCallback;

        public get IsCompleted(): boolean {
            throw new Error("not yet implemented");
        }

        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

        public OnCompleted(continuation: Action) {
            throw new Error("not yet implemented");
        }
        public UnsafeOnCompleted(continuation: Action) {
            throw new Error("not yet implemented");
        }
        private static QueueContinuation(continuation: Action, flowContext: boolean) {
            throw new Error("not yet implemented");
        }
        private __explicit__IStateMachineBoxAwareAwaiter_AwaitUnsafeOnCompleted(box: IAsyncStateMachineBox) {
            throw new Error("not yet implemented");
        }
        public AwaitUnsafeOnCompleted(box: IAsyncStateMachineBox) {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private static OutputCorrelationEtwEvent(continuation: Action): Action {
            throw new Error("not yet implemented");
        }
        private static RunAction(state: any) {
            throw new Error("not yet implemented");
        }
        public GetResult() {
            throw new Error("not yet implemented");
        }
    }
    export namespace YieldAwaiter {
        export class ____c {
            public static readonly ____9: ____c;
            public static ____9__5_0: SendOrPostCallback;
            public static ____9__5_1: Action<any>;
            public static ____9__6_0: Action<Action, Task>;

            private static staticctor_initialize = (() => {
                throw new Error("not yet implemented");
            })();
            private constructor() { }
            public constructor() {
                throw new Error("not yet implemented");
            }

            private __System_Runtime_CompilerServices_IStateMachineBoxAwareAwaiter_AwaitUnsafeOnCompleted__b__5_0(s: any) {
                throw new Error("not yet implemented");
            }
            private __System_Runtime_CompilerServices_IStateMachineBoxAwareAwaiter_AwaitUnsafeOnCompleted__b__5_1(s: any) {
                throw new Error("not yet implemented");
            }
            private __OutputCorrelationEtwEvent__b__6_0(innerContinuation: Action, continuationIdTask: Task) {
                throw new Error("not yet implemented");
            }
        }
    }
    export class YieldAwaitable extends ValueType {
        public GetAwaiter(): YieldAwaiter {
            throw new Error("not yet implemented");
        }
    }
    export namespace YieldAwaitable {
        export class YieldAwaiter extends ValueType implements ICriticalNotifyCompletion, INotifyCompletion, IStateMachineBoxAwareAwaiter {
            private static readonly s_waitCallbackRunAction: WaitCallback;
            private static readonly s_sendOrPostCallbackRunAction: SendOrPostCallback;

            public get IsCompleted(): boolean {
                throw new Error("not yet implemented");
            }

            private static staticctor_initialize = (() => {
                throw new Error("not yet implemented");
            })();
            private constructor() { }

            public OnCompleted(continuation: Action) {
                throw new Error("not yet implemented");
            }
            public UnsafeOnCompleted(continuation: Action) {
                throw new Error("not yet implemented");
            }
            private static QueueContinuation(continuation: Action, flowContext: boolean) {
                throw new Error("not yet implemented");
            }
            private __explicit__IStateMachineBoxAwareAwaiter_AwaitUnsafeOnCompleted(box: IAsyncStateMachineBox) {
                throw new Error("not yet implemented");
            }
            public AwaitUnsafeOnCompleted(box: IAsyncStateMachineBox) {
                throw new Error("Invalid call (use ExplicitAs property)");
            }
            private static OutputCorrelationEtwEvent(continuation: Action): Action {
                throw new Error("not yet implemented");
            }
            private static RunAction(state: any) {
                throw new Error("not yet implemented");
            }
            public GetResult() {
                throw new Error("not yet implemented");
            }
        }
        export namespace YieldAwaiter {
            export class ____c {
                public static readonly ____9: ____c;
                public static ____9__5_0: SendOrPostCallback;
                public static ____9__5_1: Action<any>;
                public static ____9__6_0: Action<Action, Task>;

                private static staticctor_initialize = (() => {
                    throw new Error("not yet implemented");
                })();
                private constructor() { }
                public constructor() {
                    throw new Error("not yet implemented");
                }

                private __System_Runtime_CompilerServices_IStateMachineBoxAwareAwaiter_AwaitUnsafeOnCompleted__b__5_0(s: any) {
                    throw new Error("not yet implemented");
                }
                private __System_Runtime_CompilerServices_IStateMachineBoxAwareAwaiter_AwaitUnsafeOnCompleted__b__5_1(s: any) {
                    throw new Error("not yet implemented");
                }
                private __OutputCorrelationEtwEvent__b__6_0(innerContinuation: Action, continuationIdTask: Task) {
                    throw new Error("not yet implemented");
                }
            }
        }
    }
    export class ValueTaskAwaiter extends ValueType implements ICriticalNotifyCompletion, INotifyCompletion, IStateMachineBoxAwareAwaiter {
        private static readonly s_invokeActionDelegate: Action<any>;

        private _value: ValueTask;

        public get IsCompleted(): boolean {
            throw new Error("not yet implemented");
        }

        protected constructor(value: ValueTask) {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

        public GetResult() {
            throw new Error("not yet implemented");
        }
        public OnCompleted(continuation: Action) {
            throw new Error("not yet implemented");
        }
        public UnsafeOnCompleted(continuation: Action) {
            throw new Error("not yet implemented");
        }
        private __explicit__IStateMachineBoxAwareAwaiter_AwaitUnsafeOnCompleted(box: IAsyncStateMachineBox) {
            throw new Error("not yet implemented");
        }
        public AwaitUnsafeOnCompleted(box: IAsyncStateMachineBox) {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
    }
    export namespace ValueTaskAwaiter {
        export class ____c {
            public static readonly ____9: ____c;

            private static staticctor_initialize = (() => {
                throw new Error("not yet implemented");
            })();
            private constructor() { }
            public constructor() {
                throw new Error("not yet implemented");
            }

            private ___cctor__b__10_0(state: any) {
                throw new Error("not yet implemented");
            }
        }
    }
    export class ConfiguredValueTaskAwaitable extends ValueType {
        private _value: ValueTask;

        protected constructor(value: ValueTask) {
            throw new Error("not yet implemented");
        }

        public GetAwaiter(): ConfiguredValueTaskAwaiter {
            throw new Error("not yet implemented");
        }
    }
    export namespace ConfiguredValueTaskAwaitable {
        export class ConfiguredValueTaskAwaiter extends ValueType implements ICriticalNotifyCompletion, INotifyCompletion, IStateMachineBoxAwareAwaiter {
            private _value: ValueTask;

            public get IsCompleted(): boolean {
                throw new Error("not yet implemented");
            }

            protected constructor(value: ValueTask) {
                throw new Error("not yet implemented");
            }

            public GetResult() {
                throw new Error("not yet implemented");
            }
            public OnCompleted(continuation: Action) {
                throw new Error("not yet implemented");
            }
            public UnsafeOnCompleted(continuation: Action) {
                throw new Error("not yet implemented");
            }
            private __explicit__IStateMachineBoxAwareAwaiter_AwaitUnsafeOnCompleted(box: IAsyncStateMachineBox) {
                throw new Error("not yet implemented");
            }
            public AwaitUnsafeOnCompleted(box: IAsyncStateMachineBox) {
                throw new Error("Invalid call (use ExplicitAs property)");
            }
        }
    }
    export class QCallAssembly extends ValueType {
        private _ptr: void*;
        private _assembly: number;

        protected constructor(assembly: RuntimeAssembly) {
            throw new Error("not yet implemented");
        }

    }
    export class QCallModule extends ValueType {
        private _ptr: void*;
        private _module: number;

        protected constructor(module: RuntimeModule) {
            throw new Error("not yet implemented");
        }
        protected constructor(module: RuntimeModuleBuilder) {
            throw new Error("not yet implemented");
        }

    }
    export class StackCrawlMarkHandle extends ValueType {
        private _ptr: void*;

        protected constructor(stackMark: StackCrawlMark) {
            throw new Error("not yet implemented");
        }

    }
    export class QCallTypeHandle extends ValueType {
        private _ptr: void*;
        private _handle: number;

        protected constructor(type: RuntimeType) {
            throw new Error("not yet implemented");
        }
        protected constructor(rth: RuntimeTypeHandle) {
            throw new Error("not yet implemented");
        }

    }
    export class MethodTable extends ValueType {
        public ComponentSize: number;
        private Flags: number;
        public BaseSize: number;
        public InterfaceCount: number;
        public ParentMethodTable: MethodTable*;
        public ElementType: void*;
        public InterfaceMap: MethodTable**;

        public get HasComponentSize(): boolean {
            throw new Error("not yet implemented");
        }
        public get ContainsGCPointers(): boolean {
            throw new Error("not yet implemented");
        }
        public get NonTrivialInterfaceCast(): boolean {
            throw new Error("not yet implemented");
        }
        public get HasTypeEquivalence(): boolean {
            throw new Error("not yet implemented");
        }
        public get HasDefaultConstructor(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsMultiDimensionalArray(): boolean {
            throw new Error("not yet implemented");
        }
        public get MultiDimensionalArrayRank(): number {
            throw new Error("not yet implemented");
        }
        public get IsValueType(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsNullable(): boolean {
            throw new Error("not yet implemented");
        }
        public get HasInstantiation(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsGenericTypeDefinition(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsConstructedGenericType(): boolean {
            throw new Error("not yet implemented");
        }

        private static AreSameType(mt1: MethodTable*, mt2: MethodTable*): boolean {
            throw new Error("not yet implemented");
        }
        public GetArrayElementTypeHandle(): TypeHandle {
            throw new Error("not yet implemented");
        }
        public GetNumInstanceFieldBytes(): number {
            throw new Error("not yet implemented");
        }
    }
    export class TypeHandle extends ValueType {
        private m_asTAddr: void*;

        public get IsNull(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsTypeDesc(): boolean {
            throw new Error("not yet implemented");
        }

        public constructor(tAddr: void*) {
            throw new Error("not yet implemented");
        }

        public AsMethodTable(): MethodTable* {
            throw new Error("not yet implemented");
        }
        public static TypeHandleOf(): TypeHandle {
            throw new Error("not yet implemented");
        }
    }
}
export namespace System.Runtime.ConstrainedExecution {
    export abstract class CriticalFinalizerObject {
        protected constructor() {
            throw new Error("not yet implemented");
        }

        private Finalize() {
            throw new Error("not yet implemented");
        }
    }
}
export namespace System.Runtime.ExceptionServices {
    export class ExceptionDispatchInfo {
        private _exception: Exception;
        private _dispatchState: DispatchState;

        public get SourceException(): Exception {
            throw new Error("not yet implemented");
        }

        private constructor(exception: Exception) {
            throw new Error("not yet implemented");
        }

        public static Capture(source: Exception): ExceptionDispatchInfo {
            throw new Error("not yet implemented");
        }
        public Throw() {
            throw new Error("not yet implemented");
        }
        public static Throw(source: Exception) {
            throw new Error("not yet implemented");
        }
        public static SetCurrentStackTrace(source: Exception): Exception {
            throw new Error("not yet implemented");
        }
        public static SetRemoteStackTrace(source: Exception, stackTrace: string): Exception {
            throw new Error("not yet implemented");
        }
    }
}
export namespace System.Runtime.InteropServices {
    export abstract class SafeHandle extends CriticalFinalizerObject implements IDisposable {
        private handle: number;
        private _state: number;
        private _ownsHandle: boolean;
        private _fullyInitialized: boolean;

        private get OwnsHandle(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsClosed(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsInvalid(): boolean;

        protected constructor(invalidHandleValue: number, ownsHandle: boolean) {
            throw new Error("not yet implemented");
        }

        private Finalize() {
            throw new Error("not yet implemented");
        }
        private SetHandle(handle: number) {
            throw new Error("not yet implemented");
        }
        public DangerousGetHandle(): number {
            throw new Error("not yet implemented");
        }
        public Close() {
            throw new Error("not yet implemented");
        }
        public Dispose() {
            throw new Error("not yet implemented");
        }
        private Dispose(disposing: boolean) {
            throw new Error("not yet implemented");
        }
        public SetHandleAsInvalid() {
            throw new Error("not yet implemented");
        }
        private ReleaseHandle(): boolean;
        public DangerousAddRef(ref success: boolean) {
            throw new Error("not yet implemented");
        }
        private DangerousAddRef() {
            throw new Error("not yet implemented");
        }
        public DangerousRelease() {
            throw new Error("not yet implemented");
        }
        private InternalRelease(disposeOrFinalizeOperation: boolean) {
            throw new Error("not yet implemented");
        }
    }
    export enum UnmanagedType {
        Bool = 2,
        I1 = 3,
        U1 = 4,
        I2 = 5,
        U2 = 6,
        I4 = 7,
        U4 = 8,
        I8 = 9,
        U8 = 10,
        R4 = 11,
        R8 = 12,
        Currency = 15,
        BStr = 19,
        LPStr = 20,
        LPWStr = 21,
        LPTStr = 22,
        ByValTStr = 23,
        IUnknown = 25,
        IDispatch = 26,
        Struct = 27,
        Interface = 28,
        SafeArray = 29,
        ByValArray = 30,
        SysInt = 31,
        SysUInt = 32,
        VBByRefStr = 34,
        AnsiBStr = 35,
        TBStr = 36,
        VariantBool = 37,
        FunctionPtr = 38,
        AsAny = 40,
        LPArray = 42,
        LPStruct = 43,
        CustomMarshaler = 44,
        Error = 45,
        IInspectable = 46,
        HString = 47,
        LPUTF8Str = 48,
    }
    export enum VarEnum {
        VT_EMPTY = 0,
        VT_NULL = 1,
        VT_I2 = 2,
        VT_I4 = 3,
        VT_R4 = 4,
        VT_R8 = 5,
        VT_CY = 6,
        VT_DATE = 7,
        VT_BSTR = 8,
        VT_DISPATCH = 9,
        VT_ERROR = 10,
        VT_BOOL = 11,
        VT_VARIANT = 12,
        VT_UNKNOWN = 13,
        VT_DECIMAL = 14,
        VT_I1 = 16,
        VT_UI1 = 17,
        VT_UI2 = 18,
        VT_UI4 = 19,
        VT_I8 = 20,
        VT_UI8 = 21,
        VT_INT = 22,
        VT_UINT = 23,
        VT_VOID = 24,
        VT_HRESULT = 25,
        VT_PTR = 26,
        VT_SAFEARRAY = 27,
        VT_CARRAY = 28,
        VT_USERDEFINED = 29,
        VT_LPSTR = 30,
        VT_LPWSTR = 31,
        VT_RECORD = 36,
        VT_FILETIME = 64,
        VT_BLOB = 65,
        VT_STREAM = 66,
        VT_STORAGE = 67,
        VT_STREAMED_OBJECT = 68,
        VT_STORED_OBJECT = 69,
        VT_BLOB_OBJECT = 70,
        VT_CF = 71,
        VT_CLSID = 72,
        VT_VECTOR = 4096,
        VT_ARRAY = 8192,
        VT_BYREF = 16384,
    }
    export enum GCHandleType {
        Weak = 0,
        WeakTrackResurrection = 1,
        Normal = 2,
        Pinned = 3,
    }
    export class GCHandle extends ValueType implements IEquatable<GCHandle> {
        private _handle: number;

        public get Target(): any {
            throw new Error("not yet implemented");
        }
        public set Target(value: any) {
            throw new Error("not yet implemented");
        }
        public get IsAllocated(): boolean {
            throw new Error("not yet implemented");
        }

        private constructor(value: any, type: GCHandleType) {
            throw new Error("not yet implemented");
        }
        private constructor(handle: number) {
            throw new Error("not yet implemented");
        }

        private static InternalAlloc(value: any, type: GCHandleType): number {
            throw new Error("not yet implemented");
        }
        private static InternalFree(handle: number) {
            throw new Error("not yet implemented");
        }
        private static InternalGet(handle: number): any {
            throw new Error("not yet implemented");
        }
        private static InternalSet(handle: number, value: any) {
            throw new Error("not yet implemented");
        }
        private static InternalCompareExchange(handle: number, value: any, oldValue: any): any {
            throw new Error("not yet implemented");
        }
        public static Alloc(value: any): GCHandle {
            throw new Error("not yet implemented");
        }
        public static Alloc(value: any, type: GCHandleType): GCHandle {
            throw new Error("not yet implemented");
        }
        public Free() {
            throw new Error("not yet implemented");
        }
        public AddrOfPinnedObject(): number {
            throw new Error("not yet implemented");
        }
        public static FromIntPtr(value: number): GCHandle {
            throw new Error("not yet implemented");
        }
        public static ToIntPtr(value: GCHandle): number {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public Equals(o: any): boolean {
            throw new Error("not yet implemented");
        }
        public Equals(other: GCHandle): boolean {
            throw new Error("not yet implemented");
        }
        private static GetHandleValue(handle: number): number {
            throw new Error("not yet implemented");
        }
        private static IsPinned(handle: number): boolean {
            throw new Error("not yet implemented");
        }
        private static ThrowIfInvalid(handle: number) {
            throw new Error("not yet implemented");
        }
    }
    export enum CallingConvention {
        Winapi = 1,
        Cdecl = 2,
        StdCall = 3,
        ThisCall = 4,
        FastCall = 5,
    }
    export enum CharSet {
        None = 1,
        Ansi = 2,
        Unicode = 3,
        Auto = 4,
    }
    export enum LayoutKind {
        Sequential = 0,
        Explicit = 2,
        Auto = 3,
    }
    export class StructLayoutAttribute extends Attribute {
        private __Value__k__BackingField: LayoutKind;
        public Pack: number;
        public Size: number;
        public CharSet: CharSet;

        public get Value(): LayoutKind {
            throw new Error("not yet implemented");
        }

        public constructor(layoutKind: LayoutKind) {
            throw new Error("not yet implemented");
        }
        public constructor(layoutKind: number) {
            throw new Error("not yet implemented");
        }

    }
}
export namespace System.Runtime.Loader {
    export enum InternalState {
        Alive = 0,
        Unloading = 1,
    }
    export class ContextualReflectionScope extends ValueType implements IDisposable {
        private _activated: AssemblyLoadContext;
        private _predecessor: AssemblyLoadContext;
        private _initialized: boolean;

        protected constructor(activating: AssemblyLoadContext) {
            throw new Error("not yet implemented");
        }

        public Dispose() {
            throw new Error("not yet implemented");
        }
    }
    export class AssemblyLoadContext {
        private static s_allContexts: Dictionary<number, WeakReference<AssemblyLoadContext>>;
        private static s_nextId: number;
        private static AssemblyLoad: AssemblyLoadEventHandler;
        private static TypeResolve: ResolveEventHandler;
        private static ResourceResolve: ResolveEventHandler;
        private static AssemblyResolve: ResolveEventHandler;
        private static s_asyncLocalCurrent: AsyncLocal<AssemblyLoadContext>;
        private static AssemblyLoadName: string;

        private static get AllContexts(): Dictionary<number, WeakReference<AssemblyLoadContext>> {
            throw new Error("not yet implemented");
        }
        public static get Default(): AssemblyLoadContext {
            throw new Error("not yet implemented");
        }
        public static get All(): IEnumerable<AssemblyLoadContext> {
            throw new Error("not yet implemented");
        }
        public static get CurrentContextualReflectionContext(): AssemblyLoadContext {
            throw new Error("not yet implemented");
        }

        private _nativeAssemblyLoadContext: number;
        private _unloadLock: any;
        private _resolvingUnmanagedDll: Func<Assembly, string, number>;
        private _resolving: Func<AssemblyLoadContext, AssemblyName, Assembly>;
        private _unloading: Action<AssemblyLoadContext>;
        private _name: string;
        private _id: number;
        private _state: InternalState;
        private _isCollectible: boolean;

        public get Assemblies(): IEnumerable<Assembly> {
            throw new Error("not yet implemented");
        }
        public get IsCollectible(): boolean {
            throw new Error("not yet implemented");
        }
        public get Name(): string {
            throw new Error("not yet implemented");
        }

        protected constructor() {
            throw new Error("not yet implemented");
        }
        protected constructor(isCollectible: boolean) {
            throw new Error("not yet implemented");
        }
        public constructor(name: string, isCollectible: boolean) {
            throw new Error("not yet implemented");
        }
        protected constructor(representsTPALoadContext: boolean, isCollectible: boolean, name: string) {
            throw new Error("not yet implemented");
        }

        private static InitializeAssemblyLoadContext(ptrAssemblyLoadContext: number, fRepresentsTPALoadContext: boolean, isCollectible: boolean): number {
            throw new Error("not yet implemented");
        }
        private static PrepareForAssemblyLoadContextRelease(ptrNativeAssemblyBinder: number, ptrAssemblyLoadContextStrong: number) {
            throw new Error("not yet implemented");
        }
        private static LoadFromStream(ptrNativeAssemblyBinder: number, ptrAssemblyArray: number, iAssemblyArrayLen: number, ptrSymbols: number, iSymbolArrayLen: number, retAssembly: ObjectHandleOnStack) {
            throw new Error("not yet implemented");
        }
        private static InternalSetProfileRoot(directoryPath: string) {
            throw new Error("not yet implemented");
        }
        private static InternalStartProfile(profile: string, ptrNativeAssemblyBinder: number) {
            throw new Error("not yet implemented");
        }
        private static LoadFromPath(ptrNativeAssemblyBinder: number, ilPath: string, niPath: string, retAssembly: ObjectHandleOnStack) {
            throw new Error("not yet implemented");
        }
        private static GetLoadedAssemblies(): Assembly[] {
            throw new Error("not yet implemented");
        }
        private static IsTracingEnabled(): boolean {
            throw new Error("not yet implemented");
        }
        private static TraceResolvingHandlerInvoked(assemblyName: string, handlerName: string, alcName: string, resultAssemblyName: string, resultAssemblyPath: string): boolean {
            throw new Error("not yet implemented");
        }
        private static TraceAssemblyResolveHandlerInvoked(assemblyName: string, handlerName: string, resultAssemblyName: string, resultAssemblyPath: string): boolean {
            throw new Error("not yet implemented");
        }
        private static TraceAssemblyLoadFromResolveHandlerInvoked(assemblyName: string, isTrackedAssembly: boolean, requestingAssemblyPath: string, requestedAssemblyPath: string): boolean {
            throw new Error("not yet implemented");
        }
        private static TraceSatelliteSubdirectoryPathProbed(filePath: string, hResult: number): boolean {
            throw new Error("not yet implemented");
        }
        private InternalLoadFromPath(assemblyPath: string, nativeImagePath: string): RuntimeAssembly {
            throw new Error("not yet implemented");
        }
        private InternalLoad(arrAssembly: ReadOnlySpan<number>, arrSymbols: ReadOnlySpan<number>): Assembly {
            throw new Error("not yet implemented");
        }
        private static LoadFromInMemoryModuleInternal(ptrNativeAssemblyBinder: number, hModule: number, retAssembly: ObjectHandleOnStack): number {
            throw new Error("not yet implemented");
        }
        private LoadFromInMemoryModule(moduleHandle: number): Assembly {
            throw new Error("not yet implemented");
        }
        private static ResolveSatelliteAssembly(gchManagedAssemblyLoadContext: number, assemblyName: AssemblyName): Assembly {
            throw new Error("not yet implemented");
        }
        private static ResolveUnmanagedDll(unmanagedDllName: string, gchManagedAssemblyLoadContext: number): number {
            throw new Error("not yet implemented");
        }
        private static ResolveUnmanagedDllUsingEvent(unmanagedDllName: string, assembly: Assembly, gchManagedAssemblyLoadContext: number): number {
            throw new Error("not yet implemented");
        }
        private static ResolveUsingResolvingEvent(gchManagedAssemblyLoadContext: number, assemblyName: AssemblyName): Assembly {
            throw new Error("not yet implemented");
        }
        private static GetLoadContextForAssembly(assembly: QCallAssembly): number {
            throw new Error("not yet implemented");
        }
        public static GetLoadContext(assembly: Assembly): AssemblyLoadContext {
            throw new Error("not yet implemented");
        }
        public SetProfileOptimizationRoot(directoryPath: string) {
            throw new Error("not yet implemented");
        }
        public StartProfileOptimization(profile: string) {
            throw new Error("not yet implemented");
        }
        private static GetRuntimeAssembly(asm: Assembly): RuntimeAssembly {
            throw new Error("not yet implemented");
        }
        private static StartAssemblyLoad(ref activityId: Guid, ref relatedActivityId: Guid) {
            throw new Error("not yet implemented");
        }
        private static StopAssemblyLoad(ref activityId: Guid) {
            throw new Error("not yet implemented");
        }
        private static InitializeDefaultContext() {
            throw new Error("not yet implemented");
        }
        private Finalize() {
            throw new Error("not yet implemented");
        }
        private RaiseUnloadEvent() {
            throw new Error("not yet implemented");
        }
        private InitiateUnload() {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
        public static GetAssemblyName(assemblyPath: string): AssemblyName {
            throw new Error("not yet implemented");
        }
        private Load(assemblyName: AssemblyName): Assembly {
            throw new Error("not yet implemented");
        }
        public LoadFromAssemblyName(assemblyName: AssemblyName): Assembly {
            throw new Error("not yet implemented");
        }
        public LoadFromAssemblyPath(assemblyPath: string): Assembly {
            throw new Error("not yet implemented");
        }
        public LoadFromNativeImagePath(nativeImagePath: string, assemblyPath: string): Assembly {
            throw new Error("not yet implemented");
        }
        public LoadFromStream(assembly: Stream): Assembly {
            throw new Error("not yet implemented");
        }
        public LoadFromStream(assembly: Stream, assemblySymbols: Stream): Assembly {
            throw new Error("not yet implemented");
        }
        private LoadUnmanagedDllFromPath(unmanagedDllPath: string): number {
            throw new Error("not yet implemented");
        }
        private LoadUnmanagedDll(unmanagedDllName: string): number {
            throw new Error("not yet implemented");
        }
        public Unload() {
            throw new Error("not yet implemented");
        }
        private static OnProcessExit() {
            throw new Error("not yet implemented");
        }
        private VerifyIsAlive() {
            throw new Error("not yet implemented");
        }
        private static SetCurrentContextualReflectionContext(value: AssemblyLoadContext) {
            throw new Error("not yet implemented");
        }
        public EnterContextualReflection(): ContextualReflectionScope {
            throw new Error("not yet implemented");
        }
        public static EnterContextualReflection(activating: Assembly): ContextualReflectionScope {
            throw new Error("not yet implemented");
        }
        private static Resolve(gchManagedAssemblyLoadContext: number, assemblyName: AssemblyName): Assembly {
            throw new Error("not yet implemented");
        }
        private GetFirstResolvedAssemblyFromResolvingEvent(assemblyName: AssemblyName): Assembly {
            throw new Error("not yet implemented");
        }
        private static ValidateAssemblyNameWithSimpleName(assembly: Assembly, requestedSimpleName: string): Assembly {
            throw new Error("not yet implemented");
        }
        private ResolveUsingLoad(assemblyName: AssemblyName): Assembly {
            throw new Error("not yet implemented");
        }
        private ResolveUsingEvent(assemblyName: AssemblyName): Assembly {
            throw new Error("not yet implemented");
        }
        private static OnAssemblyLoad(assembly: RuntimeAssembly) {
            throw new Error("not yet implemented");
        }
        private static OnResourceResolve(assembly: RuntimeAssembly, resourceName: string): RuntimeAssembly {
            throw new Error("not yet implemented");
        }
        private static OnTypeResolve(assembly: RuntimeAssembly, typeName: string): RuntimeAssembly {
            throw new Error("not yet implemented");
        }
        private static OnAssemblyResolve(assembly: RuntimeAssembly, assemblyFullName: string): RuntimeAssembly {
            throw new Error("not yet implemented");
        }
        private static InvokeResolveEvent(eventHandler: ResolveEventHandler, assembly: RuntimeAssembly, name: string): RuntimeAssembly {
            throw new Error("not yet implemented");
        }
        private ResolveSatelliteAssembly(assemblyName: AssemblyName): Assembly {
            throw new Error("not yet implemented");
        }
        private GetResolvedUnmanagedDll(assembly: Assembly, unmanagedDllName: string): number {
            throw new Error("not yet implemented");
        }
        private static __InitializeAssemblyLoadContext__g____PInvoke_0_0(__ptrAssemblyLoadContext_native: number, __fRepresentsTPALoadContext_native: number, __isCollectible_native: number): number {
            throw new Error("not yet implemented");
        }
        private static __InternalSetProfileRoot__g____PInvoke_3_0(__directoryPath_native: number*) {
            throw new Error("not yet implemented");
        }
        private static __InternalStartProfile__g____PInvoke_4_0(__profile_native: number*, __ptrNativeAssemblyBinder_native: number) {
            throw new Error("not yet implemented");
        }
        private static __LoadFromPath__g____PInvoke_5_0(__ptrNativeAssemblyBinder_native: number, __ilPath_native: number*, __niPath_native: number*, __retAssembly_native: ObjectHandleOnStack) {
            throw new Error("not yet implemented");
        }
        private static __TraceResolvingHandlerInvoked__g____PInvoke_8_0(__assemblyName_native: number*, __handlerName_native: number*, __alcName_native: number*, __resultAssemblyName_native: number*, __resultAssemblyPath_native: number*): number {
            throw new Error("not yet implemented");
        }
        private static __TraceAssemblyResolveHandlerInvoked__g____PInvoke_9_0(__assemblyName_native: number*, __handlerName_native: number*, __resultAssemblyName_native: number*, __resultAssemblyPath_native: number*): number {
            throw new Error("not yet implemented");
        }
        private static __TraceAssemblyLoadFromResolveHandlerInvoked__g____PInvoke_10_0(__assemblyName_native: number*, __isTrackedAssembly_native: number, __requestingAssemblyPath_native: number*, __requestedAssemblyPath_native: number*): number {
            throw new Error("not yet implemented");
        }
        private static __TraceSatelliteSubdirectoryPathProbed__g____PInvoke_11_0(__filePath_native: number*, __hResult_native: number): number {
            throw new Error("not yet implemented");
        }
        private static __LoadFromStream__g__ReadAllBytes_94_0(stream: Stream): ReadOnlySpan<number> {
            throw new Error("not yet implemented");
        }
    }
    export namespace AssemblyLoadContext {
        export enum InternalState {
            Alive = 0,
            Unloading = 1,
        }

        export class ContextualReflectionScope extends ValueType implements IDisposable {
            private _activated: AssemblyLoadContext;
            private _predecessor: AssemblyLoadContext;
            private _initialized: boolean;

            protected constructor(activating: AssemblyLoadContext) {
                throw new Error("not yet implemented");
            }

            public Dispose() {
                throw new Error("not yet implemented");
            }
        }

        export class __get_All__d__87 implements IEnumerable<AssemblyLoadContext>, IEnumerable, IEnumerator<AssemblyLoadContext>, IDisposable, IEnumerator {
            private ____1__state: number;
            private ____2__current: AssemblyLoadContext;
            private ____l__initialThreadId: number;
            private ____7__wrap1: WeakReference<AssemblyLoadContext>[];
            private ____7__wrap2: number;

            private get __explicit__AssemblyLoadContext___Current(): AssemblyLoadContext {
                throw new Error("not yet implemented");
            }
            public get Current(): AssemblyLoadContext {
                throw new Error("Invalid call (use ExplicitAs property)");
            }
            private get __explicit__IEnumerator_Current(): any {
                throw new Error("not yet implemented");
            }
            public get Current(): any {
                throw new Error("Invalid call (use ExplicitAs property)");
            }

            public constructor(____1__state: number) {
                throw new Error("not yet implemented");
            }

            private __explicit__IDisposable_Dispose() {
                throw new Error("not yet implemented");
            }
            public Dispose() {
                throw new Error("Invalid call (use ExplicitAs property)");
            }
            private __explicit__MoveNext(): boolean {
                throw new Error("not yet implemented");
            }
            private __explicit__IEnumerator_Reset() {
                throw new Error("not yet implemented");
            }
            public Reset() {
                throw new Error("Invalid call (use ExplicitAs property)");
            }
            private __explicit__AssemblyLoadContext___GetEnumerator(): IEnumerator<AssemblyLoadContext> {
                throw new Error("not yet implemented");
            }
            public GetEnumerator(): IEnumerator<AssemblyLoadContext> {
                throw new Error("Invalid call (use ExplicitAs property)");
            }
            private __explicit__IEnumerable_GetEnumerator(): IEnumerator {
                throw new Error("not yet implemented");
            }
            public GetEnumerator(): IEnumerator {
                throw new Error("Invalid call (use ExplicitAs property)");
            }

            public readonly ExplicitAsIEnumerable__AssemblyLoadContext__: IEnumerable<AssemblyLoadContext> = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'Current') {
                        return target.__explicit__AssemblyLoadContext___Current;
                    }
                    if (prop === 'Current') {
                        return target.__explicit__IEnumerator_Current;
                    }
            
                    if (prop === 'Dispose') {
                        return target.__explicit__IDisposable_Dispose.bind(target);
                    }
                    if (prop === 'MoveNext') {
                        return target.__explicit__MoveNext.bind(target);
                    }
                    if (prop === 'Reset') {
                        return target.__explicit__IEnumerator_Reset.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__AssemblyLoadContext___GetEnumerator.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
            public readonly ExplicitAsIEnumerable: IEnumerable = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'Current') {
                        return target.__explicit__AssemblyLoadContext___Current;
                    }
                    if (prop === 'Current') {
                        return target.__explicit__IEnumerator_Current;
                    }
            
                    if (prop === 'Dispose') {
                        return target.__explicit__IDisposable_Dispose.bind(target);
                    }
                    if (prop === 'MoveNext') {
                        return target.__explicit__MoveNext.bind(target);
                    }
                    if (prop === 'Reset') {
                        return target.__explicit__IEnumerator_Reset.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__AssemblyLoadContext___GetEnumerator.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
            public readonly ExplicitAsIEnumerator__AssemblyLoadContext__: IEnumerator<AssemblyLoadContext> = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'Current') {
                        return target.__explicit__AssemblyLoadContext___Current;
                    }
                    if (prop === 'Current') {
                        return target.__explicit__IEnumerator_Current;
                    }
            
                    if (prop === 'Dispose') {
                        return target.__explicit__IDisposable_Dispose.bind(target);
                    }
                    if (prop === 'MoveNext') {
                        return target.__explicit__MoveNext.bind(target);
                    }
                    if (prop === 'Reset') {
                        return target.__explicit__IEnumerator_Reset.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__AssemblyLoadContext___GetEnumerator.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
            public readonly ExplicitAsIDisposable: IDisposable = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'Current') {
                        return target.__explicit__AssemblyLoadContext___Current;
                    }
                    if (prop === 'Current') {
                        return target.__explicit__IEnumerator_Current;
                    }
            
                    if (prop === 'Dispose') {
                        return target.__explicit__IDisposable_Dispose.bind(target);
                    }
                    if (prop === 'MoveNext') {
                        return target.__explicit__MoveNext.bind(target);
                    }
                    if (prop === 'Reset') {
                        return target.__explicit__IEnumerator_Reset.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__AssemblyLoadContext___GetEnumerator.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
            public readonly ExplicitAsIEnumerator: IEnumerator = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'Current') {
                        return target.__explicit__AssemblyLoadContext___Current;
                    }
                    if (prop === 'Current') {
                        return target.__explicit__IEnumerator_Current;
                    }
            
                    if (prop === 'Dispose') {
                        return target.__explicit__IDisposable_Dispose.bind(target);
                    }
                    if (prop === 'MoveNext') {
                        return target.__explicit__MoveNext.bind(target);
                    }
                    if (prop === 'Reset') {
                        return target.__explicit__IEnumerator_Reset.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__AssemblyLoadContext___GetEnumerator.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
        }

        export class __get_Assemblies__d__57 implements IEnumerable<Assembly>, IEnumerable, IEnumerator<Assembly>, IDisposable, IEnumerator {
            private ____1__state: number;
            private ____2__current: Assembly;
            private ____l__initialThreadId: number;
            public ____4__this: AssemblyLoadContext;
            private ____7__wrap1: Assembly[];
            private ____7__wrap2: number;

            private get __explicit__Assembly___Current(): Assembly {
                throw new Error("not yet implemented");
            }
            public get Current(): Assembly {
                throw new Error("Invalid call (use ExplicitAs property)");
            }
            private get __explicit__IEnumerator_Current(): any {
                throw new Error("not yet implemented");
            }
            public get Current(): any {
                throw new Error("Invalid call (use ExplicitAs property)");
            }

            public constructor(____1__state: number) {
                throw new Error("not yet implemented");
            }

            private __explicit__IDisposable_Dispose() {
                throw new Error("not yet implemented");
            }
            public Dispose() {
                throw new Error("Invalid call (use ExplicitAs property)");
            }
            private __explicit__MoveNext(): boolean {
                throw new Error("not yet implemented");
            }
            private __explicit__IEnumerator_Reset() {
                throw new Error("not yet implemented");
            }
            public Reset() {
                throw new Error("Invalid call (use ExplicitAs property)");
            }
            private __explicit__Assembly___GetEnumerator(): IEnumerator<Assembly> {
                throw new Error("not yet implemented");
            }
            public GetEnumerator(): IEnumerator<Assembly> {
                throw new Error("Invalid call (use ExplicitAs property)");
            }
            private __explicit__IEnumerable_GetEnumerator(): IEnumerator {
                throw new Error("not yet implemented");
            }
            public GetEnumerator(): IEnumerator {
                throw new Error("Invalid call (use ExplicitAs property)");
            }

            public readonly ExplicitAsIEnumerable__Assembly__: IEnumerable<Assembly> = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'Current') {
                        return target.__explicit__Assembly___Current;
                    }
                    if (prop === 'Current') {
                        return target.__explicit__IEnumerator_Current;
                    }
            
                    if (prop === 'Dispose') {
                        return target.__explicit__IDisposable_Dispose.bind(target);
                    }
                    if (prop === 'MoveNext') {
                        return target.__explicit__MoveNext.bind(target);
                    }
                    if (prop === 'Reset') {
                        return target.__explicit__IEnumerator_Reset.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__Assembly___GetEnumerator.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
            public readonly ExplicitAsIEnumerable: IEnumerable = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'Current') {
                        return target.__explicit__Assembly___Current;
                    }
                    if (prop === 'Current') {
                        return target.__explicit__IEnumerator_Current;
                    }
            
                    if (prop === 'Dispose') {
                        return target.__explicit__IDisposable_Dispose.bind(target);
                    }
                    if (prop === 'MoveNext') {
                        return target.__explicit__MoveNext.bind(target);
                    }
                    if (prop === 'Reset') {
                        return target.__explicit__IEnumerator_Reset.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__Assembly___GetEnumerator.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
            public readonly ExplicitAsIEnumerator__Assembly__: IEnumerator<Assembly> = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'Current') {
                        return target.__explicit__Assembly___Current;
                    }
                    if (prop === 'Current') {
                        return target.__explicit__IEnumerator_Current;
                    }
            
                    if (prop === 'Dispose') {
                        return target.__explicit__IDisposable_Dispose.bind(target);
                    }
                    if (prop === 'MoveNext') {
                        return target.__explicit__MoveNext.bind(target);
                    }
                    if (prop === 'Reset') {
                        return target.__explicit__IEnumerator_Reset.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__Assembly___GetEnumerator.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
            public readonly ExplicitAsIDisposable: IDisposable = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'Current') {
                        return target.__explicit__Assembly___Current;
                    }
                    if (prop === 'Current') {
                        return target.__explicit__IEnumerator_Current;
                    }
            
                    if (prop === 'Dispose') {
                        return target.__explicit__IDisposable_Dispose.bind(target);
                    }
                    if (prop === 'MoveNext') {
                        return target.__explicit__MoveNext.bind(target);
                    }
                    if (prop === 'Reset') {
                        return target.__explicit__IEnumerator_Reset.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__Assembly___GetEnumerator.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
            public readonly ExplicitAsIEnumerator: IEnumerator = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'Current') {
                        return target.__explicit__Assembly___Current;
                    }
                    if (prop === 'Current') {
                        return target.__explicit__IEnumerator_Current;
                    }
            
                    if (prop === 'Dispose') {
                        return target.__explicit__IDisposable_Dispose.bind(target);
                    }
                    if (prop === 'MoveNext') {
                        return target.__explicit__MoveNext.bind(target);
                    }
                    if (prop === 'Reset') {
                        return target.__explicit__IEnumerator_Reset.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__Assembly___GetEnumerator.bind(target);
                    }
                    if (prop === 'GetEnumerator') {
                        return target.__explicit__IEnumerable_GetEnumerator.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
        }
    }
}
export namespace System.Runtime.Remoting {
    export class ObjectHandle extends MarshalByRefObject {
        private _wrappedObject: any;

        public constructor(o: any) {
            throw new Error("not yet implemented");
        }

        public Unwrap(): any {
            throw new Error("not yet implemented");
        }
    }
}
export namespace System.Runtime.Serialization {
    export enum StreamingContextStates {
        CrossProcess = 0x1,
        CrossMachine = 0x2,
        File = 0x4,
        Persistence = 0x8,
        Remoting = 0x10,
        Other = 0x20,
        Clone = 0x40,
        CrossAppDomain = 0x80,
        All = 0xff,
    }
    export class StreamingContext extends ValueType {
        private _additionalContext: any;
        private _state: StreamingContextStates;

        public get State(): StreamingContextStates {
            throw new Error("not yet implemented");
        }
        public get Context(): any {
            throw new Error("not yet implemented");
        }

        public constructor(state: StreamingContextStates) {
            throw new Error("not yet implemented");
        }
        public constructor(state: StreamingContextStates, additional: any) {
            throw new Error("not yet implemented");
        }

        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
    }
    export interface IDeserializationCallback {
        OnDeserialization(sender: any): void;
    }
    export interface IObjectReference {
        GetRealObject(context: StreamingContext): any;
    }
    export interface IFormatterConverter {
        Convert(value: any, type: Type): any;
        Convert(value: any, typeCode: TypeCode): any;
        ToBoolean(value: any): boolean;
        ToChar(value: any): string;
        ToSByte(value: any): number;
        ToByte(value: any): number;
        ToInt16(value: any): number;
        ToUInt16(value: any): number;
        ToInt32(value: any): number;
        ToUInt32(value: any): number;
        ToInt64(value: any): number;
        ToUInt64(value: any): number;
        ToSingle(value: any): number;
        ToDouble(value: any): number;
        ToDecimal(value: any): number;
        ToDateTime(value: any): DateTime;
        ToString(value: any): string;
    }
    export class DeserializationTracker {
        private __DeserializationInProgress__k__BackingField: boolean;

        private get DeserializationInProgress(): boolean {
            throw new Error("not yet implemented");
        }
        private set DeserializationInProgress(value: boolean) {
            throw new Error("not yet implemented");
        }

        public constructor() {
            throw new Error("not yet implemented");
        }

    }
    export class SerializationEntry extends ValueType {
        private _name: string;
        private _value: any;
        private _type: Type;

        public get Value(): any {
            throw new Error("not yet implemented");
        }
        public get Name(): string {
            throw new Error("not yet implemented");
        }
        public get ObjectType(): Type {
            throw new Error("not yet implemented");
        }

        protected constructor(entryName: string, entryValue: any, entryType: Type) {
            throw new Error("not yet implemented");
        }

    }
    export class SerializationInfoEnumerator implements IEnumerator {
        private _members: string[];
        private _data: any[];
        private _types: Type[];
        private _numItems: number;
        private _currItem: number;
        private _current: boolean;

        private get __explicit__IEnumerator_Current(): any {
            throw new Error("not yet implemented");
        }
        public get Current(): SerializationEntry {
            throw new Error("not yet implemented");
        }
        public get Name(): string {
            throw new Error("not yet implemented");
        }
        public get Value(): any {
            throw new Error("not yet implemented");
        }
        public get ObjectType(): Type {
            throw new Error("not yet implemented");
        }

        protected constructor(members: string[], info: any[], types: Type[], numItems: number) {
            throw new Error("not yet implemented");
        }

        public MoveNext(): boolean {
            throw new Error("not yet implemented");
        }
        public Reset() {
            throw new Error("not yet implemented");
        }

        public readonly ExplicitAsIEnumerator: IEnumerator = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'Current') {
                    return target.__explicit__IEnumerator_Current;
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
    }
    export class DeserializationToken extends ValueType implements IDisposable {
        private _tracker: DeserializationTracker;

        protected constructor(tracker: DeserializationTracker) {
            throw new Error("not yet implemented");
        }

        public Dispose() {
            throw new Error("not yet implemented");
        }
    }
    export class SerializationInfo {
        private static readonly __AsyncDeserializationInProgress__k__BackingField: AsyncLocal<boolean>;
        private static t_deserializationTracker: DeserializationTracker;

        private static get AsyncDeserializationInProgress(): AsyncLocal<boolean> {
            throw new Error("not yet implemented");
        }
        private static get DeserializationInProgress(): boolean {
            throw new Error("not yet implemented");
        }

        private _names: string[];
        private _values: any[];
        private _types: Type[];
        private _count: number;
        private _nameToIndex: Dictionary<string, number>;
        private _converter: IFormatterConverter;
        private _rootTypeName: string;
        private _rootTypeAssemblyName: string;
        private _rootType: Type;
        private __IsFullTypeNameSetExplicit__k__BackingField: boolean;
        private __IsAssemblyNameSetExplicit__k__BackingField: boolean;

        public get FullTypeName(): string {
            throw new Error("not yet implemented");
        }
        public set FullTypeName(value: string) {
            throw new Error("not yet implemented");
        }
        public get AssemblyName(): string {
            throw new Error("not yet implemented");
        }
        public set AssemblyName(value: string) {
            throw new Error("not yet implemented");
        }
        public get IsFullTypeNameSetExplicit(): boolean {
            throw new Error("not yet implemented");
        }
        private set IsFullTypeNameSetExplicit(value: boolean) {
            throw new Error("not yet implemented");
        }
        public get IsAssemblyNameSetExplicit(): boolean {
            throw new Error("not yet implemented");
        }
        private set IsAssemblyNameSetExplicit(value: boolean) {
            throw new Error("not yet implemented");
        }
        public get MemberCount(): number {
            throw new Error("not yet implemented");
        }
        public get ObjectType(): Type {
            throw new Error("not yet implemented");
        }

        public constructor(type: Type, converter: IFormatterConverter) {
            throw new Error("not yet implemented");
        }
        public constructor(type: Type, converter: IFormatterConverter, requireSameTokenInPartialTrust: boolean) {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

        public SetType(type: Type) {
            throw new Error("not yet implemented");
        }
        public GetEnumerator(): SerializationInfoEnumerator {
            throw new Error("not yet implemented");
        }
        private ExpandArrays() {
            throw new Error("not yet implemented");
        }
        public AddValue(name: string, value: any, type: Type) {
            throw new Error("not yet implemented");
        }
        public AddValue(name: string, value: any) {
            throw new Error("not yet implemented");
        }
        public AddValue(name: string, value: boolean) {
            throw new Error("not yet implemented");
        }
        public AddValue(name: string, value: string) {
            throw new Error("not yet implemented");
        }
        public AddValue(name: string, value: number) {
            throw new Error("not yet implemented");
        }
        public AddValue(name: string, value: number) {
            throw new Error("not yet implemented");
        }
        public AddValue(name: string, value: number) {
            throw new Error("not yet implemented");
        }
        public AddValue(name: string, value: number) {
            throw new Error("not yet implemented");
        }
        public AddValue(name: string, value: number) {
            throw new Error("not yet implemented");
        }
        public AddValue(name: string, value: number) {
            throw new Error("not yet implemented");
        }
        public AddValue(name: string, value: number) {
            throw new Error("not yet implemented");
        }
        public AddValue(name: string, value: number) {
            throw new Error("not yet implemented");
        }
        public AddValue(name: string, value: number) {
            throw new Error("not yet implemented");
        }
        public AddValue(name: string, value: number) {
            throw new Error("not yet implemented");
        }
        public AddValue(name: string, value: number) {
            throw new Error("not yet implemented");
        }
        public AddValue(name: string, value: DateTime) {
            throw new Error("not yet implemented");
        }
        private AddValueInternal(name: string, value: any, type: Type) {
            throw new Error("not yet implemented");
        }
        private UpdateValue(name: string, value: any, type: Type) {
            throw new Error("not yet implemented");
        }
        private FindElement(name: string): number {
            throw new Error("not yet implemented");
        }
        private GetElement(name: string, out foundType: Type): any {
            throw new Error("not yet implemented");
        }
        private GetElementNoThrow(name: string, out foundType: Type): any {
            throw new Error("not yet implemented");
        }
        public GetValue(name: string, type: Type): any {
            throw new Error("not yet implemented");
        }
        private GetValueNoThrow(name: string, type: Type): any {
            throw new Error("not yet implemented");
        }
        public GetBoolean(name: string): boolean {
            throw new Error("not yet implemented");
        }
        public GetChar(name: string): string {
            throw new Error("not yet implemented");
        }
        public GetSByte(name: string): number {
            throw new Error("not yet implemented");
        }
        public GetByte(name: string): number {
            throw new Error("not yet implemented");
        }
        public GetInt16(name: string): number {
            throw new Error("not yet implemented");
        }
        public GetUInt16(name: string): number {
            throw new Error("not yet implemented");
        }
        public GetInt32(name: string): number {
            throw new Error("not yet implemented");
        }
        public GetUInt32(name: string): number {
            throw new Error("not yet implemented");
        }
        public GetInt64(name: string): number {
            throw new Error("not yet implemented");
        }
        public GetUInt64(name: string): number {
            throw new Error("not yet implemented");
        }
        public GetSingle(name: string): number {
            throw new Error("not yet implemented");
        }
        public GetDouble(name: string): number {
            throw new Error("not yet implemented");
        }
        public GetDecimal(name: string): number {
            throw new Error("not yet implemented");
        }
        public GetDateTime(name: string): DateTime {
            throw new Error("not yet implemented");
        }
        public GetString(name: string): string {
            throw new Error("not yet implemented");
        }
        private static GetThreadDeserializationTracker(): DeserializationTracker {
            throw new Error("not yet implemented");
        }
        private static ThrowIfDeserializationInProgress(switchSuffix: string, ref cachedValue: number) {
            throw new Error("not yet implemented");
        }
        public static StartDeserialization(): DeserializationToken {
            throw new Error("not yet implemented");
        }
    }
    export interface ISerializable {
        GetObjectData(info: SerializationInfo, context: StreamingContext): void;
    }
}
export namespace System.Security {
    export class SecurityElement {
        private static readonly s_escapeStringPairs: string[];

        private _tag: string;
        private _text: string;
        private _children: ArrayList;
        private _attributes: ArrayList;

        public get Tag(): string {
            throw new Error("not yet implemented");
        }
        public set Tag(value: string) {
            throw new Error("not yet implemented");
        }
        public get Attributes(): Hashtable {
            throw new Error("not yet implemented");
        }
        public set Attributes(value: Hashtable) {
            throw new Error("not yet implemented");
        }
        public get Text(): string {
            throw new Error("not yet implemented");
        }
        public set Text(value: string) {
            throw new Error("not yet implemented");
        }
        public get Children(): ArrayList {
            throw new Error("not yet implemented");
        }
        public set Children(value: ArrayList) {
            throw new Error("not yet implemented");
        }

        public constructor(tag: string) {
            throw new Error("not yet implemented");
        }
        public constructor(tag: string, text: string) {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

        private AddAttributeSafe(name: string, value: string) {
            throw new Error("not yet implemented");
        }
        public AddAttribute(name: string, value: string) {
            throw new Error("not yet implemented");
        }
        public AddChild(child: SecurityElement) {
            throw new Error("not yet implemented");
        }
        public Equal(other: SecurityElement): boolean {
            throw new Error("not yet implemented");
        }
        public Copy(): SecurityElement {
            throw new Error("not yet implemented");
        }
        public static IsValidTag(tag: string): boolean {
            throw new Error("not yet implemented");
        }
        public static IsValidText(text: string): boolean {
            throw new Error("not yet implemented");
        }
        public static IsValidAttributeName(name: string): boolean {
            throw new Error("not yet implemented");
        }
        public static IsValidAttributeValue(value: string): boolean {
            throw new Error("not yet implemented");
        }
        private static GetEscapeSequence(c: string): string {
            throw new Error("not yet implemented");
        }
        public static Escape(str: string): string {
            throw new Error("not yet implemented");
        }
        private static GetUnescapeSequence(str: string, index: number, out newIndex: number): string {
            throw new Error("not yet implemented");
        }
        private static Unescape(str: string): string {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
        private ToString(obj: any, write: Action<any, string>) {
            throw new Error("not yet implemented");
        }
        public Attribute(name: string): string {
            throw new Error("not yet implemented");
        }
        public SearchForChildByTag(tag: string): SecurityElement {
            throw new Error("not yet implemented");
        }
        public SearchForTextOfTag(tag: string): string {
            throw new Error("not yet implemented");
        }
        public static FromString(xml: string): SecurityElement {
            throw new Error("not yet implemented");
        }
    }
    export namespace SecurityElement {
        export class ____c {
            public static readonly ____9: ____c;
            public static ____9__35_0: Action<any, string>;

            private static staticctor_initialize = (() => {
                throw new Error("not yet implemented");
            })();
            private constructor() { }
            public constructor() {
                throw new Error("not yet implemented");
            }

            private __ToString__b__35_0(obj: any, str: string) {
                throw new Error("not yet implemented");
            }
        }
    }
    export interface ISecurityEncodable {
        FromXml(e: SecurityElement): void;
        ToXml(): SecurityElement;
    }
    export interface IStackWalk {
        Assert(): void;
        Demand(): void;
        Deny(): void;
        PermitOnly(): void;
    }
    export interface IPermission implements ISecurityEncodable {
        Copy(): IPermission;
        Demand(): void;
        Intersect(target: IPermission): IPermission;
        IsSubsetOf(target: IPermission): boolean;
        Union(target: IPermission): IPermission;
    }
    export class PermissionSet implements ICollection, IEnumerable, IDeserializationCallback, ISecurityEncodable, IStackWalk {
        public get Count(): number {
            throw new Error("not yet implemented");
        }
        public get IsReadOnly(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsSynchronized(): boolean {
            throw new Error("not yet implemented");
        }
        public get SyncRoot(): any {
            throw new Error("not yet implemented");
        }

        public constructor(state: PermissionState) {
            throw new Error("not yet implemented");
        }
        public constructor(permSet: PermissionSet) {
            throw new Error("not yet implemented");
        }

        public AddPermission(perm: IPermission): IPermission {
            throw new Error("not yet implemented");
        }
        private AddPermissionImpl(perm: IPermission): IPermission {
            throw new Error("not yet implemented");
        }
        public Assert() {
            throw new Error("not yet implemented");
        }
        public ContainsNonCodeAccessPermissions(): boolean {
            throw new Error("not yet implemented");
        }
        public static ConvertPermissionSet(inFormat: string, inData: number[], outFormat: string): number[] {
            throw new Error("not yet implemented");
        }
        public Copy(): PermissionSet {
            throw new Error("not yet implemented");
        }
        public CopyTo(array: Array, index: number) {
            throw new Error("not yet implemented");
        }
        public Demand() {
            throw new Error("not yet implemented");
        }
        public Deny() {
            throw new Error("not yet implemented");
        }
        public Equals(o: any): boolean {
            throw new Error("not yet implemented");
        }
        public FromXml(et: SecurityElement) {
            throw new Error("not yet implemented");
        }
        public GetEnumerator(): IEnumerator {
            throw new Error("not yet implemented");
        }
        private GetEnumeratorImpl(): IEnumerator {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public GetPermission(permClass: Type): IPermission {
            throw new Error("not yet implemented");
        }
        private GetPermissionImpl(permClass: Type): IPermission {
            throw new Error("not yet implemented");
        }
        public Intersect(other: PermissionSet): PermissionSet {
            throw new Error("not yet implemented");
        }
        public IsEmpty(): boolean {
            throw new Error("not yet implemented");
        }
        public IsSubsetOf(target: PermissionSet): boolean {
            throw new Error("not yet implemented");
        }
        public IsUnrestricted(): boolean {
            throw new Error("not yet implemented");
        }
        public PermitOnly() {
            throw new Error("not yet implemented");
        }
        public RemovePermission(permClass: Type): IPermission {
            throw new Error("not yet implemented");
        }
        private RemovePermissionImpl(permClass: Type): IPermission {
            throw new Error("not yet implemented");
        }
        public static RevertAssert() {
            throw new Error("not yet implemented");
        }
        public SetPermission(perm: IPermission): IPermission {
            throw new Error("not yet implemented");
        }
        private SetPermissionImpl(perm: IPermission): IPermission {
            throw new Error("not yet implemented");
        }
        private __explicit__IDeserializationCallback_OnDeserialization(sender: any) {
            throw new Error("not yet implemented");
        }
        public OnDeserialization(sender: any) {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
        public ToXml(): SecurityElement {
            throw new Error("not yet implemented");
        }
        public Union(other: PermissionSet): PermissionSet {
            throw new Error("not yet implemented");
        }
    }
    export enum SecurityRuleSet {
        None = 0,
        Level1 = 1,
        Level2 = 2,
    }
}
export namespace System.Security.Permissions {
    export enum PermissionState {
        None = 0,
        Unrestricted = 1,
    }
}
export namespace System.Security.Principal {
    export interface IIdentity {
        get Name(): string;
        get AuthenticationType(): string;
        get IsAuthenticated(): boolean;

    }
    export interface IPrincipal {
        get Identity(): IIdentity;

        IsInRole(role: string): boolean;
    }
    export enum PrincipalPolicy {
        UnauthenticatedPrincipal = 0,
        NoPrincipal = 1,
        WindowsPrincipal = 2,
    }
}
export namespace System.Text {
    export class ValueStringBuilder extends ValueType {
        private _arrayToReturnToPool: string[];
        private _chars: Span<string>;
        private _pos: number;

        public get Length(): number {
            throw new Error("not yet implemented");
        }
        public set Length(value: number) {
            throw new Error("not yet implemented");
        }
        public get Capacity(): number {
            throw new Error("not yet implemented");
        }
        public get Item(): string {
            throw new Error("not yet implemented");
        }
        public get RawChars(): Span<string> {
            throw new Error("not yet implemented");
        }

        public constructor(initialBuffer: Span<string>) {
            throw new Error("not yet implemented");
        }
        public constructor(initialCapacity: number) {
            throw new Error("not yet implemented");
        }

        private AppendFormatHelper(provider: IFormatProvider, format: string, args: ReadOnlySpan<any>) {
            throw new Error("not yet implemented");
        }
        public EnsureCapacity(capacity: number) {
            throw new Error("not yet implemented");
        }
        public GetPinnableReference(): string {
            throw new Error("not yet implemented");
        }
        public GetPinnableReference(terminate: boolean): string {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
        public AsSpan(terminate: boolean): ReadOnlySpan<string> {
            throw new Error("not yet implemented");
        }
        public AsSpan(): ReadOnlySpan<string> {
            throw new Error("not yet implemented");
        }
        public AsSpan(start: number): ReadOnlySpan<string> {
            throw new Error("not yet implemented");
        }
        public AsSpan(start: number, length: number): ReadOnlySpan<string> {
            throw new Error("not yet implemented");
        }
        public Append(c: string) {
            throw new Error("not yet implemented");
        }
        public Append(s: string) {
            throw new Error("not yet implemented");
        }
        private AppendSlow(s: string) {
            throw new Error("not yet implemented");
        }
        public Append(c: string, count: number) {
            throw new Error("not yet implemented");
        }
        public Append(value: ReadOnlySpan<string>) {
            throw new Error("not yet implemented");
        }
        public AppendSpan(length: number): Span<string> {
            throw new Error("not yet implemented");
        }
        private GrowAndAppend(c: string) {
            throw new Error("not yet implemented");
        }
        private Grow(additionalCapacityBeyondPos: number) {
            throw new Error("not yet implemented");
        }
        public Dispose() {
            throw new Error("not yet implemented");
        }
        private AppendSpanFormattable(value: T, format: string, provider: IFormatProvider) {
            throw new Error("not yet implemented");
        }
        private static __AppendFormatHelper__g__MoveNext_0_0(format: string, ref pos: number): string {
            throw new Error("not yet implemented");
        }
    }
    export class ManyChunkInfo {
        private _chunks: StringBuilder[];
        private _chunkPos: number;

        public constructor(stringBuilder: StringBuilder, chunkCount: number) {
            throw new Error("not yet implemented");
        }

        public MoveNext(ref current: StringBuilder): boolean {
            throw new Error("not yet implemented");
        }
    }
    export class ChunkEnumerator extends ValueType {
        private _firstChunk: StringBuilder;
        private _currentChunk: StringBuilder;
        private _manyChunks: ManyChunkInfo;

        public get Current(): ReadOnlyMemory<string> {
            throw new Error("not yet implemented");
        }

        protected constructor(stringBuilder: StringBuilder) {
            throw new Error("not yet implemented");
        }

        public GetEnumerator(): ChunkEnumerator {
            throw new Error("not yet implemented");
        }
        public MoveNext(): boolean {
            throw new Error("not yet implemented");
        }
        private static ChunkCount(stringBuilder: StringBuilder): number {
            throw new Error("not yet implemented");
        }
    }
    export namespace ChunkEnumerator {
        export class ManyChunkInfo {
            private _chunks: StringBuilder[];
            private _chunkPos: number;

            public constructor(stringBuilder: StringBuilder, chunkCount: number) {
                throw new Error("not yet implemented");
            }

            public MoveNext(ref current: StringBuilder): boolean {
                throw new Error("not yet implemented");
            }
        }
    }
    export class AppendInterpolatedStringHandler extends ValueType {
        private _stringBuilder: StringBuilder;
        private _provider: IFormatProvider;
        private _hasCustomFormatter: boolean;

        public constructor(literalLength: number, formattedCount: number, stringBuilder: StringBuilder) {
            throw new Error("not yet implemented");
        }
        public constructor(literalLength: number, formattedCount: number, stringBuilder: StringBuilder, provider: IFormatProvider) {
            throw new Error("not yet implemented");
        }

        public AppendLiteral(value: string) {
            throw new Error("not yet implemented");
        }
        public AppendFormatted(value: T) {
            throw new Error("not yet implemented");
        }
        public AppendFormatted(value: T, format: string) {
            throw new Error("not yet implemented");
        }
        public AppendFormatted(value: T, alignment: number) {
            throw new Error("not yet implemented");
        }
        public AppendFormatted(value: T, alignment: number, format: string) {
            throw new Error("not yet implemented");
        }
        private AppendFormattedWithTempSpace(value: T, alignment: number, format: string) {
            throw new Error("not yet implemented");
        }
        public AppendFormatted(value: ReadOnlySpan<string>) {
            throw new Error("not yet implemented");
        }
        public AppendFormatted(value: ReadOnlySpan<string>, alignment: number, format: string) {
            throw new Error("not yet implemented");
        }
        public AppendFormatted(value: string) {
            throw new Error("not yet implemented");
        }
        public AppendFormatted(value: string, alignment: number, format: string) {
            throw new Error("not yet implemented");
        }
        public AppendFormatted(value: any, alignment: number, format: string) {
            throw new Error("not yet implemented");
        }
        private AppendCustomFormatter(value: T, format: string) {
            throw new Error("not yet implemented");
        }
    }
    export class CompositeFormat {
        private _segments: ValueTuple<string, number, number, string>[];
        private _literalLength: number;
        private _formattedCount: number;
        private _argsRequired: number;
        private __Format__k__BackingField: string;

        public get Format(): string {
            throw new Error("not yet implemented");
        }
        public get MinimumArgumentCount(): number {
            throw new Error("not yet implemented");
        }

        private constructor(format: string, segments: ValueTuple<string, number, number, string>[]) {
            throw new Error("not yet implemented");
        }

        public static Parse(format: string): CompositeFormat {
            throw new Error("not yet implemented");
        }
        private ValidateNumberOfArgs(numArgs: number) {
            throw new Error("not yet implemented");
        }
        private static TryParseLiterals(format: ReadOnlySpan<string>, segments: List<ValueTuple<string, number, number, string>>, ref failureOffset: number, ref failureReason: ExceptionResource): boolean {
            throw new Error("not yet implemented");
        }
        private static __TryParseLiterals__g__TryMoveNext_12_0(format: ReadOnlySpan<string>, ref pos: number, out nextChar: string): boolean {
            throw new Error("not yet implemented");
        }
    }
    export class StringBuilder implements ISerializable {
        private m_ChunkChars: string[];
        private m_ChunkPrevious: StringBuilder;
        private m_ChunkLength: number;
        private m_ChunkOffset: number;
        private m_MaxCapacity: number;

        public get Capacity(): number {
            throw new Error("not yet implemented");
        }
        public set Capacity(value: number) {
            throw new Error("not yet implemented");
        }
        public get MaxCapacity(): number {
            throw new Error("not yet implemented");
        }
        public get Length(): number {
            throw new Error("not yet implemented");
        }
        public set Length(value: number) {
            throw new Error("not yet implemented");
        }
        public get Chars(): string {
            throw new Error("not yet implemented");
        }
        public set Chars(index: number) {
            throw new Error("not yet implemented");
        }
        private get RemainingCurrentChunk(): Span<string> {
            throw new Error("not yet implemented");
        }

        public constructor() {
            throw new Error("not yet implemented");
        }
        public constructor(capacity: number) {
            throw new Error("not yet implemented");
        }
        public constructor(value: string) {
            throw new Error("not yet implemented");
        }
        public constructor(value: string, capacity: number) {
            throw new Error("not yet implemented");
        }
        public constructor(value: string, startIndex: number, length: number, capacity: number) {
            throw new Error("not yet implemented");
        }
        public constructor(capacity: number, maxCapacity: number) {
            throw new Error("not yet implemented");
        }
        private constructor(info: SerializationInfo, context: StreamingContext) {
            throw new Error("not yet implemented");
        }
        private constructor(from: StringBuilder) {
            throw new Error("not yet implemented");
        }
        private constructor(size: number, maxCapacity: number, previousBlock: StringBuilder) {
            throw new Error("not yet implemented");
        }

        private GetReplaceBufferCapacity(requiredCapacity: number): number {
            throw new Error("not yet implemented");
        }
        private ReplaceBufferInternal(newBuffer: string*, newLength: number) {
            throw new Error("not yet implemented");
        }
        private ReplaceBufferUtf8Internal(source: ReadOnlySpan<number>) {
            throw new Error("not yet implemented");
        }
        private ReplaceBufferAnsiInternal(newBuffer: number*, newLength: number) {
            throw new Error("not yet implemented");
        }
        private InternalCopy(dest: number, charLen: number) {
            throw new Error("not yet implemented");
        }
        private __explicit__ISerializable_GetObjectData(info: SerializationInfo, context: StreamingContext) {
            throw new Error("not yet implemented");
        }
        public GetObjectData(info: SerializationInfo, context: StreamingContext) {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        public EnsureCapacity(capacity: number): number {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
        public ToString(startIndex: number, length: number): string {
            throw new Error("not yet implemented");
        }
        public Clear(): StringBuilder {
            throw new Error("not yet implemented");
        }
        public GetChunks(): ChunkEnumerator {
            throw new Error("not yet implemented");
        }
        public Append(value: string, repeatCount: number): StringBuilder {
            throw new Error("not yet implemented");
        }
        private AppendWithExpansion(value: string, repeatCount: number) {
            throw new Error("not yet implemented");
        }
        public Append(value: string[], startIndex: number, charCount: number): StringBuilder {
            throw new Error("not yet implemented");
        }
        public Append(value: string): StringBuilder {
            throw new Error("not yet implemented");
        }
        public Append(value: string, startIndex: number, count: number): StringBuilder {
            throw new Error("not yet implemented");
        }
        public Append(value: StringBuilder): StringBuilder {
            throw new Error("not yet implemented");
        }
        public Append(value: StringBuilder, startIndex: number, count: number): StringBuilder {
            throw new Error("not yet implemented");
        }
        private AppendCore(value: StringBuilder, startIndex: number, count: number): StringBuilder {
            throw new Error("not yet implemented");
        }
        public AppendLine(): StringBuilder {
            throw new Error("not yet implemented");
        }
        public AppendLine(value: string): StringBuilder {
            throw new Error("not yet implemented");
        }
        public CopyTo(sourceIndex: number, destination: string[], destinationIndex: number, count: number) {
            throw new Error("not yet implemented");
        }
        public CopyTo(sourceIndex: number, destination: Span<string>, count: number) {
            throw new Error("not yet implemented");
        }
        public Insert(index: number, value: string, count: number): StringBuilder {
            throw new Error("not yet implemented");
        }
        private Insert(index: number, value: ReadOnlySpan<string>, count: number): StringBuilder {
            throw new Error("not yet implemented");
        }
        public Remove(startIndex: number, length: number): StringBuilder {
            throw new Error("not yet implemented");
        }
        public Append(value: boolean): StringBuilder {
            throw new Error("not yet implemented");
        }
        public Append(value: string): StringBuilder {
            throw new Error("not yet implemented");
        }
        private AppendWithExpansion(value: string) {
            throw new Error("not yet implemented");
        }
        public Append(value: number): StringBuilder {
            throw new Error("not yet implemented");
        }
        public Append(value: number): StringBuilder {
            throw new Error("not yet implemented");
        }
        public Append(value: number): StringBuilder {
            throw new Error("not yet implemented");
        }
        public Append(value: number): StringBuilder {
            throw new Error("not yet implemented");
        }
        public Append(value: number): StringBuilder {
            throw new Error("not yet implemented");
        }
        public Append(value: number): StringBuilder {
            throw new Error("not yet implemented");
        }
        public Append(value: number): StringBuilder {
            throw new Error("not yet implemented");
        }
        public Append(value: number): StringBuilder {
            throw new Error("not yet implemented");
        }
        public Append(value: number): StringBuilder {
            throw new Error("not yet implemented");
        }
        public Append(value: number): StringBuilder {
            throw new Error("not yet implemented");
        }
        public Append(value: number): StringBuilder {
            throw new Error("not yet implemented");
        }
        private AppendSpanFormattable(value: T): StringBuilder {
            throw new Error("not yet implemented");
        }
        public Append(value: any): StringBuilder {
            throw new Error("not yet implemented");
        }
        public Append(value: string[]): StringBuilder {
            throw new Error("not yet implemented");
        }
        public Append(value: ReadOnlySpan<string>): StringBuilder {
            throw new Error("not yet implemented");
        }
        public Append(value: ReadOnlyMemory<string>): StringBuilder {
            throw new Error("not yet implemented");
        }
        public Append(ref handler: AppendInterpolatedStringHandler): StringBuilder {
            throw new Error("not yet implemented");
        }
        public Append(provider: IFormatProvider, ref handler: AppendInterpolatedStringHandler): StringBuilder {
            throw new Error("not yet implemented");
        }
        public AppendLine(ref handler: AppendInterpolatedStringHandler): StringBuilder {
            throw new Error("not yet implemented");
        }
        public AppendLine(provider: IFormatProvider, ref handler: AppendInterpolatedStringHandler): StringBuilder {
            throw new Error("not yet implemented");
        }
        public AppendJoin(separator: string, values: any[]): StringBuilder {
            throw new Error("not yet implemented");
        }
        public AppendJoin(separator: string, values: IEnumerable<T>): StringBuilder {
            throw new Error("not yet implemented");
        }
        public AppendJoin(separator: string, values: string[]): StringBuilder {
            throw new Error("not yet implemented");
        }
        public AppendJoin(separator: string, values: any[]): StringBuilder {
            throw new Error("not yet implemented");
        }
        public AppendJoin(separator: string, values: IEnumerable<T>): StringBuilder {
            throw new Error("not yet implemented");
        }
        public AppendJoin(separator: string, values: string[]): StringBuilder {
            throw new Error("not yet implemented");
        }
        private AppendJoinCore(ref separator: string, separatorLength: number, values: IEnumerable<T>): StringBuilder {
            throw new Error("not yet implemented");
        }
        private AppendJoinCore(ref separator: string, separatorLength: number, values: T[]): StringBuilder {
            throw new Error("not yet implemented");
        }
        public Insert(index: number, value: string): StringBuilder {
            throw new Error("not yet implemented");
        }
        public Insert(index: number, value: boolean): StringBuilder {
            throw new Error("not yet implemented");
        }
        public Insert(index: number, value: number): StringBuilder {
            throw new Error("not yet implemented");
        }
        public Insert(index: number, value: number): StringBuilder {
            throw new Error("not yet implemented");
        }
        public Insert(index: number, value: number): StringBuilder {
            throw new Error("not yet implemented");
        }
        public Insert(index: number, value: string): StringBuilder {
            throw new Error("not yet implemented");
        }
        public Insert(index: number, value: string[]): StringBuilder {
            throw new Error("not yet implemented");
        }
        public Insert(index: number, value: string[], startIndex: number, charCount: number): StringBuilder {
            throw new Error("not yet implemented");
        }
        public Insert(index: number, value: number): StringBuilder {
            throw new Error("not yet implemented");
        }
        public Insert(index: number, value: number): StringBuilder {
            throw new Error("not yet implemented");
        }
        public Insert(index: number, value: number): StringBuilder {
            throw new Error("not yet implemented");
        }
        public Insert(index: number, value: number): StringBuilder {
            throw new Error("not yet implemented");
        }
        public Insert(index: number, value: number): StringBuilder {
            throw new Error("not yet implemented");
        }
        public Insert(index: number, value: number): StringBuilder {
            throw new Error("not yet implemented");
        }
        public Insert(index: number, value: number): StringBuilder {
            throw new Error("not yet implemented");
        }
        public Insert(index: number, value: number): StringBuilder {
            throw new Error("not yet implemented");
        }
        public Insert(index: number, value: any): StringBuilder {
            throw new Error("not yet implemented");
        }
        public Insert(index: number, value: ReadOnlySpan<string>): StringBuilder {
            throw new Error("not yet implemented");
        }
        private InsertSpanFormattable(index: number, value: T): StringBuilder {
            throw new Error("not yet implemented");
        }
        public AppendFormat(format: string, arg0: any): StringBuilder {
            throw new Error("not yet implemented");
        }
        public AppendFormat(format: string, arg0: any, arg1: any): StringBuilder {
            throw new Error("not yet implemented");
        }
        public AppendFormat(format: string, arg0: any, arg1: any, arg2: any): StringBuilder {
            throw new Error("not yet implemented");
        }
        public AppendFormat(format: string, args: any[]): StringBuilder {
            throw new Error("not yet implemented");
        }
        public AppendFormat(provider: IFormatProvider, format: string, arg0: any): StringBuilder {
            throw new Error("not yet implemented");
        }
        public AppendFormat(provider: IFormatProvider, format: string, arg0: any, arg1: any): StringBuilder {
            throw new Error("not yet implemented");
        }
        public AppendFormat(provider: IFormatProvider, format: string, arg0: any, arg1: any, arg2: any): StringBuilder {
            throw new Error("not yet implemented");
        }
        public AppendFormat(provider: IFormatProvider, format: string, args: any[]): StringBuilder {
            throw new Error("not yet implemented");
        }
        private AppendFormatHelper(provider: IFormatProvider, format: string, args: ReadOnlySpan<any>): StringBuilder {
            throw new Error("not yet implemented");
        }
        public AppendFormat(provider: IFormatProvider, format: CompositeFormat, arg0: TArg0): StringBuilder {
            throw new Error("not yet implemented");
        }
        public AppendFormat(provider: IFormatProvider, format: CompositeFormat, arg0: TArg0, arg1: TArg1): StringBuilder {
            throw new Error("not yet implemented");
        }
        public AppendFormat(provider: IFormatProvider, format: CompositeFormat, arg0: TArg0, arg1: TArg1, arg2: TArg2): StringBuilder {
            throw new Error("not yet implemented");
        }
        public AppendFormat(provider: IFormatProvider, format: CompositeFormat, args: any[]): StringBuilder {
            throw new Error("not yet implemented");
        }
        public AppendFormat(provider: IFormatProvider, format: CompositeFormat, args: ReadOnlySpan<any>): StringBuilder {
            throw new Error("not yet implemented");
        }
        private AppendFormat(provider: IFormatProvider, format: CompositeFormat, arg0: TArg0, arg1: TArg1, arg2: TArg2, args: ReadOnlySpan<any>): StringBuilder {
            throw new Error("not yet implemented");
        }
        public Replace(oldValue: string, newValue: string): StringBuilder {
            throw new Error("not yet implemented");
        }
        public Equals(sb: StringBuilder): boolean {
            throw new Error("not yet implemented");
        }
        public Equals(span: ReadOnlySpan<string>): boolean {
            throw new Error("not yet implemented");
        }
        public Replace(oldValue: string, newValue: string, startIndex: number, count: number): StringBuilder {
            throw new Error("not yet implemented");
        }
        public Replace(oldChar: string, newChar: string): StringBuilder {
            throw new Error("not yet implemented");
        }
        public Replace(oldChar: string, newChar: string, startIndex: number, count: number): StringBuilder {
            throw new Error("not yet implemented");
        }
        public Append(value: string*, valueCount: number): StringBuilder {
            throw new Error("not yet implemented");
        }
        private Append(ref value: string, valueCount: number) {
            throw new Error("not yet implemented");
        }
        private AppendWithExpansion(ref value: string, valueCount: number) {
            throw new Error("not yet implemented");
        }
        private Insert(index: number, ref value: string, valueCount: number) {
            throw new Error("not yet implemented");
        }
        private ReplaceAllInChunk(replacements: ReadOnlySpan<number>, sourceChunk: StringBuilder, removeCount: number, value: string) {
            throw new Error("not yet implemented");
        }
        private StartsWith(chunk: StringBuilder, indexInChunk: number, count: number, value: string): boolean {
            throw new Error("not yet implemented");
        }
        private ReplaceInPlaceAtChunk(ref chunk: StringBuilder, ref indexInChunk: number, ref value: string, count: number) {
            throw new Error("not yet implemented");
        }
        private FindChunkForIndex(index: number): StringBuilder {
            throw new Error("not yet implemented");
        }
        private Next(chunk: StringBuilder): StringBuilder {
            throw new Error("not yet implemented");
        }
        private ExpandByABlock(minBlockCharCount: number) {
            throw new Error("not yet implemented");
        }
        private MakeRoom(index: number, count: number, out chunk: StringBuilder, out indexInChunk: number, doNotMoveFollowingChars: boolean) {
            throw new Error("not yet implemented");
        }
        private Remove(startIndex: number, count: number, out chunk: StringBuilder, out indexInChunk: number) {
            throw new Error("not yet implemented");
        }
        private static __AppendFormatHelper__g__MoveNext_116_0(format: string, ref pos: number): string {
            throw new Error("not yet implemented");
        }
    }
    export namespace StringBuilder {
        export class ChunkEnumerator extends ValueType {
            private _firstChunk: StringBuilder;
            private _currentChunk: StringBuilder;
            private _manyChunks: ManyChunkInfo;

            public get Current(): ReadOnlyMemory<string> {
                throw new Error("not yet implemented");
            }

            protected constructor(stringBuilder: StringBuilder) {
                throw new Error("not yet implemented");
            }

            public GetEnumerator(): ChunkEnumerator {
                throw new Error("not yet implemented");
            }
            public MoveNext(): boolean {
                throw new Error("not yet implemented");
            }
            private static ChunkCount(stringBuilder: StringBuilder): number {
                throw new Error("not yet implemented");
            }
        }
        export namespace ChunkEnumerator {
            export class ManyChunkInfo {
                private _chunks: StringBuilder[];
                private _chunkPos: number;

                public constructor(stringBuilder: StringBuilder, chunkCount: number) {
                    throw new Error("not yet implemented");
                }

                public MoveNext(ref current: StringBuilder): boolean {
                    throw new Error("not yet implemented");
                }
            }
        }

        export class AppendInterpolatedStringHandler extends ValueType {
            private _stringBuilder: StringBuilder;
            private _provider: IFormatProvider;
            private _hasCustomFormatter: boolean;

            public constructor(literalLength: number, formattedCount: number, stringBuilder: StringBuilder) {
                throw new Error("not yet implemented");
            }
            public constructor(literalLength: number, formattedCount: number, stringBuilder: StringBuilder, provider: IFormatProvider) {
                throw new Error("not yet implemented");
            }

            public AppendLiteral(value: string) {
                throw new Error("not yet implemented");
            }
            public AppendFormatted(value: T) {
                throw new Error("not yet implemented");
            }
            public AppendFormatted(value: T, format: string) {
                throw new Error("not yet implemented");
            }
            public AppendFormatted(value: T, alignment: number) {
                throw new Error("not yet implemented");
            }
            public AppendFormatted(value: T, alignment: number, format: string) {
                throw new Error("not yet implemented");
            }
            private AppendFormattedWithTempSpace(value: T, alignment: number, format: string) {
                throw new Error("not yet implemented");
            }
            public AppendFormatted(value: ReadOnlySpan<string>) {
                throw new Error("not yet implemented");
            }
            public AppendFormatted(value: ReadOnlySpan<string>, alignment: number, format: string) {
                throw new Error("not yet implemented");
            }
            public AppendFormatted(value: string) {
                throw new Error("not yet implemented");
            }
            public AppendFormatted(value: string, alignment: number, format: string) {
                throw new Error("not yet implemented");
            }
            public AppendFormatted(value: any, alignment: number, format: string) {
                throw new Error("not yet implemented");
            }
            private AppendCustomFormatter(value: T, format: string) {
                throw new Error("not yet implemented");
            }
        }
    }
    export class Rune extends ValueType implements IComparable, IComparable<Rune>, IEquatable<Rune>, ISpanFormattable, IFormattable, IUtf8SpanFormattable {
        private static get AsciiCharInfo(): ReadOnlySpan<number> {
            throw new Error("not yet implemented");
        }
        public static get ReplacementChar(): Rune {
            throw new Error("not yet implemented");
        }

        private _value: number;

        private get DebuggerDisplay(): string {
            throw new Error("not yet implemented");
        }
        public get IsAscii(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsBmp(): boolean {
            throw new Error("not yet implemented");
        }
        public get Plane(): number {
            throw new Error("not yet implemented");
        }
        public get Utf16SequenceLength(): number {
            throw new Error("not yet implemented");
        }
        public get Utf8SequenceLength(): number {
            throw new Error("not yet implemented");
        }
        public get Value(): number {
            throw new Error("not yet implemented");
        }

        public constructor(ch: string) {
            throw new Error("not yet implemented");
        }
        public constructor(highSurrogate: string, lowSurrogate: string) {
            throw new Error("not yet implemented");
        }
        public constructor(value: number) {
            throw new Error("not yet implemented");
        }
        public constructor(value: number) {
            throw new Error("not yet implemented");
        }
        private constructor(scalarValue: number, _: boolean) {
            throw new Error("not yet implemented");
        }

        private static ChangeCaseCultureAware(rune: Rune, textInfo: TextInfo, toUpper: boolean): Rune {
            throw new Error("not yet implemented");
        }
        public CompareTo(other: Rune): number {
            throw new Error("not yet implemented");
        }
        public static DecodeFromUtf16(source: ReadOnlySpan<string>, out result: Rune, out charsConsumed: number): OperationStatus {
            throw new Error("not yet implemented");
        }
        public static DecodeFromUtf8(source: ReadOnlySpan<number>, out result: Rune, out bytesConsumed: number): OperationStatus {
            throw new Error("not yet implemented");
        }
        public static DecodeLastFromUtf16(source: ReadOnlySpan<string>, out result: Rune, out charsConsumed: number): OperationStatus {
            throw new Error("not yet implemented");
        }
        public static DecodeLastFromUtf8(source: ReadOnlySpan<number>, out value: Rune, out bytesConsumed: number): OperationStatus {
            throw new Error("not yet implemented");
        }
        public EncodeToUtf16(destination: Span<string>): number {
            throw new Error("not yet implemented");
        }
        public EncodeToUtf8(destination: Span<number>): number {
            throw new Error("not yet implemented");
        }
        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public Equals(other: Rune): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public static GetRuneAt(input: string, index: number): Rune {
            throw new Error("not yet implemented");
        }
        public static IsValid(value: number): boolean {
            throw new Error("not yet implemented");
        }
        public static IsValid(value: number): boolean {
            throw new Error("not yet implemented");
        }
        private static ReadFirstRuneFromUtf16Buffer(input: ReadOnlySpan<string>): number {
            throw new Error("not yet implemented");
        }
        private static ReadRuneFromString(input: string, index: number): number {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
        private __explicit__ISpanFormattable_TryFormat(destination: Span<string>, out charsWritten: number, format: ReadOnlySpan<string>, provider: IFormatProvider): boolean {
            throw new Error("not yet implemented");
        }
        public TryFormat(destination: Span<string>, out charsWritten: number, format: ReadOnlySpan<string>, provider: IFormatProvider): boolean {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__IUtf8SpanFormattable_TryFormat(utf8Destination: Span<number>, out bytesWritten: number, format: ReadOnlySpan<string>, provider: IFormatProvider): boolean {
            throw new Error("not yet implemented");
        }
        public TryFormat(utf8Destination: Span<number>, out bytesWritten: number, format: ReadOnlySpan<string>, provider: IFormatProvider): boolean {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private __explicit__IFormattable_ToString(format: string, formatProvider: IFormatProvider): string {
            throw new Error("not yet implemented");
        }
        public static TryCreate(ch: string, out result: Rune): boolean {
            throw new Error("not yet implemented");
        }
        public static TryCreate(highSurrogate: string, lowSurrogate: string, out result: Rune): boolean {
            throw new Error("not yet implemented");
        }
        public static TryCreate(value: number, out result: Rune): boolean {
            throw new Error("not yet implemented");
        }
        public static TryCreate(value: number, out result: Rune): boolean {
            throw new Error("not yet implemented");
        }
        public TryEncodeToUtf16(destination: Span<string>, out charsWritten: number): boolean {
            throw new Error("not yet implemented");
        }
        private static TryEncodeToUtf16(value: Rune, destination: Span<string>, out charsWritten: number): boolean {
            throw new Error("not yet implemented");
        }
        public TryEncodeToUtf8(destination: Span<number>, out bytesWritten: number): boolean {
            throw new Error("not yet implemented");
        }
        private static TryEncodeToUtf8(value: Rune, destination: Span<number>, out bytesWritten: number): boolean {
            throw new Error("not yet implemented");
        }
        public static TryGetRuneAt(input: string, index: number, out value: Rune): boolean {
            throw new Error("not yet implemented");
        }
        private static UnsafeCreate(scalarValue: number): Rune {
            throw new Error("not yet implemented");
        }
        public static GetNumericValue(value: Rune): number {
            throw new Error("not yet implemented");
        }
        public static GetUnicodeCategory(value: Rune): UnicodeCategory {
            throw new Error("not yet implemented");
        }
        private static GetUnicodeCategoryNonAscii(value: Rune): UnicodeCategory {
            throw new Error("not yet implemented");
        }
        private static IsCategoryLetter(category: UnicodeCategory): boolean {
            throw new Error("not yet implemented");
        }
        private static IsCategoryLetterOrDecimalDigit(category: UnicodeCategory): boolean {
            throw new Error("not yet implemented");
        }
        private static IsCategoryNumber(category: UnicodeCategory): boolean {
            throw new Error("not yet implemented");
        }
        private static IsCategoryPunctuation(category: UnicodeCategory): boolean {
            throw new Error("not yet implemented");
        }
        private static IsCategorySeparator(category: UnicodeCategory): boolean {
            throw new Error("not yet implemented");
        }
        private static IsCategorySymbol(category: UnicodeCategory): boolean {
            throw new Error("not yet implemented");
        }
        public static IsControl(value: Rune): boolean {
            throw new Error("not yet implemented");
        }
        public static IsDigit(value: Rune): boolean {
            throw new Error("not yet implemented");
        }
        public static IsLetter(value: Rune): boolean {
            throw new Error("not yet implemented");
        }
        public static IsLetterOrDigit(value: Rune): boolean {
            throw new Error("not yet implemented");
        }
        public static IsLower(value: Rune): boolean {
            throw new Error("not yet implemented");
        }
        public static IsNumber(value: Rune): boolean {
            throw new Error("not yet implemented");
        }
        public static IsPunctuation(value: Rune): boolean {
            throw new Error("not yet implemented");
        }
        public static IsSeparator(value: Rune): boolean {
            throw new Error("not yet implemented");
        }
        public static IsSymbol(value: Rune): boolean {
            throw new Error("not yet implemented");
        }
        public static IsUpper(value: Rune): boolean {
            throw new Error("not yet implemented");
        }
        public static IsWhiteSpace(value: Rune): boolean {
            throw new Error("not yet implemented");
        }
        public static ToLower(value: Rune, culture: CultureInfo): Rune {
            throw new Error("not yet implemented");
        }
        public static ToLowerInvariant(value: Rune): Rune {
            throw new Error("not yet implemented");
        }
        public static ToUpper(value: Rune, culture: CultureInfo): Rune {
            throw new Error("not yet implemented");
        }
        public static ToUpperInvariant(value: Rune): Rune {
            throw new Error("not yet implemented");
        }
        private __explicit__IComparable_CompareTo(obj: any): number {
            throw new Error("not yet implemented");
        }
    }
    export class CodePageDataItem {
        private __UIFamilyCodePage__k__BackingField: number;
        private __WebName__k__BackingField: string;
        private __HeaderName__k__BackingField: string;
        private __BodyName__k__BackingField: string;
        private __DisplayName__k__BackingField: string;
        private __Flags__k__BackingField: number;

        public get UIFamilyCodePage(): number {
            throw new Error("not yet implemented");
        }
        public get WebName(): string {
            throw new Error("not yet implemented");
        }
        public get HeaderName(): string {
            throw new Error("not yet implemented");
        }
        public get BodyName(): string {
            throw new Error("not yet implemented");
        }
        public get DisplayName(): string {
            throw new Error("not yet implemented");
        }
        public get Flags(): number {
            throw new Error("not yet implemented");
        }

        protected constructor(uiFamilyCodePage: number, webName: string, headerName: string, bodyName: string, displayName: string, flags: number) {
            throw new Error("not yet implemented");
        }

    }
    export abstract class Encoder {
        private _fallback: EncoderFallback;
        private _fallbackBuffer: EncoderFallbackBuffer;

        public get Fallback(): EncoderFallback {
            throw new Error("not yet implemented");
        }
        public set Fallback(value: EncoderFallback) {
            throw new Error("not yet implemented");
        }
        public get FallbackBuffer(): EncoderFallbackBuffer {
            throw new Error("not yet implemented");
        }
        private get InternalHasFallbackBuffer(): boolean {
            throw new Error("not yet implemented");
        }

        protected constructor() {
            throw new Error("not yet implemented");
        }

        public Reset() {
            throw new Error("not yet implemented");
        }
        public GetByteCount(chars: string[], index: number, count: number, flush: boolean): number;
        public GetByteCount(chars: string*, count: number, flush: boolean): number {
            throw new Error("not yet implemented");
        }
        public GetByteCount(chars: ReadOnlySpan<string>, flush: boolean): number {
            throw new Error("not yet implemented");
        }
        public GetBytes(chars: string[], charIndex: number, charCount: number, bytes: number[], byteIndex: number, flush: boolean): number;
        public GetBytes(chars: string*, charCount: number, bytes: number*, byteCount: number, flush: boolean): number {
            throw new Error("not yet implemented");
        }
        public GetBytes(chars: ReadOnlySpan<string>, bytes: Span<number>, flush: boolean): number {
            throw new Error("not yet implemented");
        }
        public Convert(chars: string[], charIndex: number, charCount: number, bytes: number[], byteIndex: number, byteCount: number, flush: boolean, out charsUsed: number, out bytesUsed: number, out completed: boolean) {
            throw new Error("not yet implemented");
        }
        public Convert(chars: string*, charCount: number, bytes: number*, byteCount: number, flush: boolean, out charsUsed: number, out bytesUsed: number, out completed: boolean) {
            throw new Error("not yet implemented");
        }
        public Convert(chars: ReadOnlySpan<string>, bytes: Span<number>, flush: boolean, out charsUsed: number, out bytesUsed: number, out completed: boolean) {
            throw new Error("not yet implemented");
        }
    }
    export class EncoderNLS extends Encoder {
        private _charLeftOver: string;
        private _encoding: Encoding;
        private _mustFlush: boolean;
        private _throwOnOverflow: boolean;
        private _charsUsed: number;

        public get Encoding(): Encoding {
            throw new Error("not yet implemented");
        }
        public get MustFlush(): boolean {
            throw new Error("not yet implemented");
        }
        private get HasLeftoverData(): boolean {
            throw new Error("not yet implemented");
        }
        private get HasState(): boolean {
            throw new Error("not yet implemented");
        }

        protected constructor(encoding: Encoding) {
            throw new Error("not yet implemented");
        }

        public Reset() {
            throw new Error("not yet implemented");
        }
        public GetByteCount(chars: string[], index: number, count: number, flush: boolean): number {
            throw new Error("not yet implemented");
        }
        public GetByteCount(chars: string*, count: number, flush: boolean): number {
            throw new Error("not yet implemented");
        }
        public GetBytes(chars: string[], charIndex: number, charCount: number, bytes: number[], byteIndex: number, flush: boolean): number {
            throw new Error("not yet implemented");
        }
        public GetBytes(chars: string*, charCount: number, bytes: number*, byteCount: number, flush: boolean): number {
            throw new Error("not yet implemented");
        }
        public Convert(chars: string[], charIndex: number, charCount: number, bytes: number[], byteIndex: number, byteCount: number, flush: boolean, out charsUsed: number, out bytesUsed: number, out completed: boolean) {
            throw new Error("not yet implemented");
        }
        public Convert(chars: string*, charCount: number, bytes: number*, byteCount: number, flush: boolean, out charsUsed: number, out bytesUsed: number, out completed: boolean) {
            throw new Error("not yet implemented");
        }
        private ClearMustFlush() {
            throw new Error("not yet implemented");
        }
        private DrainLeftoverDataForGetByteCount(chars: ReadOnlySpan<string>, out charsConsumed: number): number {
            throw new Error("not yet implemented");
        }
        private TryDrainLeftoverDataForGetBytes(chars: ReadOnlySpan<string>, bytes: Span<number>, out charsConsumed: number, out bytesWritten: number): boolean {
            throw new Error("not yet implemented");
        }
    }
    export abstract class EncoderFallbackBuffer {
        private charStart: string*;
        private charEnd: string*;
        private encoder: EncoderNLS;
        private setEncoder: boolean;
        private bUsedEncoder: boolean;
        private bFallingBack: boolean;
        private iRecursionCount: number;
        private encoding: Encoding;
        private originalCharCount: number;

        public get Remaining(): number;

        protected constructor() {
            throw new Error("not yet implemented");
        }

        public Fallback(charUnknown: string, index: number): boolean;
        public Fallback(charUnknownHigh: string, charUnknownLow: string, index: number): boolean;
        public GetNextChar(): string;
        public MovePrevious(): boolean;
        public Reset() {
            throw new Error("not yet implemented");
        }
        private InternalReset() {
            throw new Error("not yet implemented");
        }
        private InternalInitialize(charStart: string*, charEnd: string*, encoder: EncoderNLS, setEncoder: boolean) {
            throw new Error("not yet implemented");
        }
        private static CreateAndInitialize(encoding: Encoding, encoder: EncoderNLS, originalCharCount: number): EncoderFallbackBuffer {
            throw new Error("not yet implemented");
        }
        private InternalGetNextChar(): string {
            throw new Error("not yet implemented");
        }
        private InternalFallback(chars: ReadOnlySpan<string>, out charsConsumed: number): boolean {
            throw new Error("not yet implemented");
        }
        private InternalFallbackGetByteCount(chars: ReadOnlySpan<string>, out charsConsumed: number): number {
            throw new Error("not yet implemented");
        }
        private TryInternalFallbackGetBytes(chars: ReadOnlySpan<string>, bytes: Span<number>, out charsConsumed: number, out bytesWritten: number): boolean {
            throw new Error("not yet implemented");
        }
        private TryDrainRemainingDataForGetBytes(bytes: Span<number>, out bytesWritten: number): boolean {
            throw new Error("not yet implemented");
        }
        private DrainRemainingDataForGetByteCount(): number {
            throw new Error("not yet implemented");
        }
        private GetNextRune(): Rune {
            throw new Error("not yet implemented");
        }
        private InternalFallback(ch: string, ref chars: Char*): boolean {
            throw new Error("not yet implemented");
        }
        private static ThrowLastCharRecursive(charRecursive: number) {
            throw new Error("not yet implemented");
        }
    }
    export abstract class EncoderFallback {
        public static get ReplacementFallback(): EncoderFallback {
            throw new Error("not yet implemented");
        }
        public static get ExceptionFallback(): EncoderFallback {
            throw new Error("not yet implemented");
        }

        public get MaxCharCount(): number;

        protected constructor() {
            throw new Error("not yet implemented");
        }

        public CreateFallbackBuffer(): EncoderFallbackBuffer;
    }
    export abstract class Decoder {
        private _fallback: DecoderFallback;
        private _fallbackBuffer: DecoderFallbackBuffer;

        public get Fallback(): DecoderFallback {
            throw new Error("not yet implemented");
        }
        public set Fallback(value: DecoderFallback) {
            throw new Error("not yet implemented");
        }
        public get FallbackBuffer(): DecoderFallbackBuffer {
            throw new Error("not yet implemented");
        }
        private get InternalHasFallbackBuffer(): boolean {
            throw new Error("not yet implemented");
        }

        protected constructor() {
            throw new Error("not yet implemented");
        }

        public Reset() {
            throw new Error("not yet implemented");
        }
        public GetCharCount(bytes: number[], index: number, count: number): number;
        public GetCharCount(bytes: number[], index: number, count: number, flush: boolean): number {
            throw new Error("not yet implemented");
        }
        public GetCharCount(bytes: number*, count: number, flush: boolean): number {
            throw new Error("not yet implemented");
        }
        public GetCharCount(bytes: ReadOnlySpan<number>, flush: boolean): number {
            throw new Error("not yet implemented");
        }
        public GetChars(bytes: number[], byteIndex: number, byteCount: number, chars: string[], charIndex: number): number;
        public GetChars(bytes: number[], byteIndex: number, byteCount: number, chars: string[], charIndex: number, flush: boolean): number {
            throw new Error("not yet implemented");
        }
        public GetChars(bytes: number*, byteCount: number, chars: string*, charCount: number, flush: boolean): number {
            throw new Error("not yet implemented");
        }
        public GetChars(bytes: ReadOnlySpan<number>, chars: Span<string>, flush: boolean): number {
            throw new Error("not yet implemented");
        }
        public Convert(bytes: number[], byteIndex: number, byteCount: number, chars: string[], charIndex: number, charCount: number, flush: boolean, out bytesUsed: number, out charsUsed: number, out completed: boolean) {
            throw new Error("not yet implemented");
        }
        public Convert(bytes: number*, byteCount: number, chars: string*, charCount: number, flush: boolean, out bytesUsed: number, out charsUsed: number, out completed: boolean) {
            throw new Error("not yet implemented");
        }
        public Convert(bytes: ReadOnlySpan<number>, chars: Span<string>, flush: boolean, out bytesUsed: number, out charsUsed: number, out completed: boolean) {
            throw new Error("not yet implemented");
        }
    }
    export class DecoderNLS extends Decoder {
        private _encoding: Encoding;
        private _mustFlush: boolean;
        private _throwOnOverflow: boolean;
        private _bytesUsed: number;
        private _leftoverBytes: number;
        private _leftoverByteCount: number;

        public get MustFlush(): boolean {
            throw new Error("not yet implemented");
        }
        private get HasState(): boolean {
            throw new Error("not yet implemented");
        }
        private get HasLeftoverData(): boolean {
            throw new Error("not yet implemented");
        }

        protected constructor(encoding: Encoding) {
            throw new Error("not yet implemented");
        }

        public Reset() {
            throw new Error("not yet implemented");
        }
        public GetCharCount(bytes: number[], index: number, count: number): number {
            throw new Error("not yet implemented");
        }
        public GetCharCount(bytes: number[], index: number, count: number, flush: boolean): number {
            throw new Error("not yet implemented");
        }
        public GetCharCount(bytes: number*, count: number, flush: boolean): number {
            throw new Error("not yet implemented");
        }
        public GetChars(bytes: number[], byteIndex: number, byteCount: number, chars: string[], charIndex: number): number {
            throw new Error("not yet implemented");
        }
        public GetChars(bytes: number[], byteIndex: number, byteCount: number, chars: string[], charIndex: number, flush: boolean): number {
            throw new Error("not yet implemented");
        }
        public GetChars(bytes: number*, byteCount: number, chars: string*, charCount: number, flush: boolean): number {
            throw new Error("not yet implemented");
        }
        public Convert(bytes: number[], byteIndex: number, byteCount: number, chars: string[], charIndex: number, charCount: number, flush: boolean, out bytesUsed: number, out charsUsed: number, out completed: boolean) {
            throw new Error("not yet implemented");
        }
        public Convert(bytes: number*, byteCount: number, chars: string*, charCount: number, flush: boolean, out bytesUsed: number, out charsUsed: number, out completed: boolean) {
            throw new Error("not yet implemented");
        }
        private ClearMustFlush() {
            throw new Error("not yet implemented");
        }
        private GetLeftoverData(): ReadOnlySpan<number> {
            throw new Error("not yet implemented");
        }
        private SetLeftoverData(bytes: ReadOnlySpan<number>) {
            throw new Error("not yet implemented");
        }
        private ClearLeftoverData() {
            throw new Error("not yet implemented");
        }
        private DrainLeftoverDataForGetCharCount(bytes: ReadOnlySpan<number>, out bytesConsumed: number): number {
            throw new Error("not yet implemented");
        }
        private DrainLeftoverDataForGetChars(bytes: ReadOnlySpan<number>, chars: Span<string>, out bytesConsumed: number): number {
            throw new Error("not yet implemented");
        }
        private static ConcatInto(srcLeft: ReadOnlySpan<number>, srcRight: ReadOnlySpan<number>, dest: Span<number>): number {
            throw new Error("not yet implemented");
        }
    }
    export abstract class DecoderFallbackBuffer {
        private byteStart: number*;
        private charEnd: string*;
        private _encoding: Encoding;
        private _decoder: DecoderNLS;
        private _originalByteCount: number;

        public get Remaining(): number;

        protected constructor() {
            throw new Error("not yet implemented");
        }

        public Fallback(bytesUnknown: number[], index: number): boolean;
        public GetNextChar(): string;
        public MovePrevious(): boolean;
        public Reset() {
            throw new Error("not yet implemented");
        }
        private InternalReset() {
            throw new Error("not yet implemented");
        }
        private InternalInitialize(byteStart: number*, charEnd: string*) {
            throw new Error("not yet implemented");
        }
        private static CreateAndInitialize(encoding: Encoding, decoder: DecoderNLS, originalByteCount: number): DecoderFallbackBuffer {
            throw new Error("not yet implemented");
        }
        private InternalFallback(bytes: number[], pBytes: number*, ref chars: Char*): boolean {
            throw new Error("not yet implemented");
        }
        private InternalFallback(bytes: number[], pBytes: number*): number {
            throw new Error("not yet implemented");
        }
        private InternalFallbackGetCharCount(remainingBytes: ReadOnlySpan<number>, fallbackLength: number): number {
            throw new Error("not yet implemented");
        }
        private TryInternalFallbackGetChars(remainingBytes: ReadOnlySpan<number>, fallbackLength: number, chars: Span<string>, out charsWritten: number): boolean {
            throw new Error("not yet implemented");
        }
        private GetNextRune(): Rune {
            throw new Error("not yet implemented");
        }
        private DrainRemainingDataForGetCharCount(): number {
            throw new Error("not yet implemented");
        }
        private TryDrainRemainingDataForGetChars(chars: Span<string>, out charsWritten: number): boolean {
            throw new Error("not yet implemented");
        }
        private static ThrowLastBytesRecursive(bytesUnknown: number[]) {
            throw new Error("not yet implemented");
        }
    }
    export abstract class DecoderFallback {
        public static get ReplacementFallback(): DecoderFallback {
            throw new Error("not yet implemented");
        }
        public static get ExceptionFallback(): DecoderFallback {
            throw new Error("not yet implemented");
        }

        public get MaxCharCount(): number;

        protected constructor() {
            throw new Error("not yet implemented");
        }

        public CreateFallbackBuffer(): DecoderFallbackBuffer;
    }
    export class UTF8Encoding extends Encoding implements ICloneable {
        private static readonly s_default: UTF8EncodingSealed;

        private static get PreambleSpan(): ReadOnlySpan<number> {
            throw new Error("not yet implemented");
        }

        private _emitUTF8Identifier: boolean;
        private _isThrowException: boolean;

        public get Preamble(): ReadOnlySpan<number> {
            throw new Error("not yet implemented");
        }

        public constructor() {
            throw new Error("not yet implemented");
        }
        public constructor(encoderShouldEmitUTF8Identifier: boolean) {
            throw new Error("not yet implemented");
        }
        public constructor(encoderShouldEmitUTF8Identifier: boolean, throwOnInvalidBytes: boolean) {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

        private SetDefaultFallbacks() {
            throw new Error("not yet implemented");
        }
        public GetByteCount(chars: string[], index: number, count: number): number {
            throw new Error("not yet implemented");
        }
        public GetByteCount(chars: string): number {
            throw new Error("not yet implemented");
        }
        public GetByteCount(chars: string*, count: number): number {
            throw new Error("not yet implemented");
        }
        public GetByteCount(chars: ReadOnlySpan<string>): number {
            throw new Error("not yet implemented");
        }
        private GetByteCountCommon(pChars: string*, charCount: number): number {
            throw new Error("not yet implemented");
        }
        private GetByteCountFast(pChars: string*, charsLength: number, fallback: EncoderFallback, out charsConsumed: number): number {
            throw new Error("not yet implemented");
        }
        public GetBytes(s: string, charIndex: number, charCount: number, bytes: number[], byteIndex: number): number {
            throw new Error("not yet implemented");
        }
        public GetBytes(chars: string[], charIndex: number, charCount: number, bytes: number[], byteIndex: number): number {
            throw new Error("not yet implemented");
        }
        public GetBytes(chars: string*, charCount: number, bytes: number*, byteCount: number): number {
            throw new Error("not yet implemented");
        }
        public GetBytes(chars: ReadOnlySpan<string>, bytes: Span<number>): number {
            throw new Error("not yet implemented");
        }
        public TryGetBytes(chars: ReadOnlySpan<string>, bytes: Span<number>, out bytesWritten: number): boolean {
            throw new Error("not yet implemented");
        }
        private GetBytesCommon(pChars: string*, charCount: number, pBytes: number*, byteCount: number, throwForDestinationOverflow: boolean): number {
            throw new Error("not yet implemented");
        }
        private GetBytesFast(pChars: string*, charsLength: number, pBytes: number*, bytesLength: number, out charsConsumed: number): number {
            throw new Error("not yet implemented");
        }
        public GetCharCount(bytes: number[], index: number, count: number): number {
            throw new Error("not yet implemented");
        }
        public GetCharCount(bytes: number*, count: number): number {
            throw new Error("not yet implemented");
        }
        public GetCharCount(bytes: ReadOnlySpan<number>): number {
            throw new Error("not yet implemented");
        }
        public GetChars(bytes: number[], byteIndex: number, byteCount: number, chars: string[], charIndex: number): number {
            throw new Error("not yet implemented");
        }
        public GetChars(bytes: number*, byteCount: number, chars: string*, charCount: number): number {
            throw new Error("not yet implemented");
        }
        public GetChars(bytes: ReadOnlySpan<number>, chars: Span<string>): number {
            throw new Error("not yet implemented");
        }
        public TryGetChars(bytes: ReadOnlySpan<number>, chars: Span<string>, out charsWritten: number): boolean {
            throw new Error("not yet implemented");
        }
        private GetCharsCommon(pBytes: number*, byteCount: number, pChars: string*, charCount: number, throwForDestinationOverflow: boolean): number {
            throw new Error("not yet implemented");
        }
        private GetCharsFast(pBytes: number*, bytesLength: number, pChars: string*, charsLength: number, out bytesConsumed: number): number {
            throw new Error("not yet implemented");
        }
        private GetCharsWithFallback(bytes: ReadOnlySpan<number>, originalBytesLength: number, chars: Span<string>, originalCharsLength: number, decoder: DecoderNLS, throwForDestinationOverflow: boolean): number {
            throw new Error("not yet implemented");
        }
        public GetString(bytes: number[], index: number, count: number): string {
            throw new Error("not yet implemented");
        }
        private GetCharCountCommon(pBytes: number*, byteCount: number): number {
            throw new Error("not yet implemented");
        }
        private GetCharCountFast(pBytes: number*, bytesLength: number, fallback: DecoderFallback, out bytesConsumed: number): number {
            throw new Error("not yet implemented");
        }
        public GetDecoder(): Decoder {
            throw new Error("not yet implemented");
        }
        public GetEncoder(): Encoder {
            throw new Error("not yet implemented");
        }
        private TryGetByteCount(value: Rune, out byteCount: number): boolean {
            throw new Error("not yet implemented");
        }
        private EncodeRune(value: Rune, bytes: Span<number>, out bytesWritten: number): OperationStatus {
            throw new Error("not yet implemented");
        }
        private DecodeFirstRune(bytes: ReadOnlySpan<number>, out value: Rune, out bytesConsumed: number): OperationStatus {
            throw new Error("not yet implemented");
        }
        public GetMaxByteCount(charCount: number): number {
            throw new Error("not yet implemented");
        }
        public GetMaxCharCount(byteCount: number): number {
            throw new Error("not yet implemented");
        }
        public GetPreamble(): number[] {
            throw new Error("not yet implemented");
        }
        public Equals(value: any): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
    }
    export namespace UTF8Encoding {
        export class UTF8EncodingSealed extends UTF8Encoding implements ICloneable {
            public get Preamble(): ReadOnlySpan<number> {
                throw new Error("not yet implemented");
            }

            public constructor(encoderShouldEmitUTF8Identifier: boolean) {
                throw new Error("not yet implemented");
            }

            public Clone(): any {
                throw new Error("not yet implemented");
            }
            public GetBytes(s: string): number[] {
                throw new Error("not yet implemented");
            }
            private GetBytesForSmallInput(s: string): number[] {
                throw new Error("not yet implemented");
            }
            public GetMaxByteCount(charCount: number): number {
                throw new Error("not yet implemented");
            }
            public GetMaxCharCount(byteCount: number): number {
                throw new Error("not yet implemented");
            }
            public GetString(bytes: number[]): string {
                throw new Error("not yet implemented");
            }
            private GetStringForSmallInput(bytes: number[]): string {
                throw new Error("not yet implemented");
            }
            public TryGetBytes(chars: ReadOnlySpan<string>, bytes: Span<number>, out bytesWritten: number): boolean {
                throw new Error("not yet implemented");
            }
            private static ReadUtf8(ref input: string, inputLength: number, ref output: number, outputLength: number): number {
                throw new Error("not yet implemented");
            }
            private static __GetMaxByteCount__g__ThrowArgumentException_7_0(charCount: number) {
                throw new Error("not yet implemented");
            }
            private static __GetMaxCharCount__g__ThrowArgumentException_8_0(byteCount: number) {
                throw new Error("not yet implemented");
            }
        }
    }
    export class UTF8EncodingSealed extends UTF8Encoding implements ICloneable {
        public get Preamble(): ReadOnlySpan<number> {
            throw new Error("not yet implemented");
        }

        public constructor(encoderShouldEmitUTF8Identifier: boolean) {
            throw new Error("not yet implemented");
        }

        public Clone(): any {
            throw new Error("not yet implemented");
        }
        public GetBytes(s: string): number[] {
            throw new Error("not yet implemented");
        }
        private GetBytesForSmallInput(s: string): number[] {
            throw new Error("not yet implemented");
        }
        public GetMaxByteCount(charCount: number): number {
            throw new Error("not yet implemented");
        }
        public GetMaxCharCount(byteCount: number): number {
            throw new Error("not yet implemented");
        }
        public GetString(bytes: number[]): string {
            throw new Error("not yet implemented");
        }
        private GetStringForSmallInput(bytes: number[]): string {
            throw new Error("not yet implemented");
        }
        public TryGetBytes(chars: ReadOnlySpan<string>, bytes: Span<number>, out bytesWritten: number): boolean {
            throw new Error("not yet implemented");
        }
        private static ReadUtf8(ref input: string, inputLength: number, ref output: number, outputLength: number): number {
            throw new Error("not yet implemented");
        }
        private static __GetMaxByteCount__g__ThrowArgumentException_7_0(charCount: number) {
            throw new Error("not yet implemented");
        }
        private static __GetMaxCharCount__g__ThrowArgumentException_8_0(byteCount: number) {
            throw new Error("not yet implemented");
        }
    }
    export abstract class EncodingProvider {
        private static s_providers: EncodingProvider[];

        public constructor() {
            throw new Error("not yet implemented");
        }

        public GetEncoding(name: string): Encoding;
        public GetEncoding(codepage: number): Encoding;
        public GetEncoding(name: string, encoderFallback: EncoderFallback, decoderFallback: DecoderFallback): Encoding {
            throw new Error("not yet implemented");
        }
        public GetEncoding(codepage: number, encoderFallback: EncoderFallback, decoderFallback: DecoderFallback): Encoding {
            throw new Error("not yet implemented");
        }
        public GetEncodings(): IEnumerable<EncodingInfo> {
            throw new Error("not yet implemented");
        }
        private static AddProvider(provider: EncodingProvider) {
            throw new Error("not yet implemented");
        }
        private static GetEncodingFromProvider(codepage: number): Encoding {
            throw new Error("not yet implemented");
        }
        private static GetEncodingListFromProviders(): Dictionary<number, EncodingInfo> {
            throw new Error("not yet implemented");
        }
        private static GetEncodingFromProvider(encodingName: string): Encoding {
            throw new Error("not yet implemented");
        }
        private static GetEncodingFromProvider(codepage: number, enc: EncoderFallback, dec: DecoderFallback): Encoding {
            throw new Error("not yet implemented");
        }
        private static GetEncodingFromProvider(encodingName: string, enc: EncoderFallback, dec: DecoderFallback): Encoding {
            throw new Error("not yet implemented");
        }
    }
    export class EncodingInfo {
        private __CodePage__k__BackingField: number;
        private __Name__k__BackingField: string;
        private __DisplayName__k__BackingField: string;
        private __Provider__k__BackingField: EncodingProvider;

        public get CodePage(): number {
            throw new Error("not yet implemented");
        }
        public get Name(): string {
            throw new Error("not yet implemented");
        }
        public get DisplayName(): string {
            throw new Error("not yet implemented");
        }
        private get Provider(): EncodingProvider {
            throw new Error("not yet implemented");
        }

        public constructor(provider: EncodingProvider, codePage: number, name: string, displayName: string) {
            throw new Error("not yet implemented");
        }
        protected constructor(codePage: number, name: string, displayName: string) {
            throw new Error("not yet implemented");
        }

        public GetEncoding(): Encoding {
            throw new Error("not yet implemented");
        }
        public Equals(value: any): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
    }
    export enum NormalizationForm {
        FormC = 1,
        FormD = 2,
        FormKC = 5,
        FormKD = 6,
    }
    export abstract class Encoding implements ICloneable {
        private static readonly s_defaultEncoding: UTF8EncodingSealed;

        public static get Default(): Encoding {
            throw new Error("not yet implemented");
        }
        public static get ASCII(): Encoding {
            throw new Error("not yet implemented");
        }
        public static get Latin1(): Encoding {
            throw new Error("not yet implemented");
        }
        public static get Unicode(): Encoding {
            throw new Error("not yet implemented");
        }
        public static get BigEndianUnicode(): Encoding {
            throw new Error("not yet implemented");
        }
        public static get UTF7(): Encoding {
            throw new Error("not yet implemented");
        }
        public static get UTF8(): Encoding {
            throw new Error("not yet implemented");
        }
        public static get UTF32(): Encoding {
            throw new Error("not yet implemented");
        }
        private static get BigEndianUTF32(): Encoding {
            throw new Error("not yet implemented");
        }

        private _codePage: number;
        private _dataItem: CodePageDataItem;
        private _isReadOnly: boolean;
        private encoderFallback: EncoderFallback;
        private decoderFallback: DecoderFallback;

        public get Preamble(): ReadOnlySpan<number> {
            throw new Error("not yet implemented");
        }
        public get BodyName(): string {
            throw new Error("not yet implemented");
        }
        public get EncodingName(): string {
            throw new Error("not yet implemented");
        }
        public get HeaderName(): string {
            throw new Error("not yet implemented");
        }
        public get WebName(): string {
            throw new Error("not yet implemented");
        }
        public get WindowsCodePage(): number {
            throw new Error("not yet implemented");
        }
        public get IsBrowserDisplay(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsBrowserSave(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsMailNewsDisplay(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsMailNewsSave(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsSingleByte(): boolean {
            throw new Error("not yet implemented");
        }
        public get EncoderFallback(): EncoderFallback {
            throw new Error("not yet implemented");
        }
        public set EncoderFallback(value: EncoderFallback) {
            throw new Error("not yet implemented");
        }
        public get DecoderFallback(): DecoderFallback {
            throw new Error("not yet implemented");
        }
        public set DecoderFallback(value: DecoderFallback) {
            throw new Error("not yet implemented");
        }
        public get IsReadOnly(): boolean {
            throw new Error("not yet implemented");
        }
        private set IsReadOnly(value: boolean) {
            throw new Error("not yet implemented");
        }
        public get CodePage(): number {
            throw new Error("not yet implemented");
        }
        private get IsUTF8CodePage(): boolean {
            throw new Error("not yet implemented");
        }

        protected constructor() {
            throw new Error("not yet implemented");
        }
        protected constructor(codePage: number) {
            throw new Error("not yet implemented");
        }
        protected constructor(codePage: number, encoderFallback: EncoderFallback, decoderFallback: DecoderFallback) {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

        private SetDefaultFallbacks() {
            throw new Error("not yet implemented");
        }
        public static Convert(srcEncoding: Encoding, dstEncoding: Encoding, bytes: number[]): number[] {
            throw new Error("not yet implemented");
        }
        public static Convert(srcEncoding: Encoding, dstEncoding: Encoding, bytes: number[], index: number, count: number): number[] {
            throw new Error("not yet implemented");
        }
        public static RegisterProvider(provider: EncodingProvider) {
            throw new Error("not yet implemented");
        }
        public static GetEncoding(codepage: number): Encoding {
            throw new Error("not yet implemented");
        }
        public static GetEncoding(codepage: number, encoderFallback: EncoderFallback, decoderFallback: DecoderFallback): Encoding {
            throw new Error("not yet implemented");
        }
        public static GetEncoding(name: string): Encoding {
            throw new Error("not yet implemented");
        }
        public static GetEncoding(name: string, encoderFallback: EncoderFallback, decoderFallback: DecoderFallback): Encoding {
            throw new Error("not yet implemented");
        }
        private static FilterDisallowedEncodings(encoding: Encoding): Encoding {
            throw new Error("not yet implemented");
        }
        public static GetEncodings(): EncodingInfo[] {
            throw new Error("not yet implemented");
        }
        public GetPreamble(): number[] {
            throw new Error("not yet implemented");
        }
        private GetDataItem() {
            throw new Error("not yet implemented");
        }
        public Clone(): any {
            throw new Error("not yet implemented");
        }
        public GetByteCount(chars: string[]): number {
            throw new Error("not yet implemented");
        }
        public GetByteCount(s: string): number {
            throw new Error("not yet implemented");
        }
        public GetByteCount(chars: string[], index: number, count: number): number;
        public GetByteCount(s: string, index: number, count: number): number {
            throw new Error("not yet implemented");
        }
        public GetByteCount(chars: string*, count: number): number {
            throw new Error("not yet implemented");
        }
        public GetByteCount(chars: ReadOnlySpan<string>): number {
            throw new Error("not yet implemented");
        }
        public GetBytes(chars: string[]): number[] {
            throw new Error("not yet implemented");
        }
        public GetBytes(chars: string[], index: number, count: number): number[] {
            throw new Error("not yet implemented");
        }
        public GetBytes(chars: string[], charIndex: number, charCount: number, bytes: number[], byteIndex: number): number;
        public GetBytes(s: string): number[] {
            throw new Error("not yet implemented");
        }
        public GetBytes(s: string, index: number, count: number): number[] {
            throw new Error("not yet implemented");
        }
        public GetBytes(s: string, charIndex: number, charCount: number, bytes: number[], byteIndex: number): number {
            throw new Error("not yet implemented");
        }
        public GetBytes(chars: string*, charCount: number, bytes: number*, byteCount: number): number {
            throw new Error("not yet implemented");
        }
        public GetBytes(chars: ReadOnlySpan<string>, bytes: Span<number>): number {
            throw new Error("not yet implemented");
        }
        public TryGetBytes(chars: ReadOnlySpan<string>, bytes: Span<number>, out bytesWritten: number): boolean {
            throw new Error("not yet implemented");
        }
        public GetCharCount(bytes: number[]): number {
            throw new Error("not yet implemented");
        }
        public GetCharCount(bytes: number[], index: number, count: number): number;
        public GetCharCount(bytes: number*, count: number): number {
            throw new Error("not yet implemented");
        }
        public GetCharCount(bytes: ReadOnlySpan<number>): number {
            throw new Error("not yet implemented");
        }
        public GetChars(bytes: number[]): string[] {
            throw new Error("not yet implemented");
        }
        public GetChars(bytes: number[], index: number, count: number): string[] {
            throw new Error("not yet implemented");
        }
        public GetChars(bytes: number[], byteIndex: number, byteCount: number, chars: string[], charIndex: number): number;
        public GetChars(bytes: number*, byteCount: number, chars: string*, charCount: number): number {
            throw new Error("not yet implemented");
        }
        public GetChars(bytes: ReadOnlySpan<number>, chars: Span<string>): number {
            throw new Error("not yet implemented");
        }
        public TryGetChars(bytes: ReadOnlySpan<number>, chars: Span<string>, out charsWritten: number): boolean {
            throw new Error("not yet implemented");
        }
        public GetString(bytes: number*, byteCount: number): string {
            throw new Error("not yet implemented");
        }
        public GetString(bytes: ReadOnlySpan<number>): string {
            throw new Error("not yet implemented");
        }
        public IsAlwaysNormalized(): boolean {
            throw new Error("not yet implemented");
        }
        public IsAlwaysNormalized(form: NormalizationForm): boolean {
            throw new Error("not yet implemented");
        }
        public GetDecoder(): Decoder {
            throw new Error("not yet implemented");
        }
        public GetEncoder(): Encoder {
            throw new Error("not yet implemented");
        }
        public GetMaxByteCount(charCount: number): number;
        public GetMaxCharCount(byteCount: number): number;
        public GetString(bytes: number[]): string {
            throw new Error("not yet implemented");
        }
        public GetString(bytes: number[], index: number, count: number): string {
            throw new Error("not yet implemented");
        }
        public Equals(value: any): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public static CreateTranscodingStream(innerStream: Stream, innerStreamEncoding: Encoding, outerStreamEncoding: Encoding, leaveOpen: boolean): Stream {
            throw new Error("not yet implemented");
        }
        private ThrowBytesOverflow() {
            throw new Error("not yet implemented");
        }
        private ThrowBytesOverflow(encoder: EncoderNLS, nothingEncoded: boolean) {
            throw new Error("not yet implemented");
        }
        private static ThrowConversionOverflow() {
            throw new Error("not yet implemented");
        }
        private ThrowCharsOverflow() {
            throw new Error("not yet implemented");
        }
        private ThrowCharsOverflow(decoder: DecoderNLS, nothingDecoded: boolean) {
            throw new Error("not yet implemented");
        }
        private DecodeFirstRune(bytes: ReadOnlySpan<number>, out value: Rune, out bytesConsumed: number): OperationStatus {
            throw new Error("not yet implemented");
        }
        private EncodeRune(value: Rune, bytes: Span<number>, out bytesWritten: number): OperationStatus {
            throw new Error("not yet implemented");
        }
        private TryGetByteCount(value: Rune, out byteCount: number): boolean {
            throw new Error("not yet implemented");
        }
        private GetByteCount(pChars: string*, charCount: number, encoder: EncoderNLS): number {
            throw new Error("not yet implemented");
        }
        private GetByteCountFast(pChars: string*, charsLength: number, fallback: EncoderFallback, out charsConsumed: number): number {
            throw new Error("not yet implemented");
        }
        private GetByteCountWithFallback(pCharsOriginal: string*, originalCharCount: number, charsConsumedSoFar: number): number {
            throw new Error("not yet implemented");
        }
        private GetByteCountWithFallback(pOriginalChars: string*, originalCharCount: number, charsConsumedSoFar: number, encoder: EncoderNLS): number {
            throw new Error("not yet implemented");
        }
        private GetByteCountWithFallback(chars: ReadOnlySpan<string>, originalCharsLength: number, encoder: EncoderNLS): number {
            throw new Error("not yet implemented");
        }
        private GetBytes(pChars: string*, charCount: number, pBytes: number*, byteCount: number, encoder: EncoderNLS): number {
            throw new Error("not yet implemented");
        }
        private GetBytesFast(pChars: string*, charsLength: number, pBytes: number*, bytesLength: number, out charsConsumed: number): number {
            throw new Error("not yet implemented");
        }
        private GetBytesWithFallback(pOriginalChars: string*, originalCharCount: number, pOriginalBytes: number*, originalByteCount: number, charsConsumedSoFar: number, bytesWrittenSoFar: number, throwForDestinationOverflow: boolean): number {
            throw new Error("not yet implemented");
        }
        private GetBytesWithFallback(pOriginalChars: string*, originalCharCount: number, pOriginalBytes: number*, originalByteCount: number, charsConsumedSoFar: number, bytesWrittenSoFar: number, encoder: EncoderNLS): number {
            throw new Error("not yet implemented");
        }
        private GetBytesWithFallback(chars: ReadOnlySpan<string>, originalCharsLength: number, bytes: Span<number>, originalBytesLength: number, encoder: EncoderNLS, throwForDestinationOverflow: boolean): number {
            throw new Error("not yet implemented");
        }
        private GetCharCount(pBytes: number*, byteCount: number, decoder: DecoderNLS): number {
            throw new Error("not yet implemented");
        }
        private GetCharCountFast(pBytes: number*, bytesLength: number, fallback: DecoderFallback, out bytesConsumed: number): number {
            throw new Error("not yet implemented");
        }
        private GetCharCountWithFallback(pBytesOriginal: number*, originalByteCount: number, bytesConsumedSoFar: number): number {
            throw new Error("not yet implemented");
        }
        private GetCharCountWithFallback(pOriginalBytes: number*, originalByteCount: number, bytesConsumedSoFar: number, decoder: DecoderNLS): number {
            throw new Error("not yet implemented");
        }
        private GetCharCountWithFallback(bytes: ReadOnlySpan<number>, originalBytesLength: number, decoder: DecoderNLS): number {
            throw new Error("not yet implemented");
        }
        private GetChars(pBytes: number*, byteCount: number, pChars: string*, charCount: number, decoder: DecoderNLS): number {
            throw new Error("not yet implemented");
        }
        private GetCharsFast(pBytes: number*, bytesLength: number, pChars: string*, charsLength: number, out bytesConsumed: number): number {
            throw new Error("not yet implemented");
        }
        private GetCharsWithFallback(pOriginalBytes: number*, originalByteCount: number, pOriginalChars: string*, originalCharCount: number, bytesConsumedSoFar: number, charsWrittenSoFar: number, throwForDestinationOverflow: boolean): number {
            throw new Error("not yet implemented");
        }
        private GetCharsWithFallback(pOriginalBytes: number*, originalByteCount: number, pOriginalChars: string*, originalCharCount: number, bytesConsumedSoFar: number, charsWrittenSoFar: number, decoder: DecoderNLS): number {
            throw new Error("not yet implemented");
        }
        private GetCharsWithFallback(bytes: ReadOnlySpan<number>, originalBytesLength: number, chars: Span<string>, originalCharsLength: number, decoder: DecoderNLS, throwForDestinationOverflow: boolean): number {
            throw new Error("not yet implemented");
        }
    }
    export namespace Encoding {
        export class DefaultEncoder extends Encoder {
            private _encoding: Encoding;

            public constructor(encoding: Encoding) {
                throw new Error("not yet implemented");
            }

            public GetByteCount(chars: string[], index: number, count: number, flush: boolean): number {
                throw new Error("not yet implemented");
            }
            public GetByteCount(chars: string*, count: number, flush: boolean): number {
                throw new Error("not yet implemented");
            }
            public GetBytes(chars: string[], charIndex: number, charCount: number, bytes: number[], byteIndex: number, flush: boolean): number {
                throw new Error("not yet implemented");
            }
            public GetBytes(chars: string*, charCount: number, bytes: number*, byteCount: number, flush: boolean): number {
                throw new Error("not yet implemented");
            }
        }

        export class DefaultDecoder extends Decoder {
            private _encoding: Encoding;

            public constructor(encoding: Encoding) {
                throw new Error("not yet implemented");
            }

            public GetCharCount(bytes: number[], index: number, count: number): number {
                throw new Error("not yet implemented");
            }
            public GetCharCount(bytes: number[], index: number, count: number, flush: boolean): number {
                throw new Error("not yet implemented");
            }
            public GetCharCount(bytes: number*, count: number, flush: boolean): number {
                throw new Error("not yet implemented");
            }
            public GetChars(bytes: number[], byteIndex: number, byteCount: number, chars: string[], charIndex: number): number {
                throw new Error("not yet implemented");
            }
            public GetChars(bytes: number[], byteIndex: number, byteCount: number, chars: string[], charIndex: number, flush: boolean): number {
                throw new Error("not yet implemented");
            }
            public GetChars(bytes: number*, byteCount: number, chars: string*, charCount: number, flush: boolean): number {
                throw new Error("not yet implemented");
            }
        }

        export class EncodingCharBuffer {
            private _chars: string*;
            private _charStart: string*;
            private _charEnd: string*;
            private _charCountResult: number;
            private _enc: Encoding;
            private _decoder: DecoderNLS;
            private _byteStart: number*;
            private _byteEnd: number*;
            private _bytes: number*;
            private _fallbackBuffer: DecoderFallbackBuffer;

            private get MoreData(): boolean {
                throw new Error("not yet implemented");
            }
            private get BytesUsed(): number {
                throw new Error("not yet implemented");
            }
            private get Count(): number {
                throw new Error("not yet implemented");
            }

            protected constructor(enc: Encoding, decoder: DecoderNLS, charStart: string*, charCount: number, byteStart: number*, byteCount: number) {
                throw new Error("not yet implemented");
            }

            private AddChar(ch: string, numBytes: number): boolean {
                throw new Error("not yet implemented");
            }
            private AddChar(ch: string): boolean {
                throw new Error("not yet implemented");
            }
            private AdjustBytes(count: number) {
                throw new Error("not yet implemented");
            }
            private GetNextByte(): number {
                throw new Error("not yet implemented");
            }
            private Fallback(fallbackByte: number): boolean {
                throw new Error("not yet implemented");
            }
            private Fallback(byteBuffer: number[]): boolean {
                throw new Error("not yet implemented");
            }
        }

        export class EncodingByteBuffer {
            private _bytes: number*;
            private _byteStart: number*;
            private _byteEnd: number*;
            private _chars: string*;
            private _charStart: string*;
            private _charEnd: string*;
            private _byteCountResult: number;
            private _enc: Encoding;
            private _encoder: EncoderNLS;
            private fallbackBuffer: EncoderFallbackBuffer;

            private get MoreData(): boolean {
                throw new Error("not yet implemented");
            }
            private get CharsUsed(): number {
                throw new Error("not yet implemented");
            }
            private get Count(): number {
                throw new Error("not yet implemented");
            }

            protected constructor(inEncoding: Encoding, inEncoder: EncoderNLS, inByteStart: number*, inByteCount: number, inCharStart: string*, inCharCount: number) {
                throw new Error("not yet implemented");
            }

            private AddByte(b: number, moreBytesExpected: number): boolean {
                throw new Error("not yet implemented");
            }
            private AddByte(b1: number): boolean {
                throw new Error("not yet implemented");
            }
            private AddByte(b1: number, b2: number): boolean {
                throw new Error("not yet implemented");
            }
            private AddByte(b1: number, b2: number, moreBytesExpected: number): boolean {
                throw new Error("not yet implemented");
            }
            private MovePrevious(bThrow: boolean) {
                throw new Error("not yet implemented");
            }
            private GetNextChar(): string {
                throw new Error("not yet implemented");
            }
        }
    }
}
export namespace System.Threading {
    export abstract class WaitHandle extends MarshalByRefObject implements IDisposable {
        private static readonly InvalidHandle: number;
        private static t_safeWaitHandlesForRent: SafeWaitHandle[];
        private static MaxWaitHandles: number;
        private static WaitSuccess: number;
        private static WaitAbandoned: number;
        public static WaitTimeout: number;

        private _waitHandle: SafeWaitHandle;

        public get Handle(): number {
            throw new Error("not yet implemented");
        }
        public set Handle(value: number) {
            throw new Error("not yet implemented");
        }
        public get SafeWaitHandle(): SafeWaitHandle {
            throw new Error("not yet implemented");
        }
        public set SafeWaitHandle(value: SafeWaitHandle) {
            throw new Error("not yet implemented");
        }

        protected constructor() {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

        private static WaitOneCore(waitHandle: number, millisecondsTimeout: number): number {
            throw new Error("not yet implemented");
        }
        private static WaitMultipleIgnoringSyncContext(waitHandles: Span<number>, waitAll: boolean, millisecondsTimeout: number): number {
            throw new Error("not yet implemented");
        }
        private static WaitMultipleIgnoringSyncContext(waitHandles: number*, numHandles: number, waitAll: boolean, millisecondsTimeout: number): number {
            throw new Error("not yet implemented");
        }
        private static SignalAndWaitCore(waitHandleToSignal: number, waitHandleToWaitOn: number, millisecondsTimeout: number): number {
            throw new Error("not yet implemented");
        }
        private static SignalAndWaitNative(waitHandleToSignal: number, waitHandleToWaitOn: number, millisecondsTimeout: number): number {
            throw new Error("not yet implemented");
        }
        private static ToTimeoutMilliseconds(timeout: TimeSpan): number {
            throw new Error("not yet implemented");
        }
        public Close() {
            throw new Error("not yet implemented");
        }
        private Dispose(explicitDisposing: boolean) {
            throw new Error("not yet implemented");
        }
        public Dispose() {
            throw new Error("not yet implemented");
        }
        public WaitOne(millisecondsTimeout: number): boolean {
            throw new Error("not yet implemented");
        }
        private WaitOneNoCheck(millisecondsTimeout: number): boolean {
            throw new Error("not yet implemented");
        }
        private static RentSafeWaitHandleArray(capacity: number): SafeWaitHandle[] {
            throw new Error("not yet implemented");
        }
        private static ReturnSafeWaitHandleArray(safeWaitHandles: SafeWaitHandle[]) {
            throw new Error("not yet implemented");
        }
        private static ObtainSafeWaitHandles(waitHandles: ReadOnlySpan<WaitHandle>, safeWaitHandles: Span<SafeWaitHandle>, unsafeWaitHandles: Span<number>) {
            throw new Error("not yet implemented");
        }
        private static WaitMultiple(waitHandles: WaitHandle[], waitAll: boolean, millisecondsTimeout: number): number {
            throw new Error("not yet implemented");
        }
        private static WaitMultiple(waitHandles: ReadOnlySpan<WaitHandle>, waitAll: boolean, millisecondsTimeout: number): number {
            throw new Error("not yet implemented");
        }
        private static WaitAnyMultiple(safeWaitHandles: ReadOnlySpan<SafeWaitHandle>, millisecondsTimeout: number): number {
            throw new Error("not yet implemented");
        }
        private static SignalAndWait(toSignal: WaitHandle, toWaitOn: WaitHandle, millisecondsTimeout: number): boolean {
            throw new Error("not yet implemented");
        }
        public WaitOne(timeout: TimeSpan): boolean {
            throw new Error("not yet implemented");
        }
        public WaitOne(): boolean {
            throw new Error("not yet implemented");
        }
        public WaitOne(millisecondsTimeout: number, exitContext: boolean): boolean {
            throw new Error("not yet implemented");
        }
        public WaitOne(timeout: TimeSpan, exitContext: boolean): boolean {
            throw new Error("not yet implemented");
        }
        public static WaitAll(waitHandles: WaitHandle[], millisecondsTimeout: number): boolean {
            throw new Error("not yet implemented");
        }
        public static WaitAll(waitHandles: WaitHandle[], timeout: TimeSpan): boolean {
            throw new Error("not yet implemented");
        }
        public static WaitAll(waitHandles: WaitHandle[]): boolean {
            throw new Error("not yet implemented");
        }
        public static WaitAll(waitHandles: WaitHandle[], millisecondsTimeout: number, exitContext: boolean): boolean {
            throw new Error("not yet implemented");
        }
        public static WaitAll(waitHandles: WaitHandle[], timeout: TimeSpan, exitContext: boolean): boolean {
            throw new Error("not yet implemented");
        }
        public static WaitAny(waitHandles: WaitHandle[], millisecondsTimeout: number): number {
            throw new Error("not yet implemented");
        }
        private static WaitAny(safeWaitHandles: ReadOnlySpan<SafeWaitHandle>, millisecondsTimeout: number): number {
            throw new Error("not yet implemented");
        }
        public static WaitAny(waitHandles: WaitHandle[], timeout: TimeSpan): number {
            throw new Error("not yet implemented");
        }
        public static WaitAny(waitHandles: WaitHandle[]): number {
            throw new Error("not yet implemented");
        }
        public static WaitAny(waitHandles: WaitHandle[], millisecondsTimeout: number, exitContext: boolean): number {
            throw new Error("not yet implemented");
        }
        public static WaitAny(waitHandles: WaitHandle[], timeout: TimeSpan, exitContext: boolean): number {
            throw new Error("not yet implemented");
        }
        public static SignalAndWait(toSignal: WaitHandle, toWaitOn: WaitHandle): boolean {
            throw new Error("not yet implemented");
        }
        public static SignalAndWait(toSignal: WaitHandle, toWaitOn: WaitHandle, timeout: TimeSpan, exitContext: boolean): boolean {
            throw new Error("not yet implemented");
        }
        public static SignalAndWait(toSignal: WaitHandle, toWaitOn: WaitHandle, millisecondsTimeout: number, exitContext: boolean): boolean {
            throw new Error("not yet implemented");
        }
    }
    export interface IAsyncLocal {
        OnValueChanged(previousValue: any, currentValue: any, contextChanged: boolean): void;
    }
    export class AsyncLocal<T> implements IAsyncLocal {
        private _valueChangedHandler: Action<AsyncLocalValueChangedArgs<T>>;

        public get Value(): T {
            throw new Error("not yet implemented");
        }
        public set Value(value: T) {
            throw new Error("not yet implemented");
        }

        public constructor() {
            throw new Error("not yet implemented");
        }
        public constructor(valueChangedHandler: Action<AsyncLocalValueChangedArgs<T>>) {
            throw new Error("not yet implemented");
        }

        private __explicit__IAsyncLocal_OnValueChanged(previousValueObj: any, currentValueObj: any, contextChanged: boolean) {
            throw new Error("not yet implemented");
        }
        public OnValueChanged(previousValueObj: any, currentValueObj: any, contextChanged: boolean) {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
    }
    export class AsyncLocalValueChangedArgs<T> extends ValueType {
        private __PreviousValue__k__BackingField: T;
        private __CurrentValue__k__BackingField: T;
        private __ThreadContextChanged__k__BackingField: boolean;

        public get PreviousValue(): T {
            throw new Error("not yet implemented");
        }
        public get CurrentValue(): T {
            throw new Error("not yet implemented");
        }
        public get ThreadContextChanged(): boolean {
            throw new Error("not yet implemented");
        }

        protected constructor(previousValue: T, currentValue: T, contextChanged: boolean) {
            throw new Error("not yet implemented");
        }

    }
    export interface IAsyncLocalValueMap {
        TryGetValue(key: IAsyncLocal, out value: any): boolean;
        Set(key: IAsyncLocal, value: any, treatNullValueAsNonexistent: boolean): IAsyncLocalValueMap;
    }
    export class SendOrPostCallback extends MulticastDelegate implements ICloneable, ISerializable {
        public constructor(object: any, method: number) {
            throw new Error("not yet implemented");
        }

        public Invoke(state: any) {
            throw new Error("not yet implemented");
        }
        public BeginInvoke(state: any, callback: AsyncCallback, object: any): IAsyncResult {
            throw new Error("not yet implemented");
        }
        public EndInvoke(result: IAsyncResult) {
            throw new Error("not yet implemented");
        }
    }
    export class SynchronizationContext {
        public static get Current(): SynchronizationContext {
            throw new Error("not yet implemented");
        }

        private _requireWaitNotification: boolean;

        public constructor() {
            throw new Error("not yet implemented");
        }

        private static InvokeWaitMethodHelper(syncContext: SynchronizationContext, waitHandles: number[], waitAll: boolean, millisecondsTimeout: number): number {
            throw new Error("not yet implemented");
        }
        private SetWaitNotificationRequired() {
            throw new Error("not yet implemented");
        }
        public IsWaitNotificationRequired(): boolean {
            throw new Error("not yet implemented");
        }
        public Send(d: SendOrPostCallback, state: any) {
            throw new Error("not yet implemented");
        }
        public Post(d: SendOrPostCallback, state: any) {
            throw new Error("not yet implemented");
        }
        public OperationStarted() {
            throw new Error("not yet implemented");
        }
        public OperationCompleted() {
            throw new Error("not yet implemented");
        }
        public Wait(waitHandles: number[], waitAll: boolean, millisecondsTimeout: number): number {
            throw new Error("not yet implemented");
        }
        private static WaitHelper(waitHandles: number[], waitAll: boolean, millisecondsTimeout: number): number {
            throw new Error("not yet implemented");
        }
        public static SetSynchronizationContext(syncContext: SynchronizationContext) {
            throw new Error("not yet implemented");
        }
        public CreateCopy(): SynchronizationContext {
            throw new Error("not yet implemented");
        }
    }
    export namespace SynchronizationContext {
        export class ____c {
            public static readonly ____9: ____c;
            public static ____9__8_0: Action<KeyValuePair<SendOrPostCallback, any>>;

            private static staticctor_initialize = (() => {
                throw new Error("not yet implemented");
            })();
            private constructor() { }
            public constructor() {
                throw new Error("not yet implemented");
            }

            private __Post__b__8_0(s: KeyValuePair<SendOrPostCallback, any>) {
                throw new Error("not yet implemented");
            }
        }
    }
    export class ContextCallback extends MulticastDelegate implements ICloneable, ISerializable {
        public constructor(object: any, method: number) {
            throw new Error("not yet implemented");
        }

        public Invoke(state: any) {
            throw new Error("not yet implemented");
        }
        public BeginInvoke(state: any, callback: AsyncCallback, object: any): IAsyncResult {
            throw new Error("not yet implemented");
        }
        public EndInvoke(result: IAsyncResult) {
            throw new Error("not yet implemented");
        }
    }
    export class StartHelper {
        private static readonly s_threadStartContextCallback: ContextCallback;

        private _maxStackSize: number;
        private _start: Delegate;
        private _startArg: any;
        private _culture: CultureInfo;
        private _uiCulture: CultureInfo;
        private _executionContext: ExecutionContext;

        protected constructor(start: Delegate) {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

        private static Callback(state: any) {
            throw new Error("not yet implemented");
        }
        private Run() {
            throw new Error("not yet implemented");
        }
        private RunWorker() {
            throw new Error("not yet implemented");
        }
        private InitializeCulture() {
            throw new Error("not yet implemented");
        }
    }
    export enum ThreadPriority {
        Lowest = 0,
        BelowNormal = 1,
        Normal = 2,
        AboveNormal = 3,
        Highest = 4,
    }
    export enum ThreadState {
        Running = 0x0,
        StopRequested = 0x1,
        SuspendRequested = 0x2,
        Background = 0x4,
        Unstarted = 0x8,
        Stopped = 0x10,
        WaitSleepJoin = 0x20,
        Suspended = 0x40,
        AbortRequested = 0x80,
        Aborted = 0x100,
    }
    export enum ApartmentState {
        STA = 0,
        MTA = 1,
        Unknown = 2,
    }
    export class ThreadStart extends MulticastDelegate implements ICloneable, ISerializable {
        public constructor(object: any, method: number) {
            throw new Error("not yet implemented");
        }

        public Invoke() {
            throw new Error("not yet implemented");
        }
        public BeginInvoke(callback: AsyncCallback, object: any): IAsyncResult {
            throw new Error("not yet implemented");
        }
        public EndInvoke(result: IAsyncResult) {
            throw new Error("not yet implemented");
        }
    }
    export class ParameterizedThreadStart extends MulticastDelegate implements ICloneable, ISerializable {
        public constructor(object: any, method: number) {
            throw new Error("not yet implemented");
        }

        public Invoke(obj: any) {
            throw new Error("not yet implemented");
        }
        public BeginInvoke(obj: any, callback: AsyncCallback, object: any): IAsyncResult {
            throw new Error("not yet implemented");
        }
        public EndInvoke(result: IAsyncResult) {
            throw new Error("not yet implemented");
        }
    }
    export class ThreadHandle extends ValueType {
        private _ptr: number;

        protected constructor(pThread: number) {
            throw new Error("not yet implemented");
        }

    }
    export class LinkedSlotVolatile extends ValueType {
        private Value: LinkedSlot;

    }
    export class LinkedSlot {
        private _next: LinkedSlot;
        private _previous: LinkedSlot;
        private _slotArray: LinkedSlotVolatile[];
        private _value: T;

        protected constructor(slotArray: LinkedSlotVolatile[]) {
            throw new Error("not yet implemented");
        }

    }
    export class IdManager {
        private _nextIdToTry: number;
        private _idsThatDoNotTrackAllValues: number;
        private _usedIdToTracksAllValuesMap: Dictionary<number, boolean>;
        private _freeIds: List<number>;

        private get IdsThatDoNotTrackValuesCount(): number {
            throw new Error("not yet implemented");
        }

        public constructor() {
            throw new Error("not yet implemented");
        }

        private GetId(trackAllValues: boolean): number {
            throw new Error("not yet implemented");
        }
        private IdTracksAllValues(id: number): boolean {
            throw new Error("not yet implemented");
        }
        private ReturnId(id: number, idTracksAllValues: boolean) {
            throw new Error("not yet implemented");
        }
    }
    export class FinalizationHelper {
        private SlotArray: LinkedSlotVolatile[];

        protected constructor(slotArray: LinkedSlotVolatile[]) {
            throw new Error("not yet implemented");
        }

        private Finalize() {
            throw new Error("not yet implemented");
        }
    }
    export class ThreadLocal<T> implements IDisposable {
        private static readonly s_idManager: IdManager;
        private static ts_slotArray: LinkedSlotVolatile[];
        private static ts_finalizationHelper: FinalizationHelper;

        private _valueFactory: Func<T>;
        private _idComplement: number;
        private _initialized: boolean;
        private _linkedSlot: LinkedSlot;
        private _trackAllValues: boolean;

        public get Value(): T {
            throw new Error("not yet implemented");
        }
        public set Value(value: T) {
            throw new Error("not yet implemented");
        }
        public get Values(): IList<T> {
            throw new Error("not yet implemented");
        }
        private get ValuesCountForDebugDisplay(): number {
            throw new Error("not yet implemented");
        }
        public get IsValueCreated(): boolean {
            throw new Error("not yet implemented");
        }
        private get ValueForDebugDisplay(): T {
            throw new Error("not yet implemented");
        }
        private get ValuesForDebugDisplay(): List<T> {
            throw new Error("not yet implemented");
        }

        public constructor() {
            throw new Error("not yet implemented");
        }
        public constructor(trackAllValues: boolean) {
            throw new Error("not yet implemented");
        }
        public constructor(valueFactory: Func<T>) {
            throw new Error("not yet implemented");
        }
        public constructor(valueFactory: Func<T>, trackAllValues: boolean) {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

        private Initialize(valueFactory: Func<T>, trackAllValues: boolean) {
            throw new Error("not yet implemented");
        }
        private Finalize() {
            throw new Error("not yet implemented");
        }
        public Dispose() {
            throw new Error("not yet implemented");
        }
        private Dispose(disposing: boolean) {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
        private GetValueSlow(): T {
            throw new Error("not yet implemented");
        }
        private SetValueSlow(value: T, slotArray: LinkedSlotVolatile[]) {
            throw new Error("not yet implemented");
        }
        private CreateLinkedSlot(slotArray: LinkedSlotVolatile[], id: number, value: T) {
            throw new Error("not yet implemented");
        }
        private GetValuesAsList(): List<T> {
            throw new Error("not yet implemented");
        }
        private static GrowTable(ref table: LinkedSlotVolatile[], minLength: number) {
            throw new Error("not yet implemented");
        }
        private static GetNewTableSize(minSize: number): number {
            throw new Error("not yet implemented");
        }
    }
    export namespace ThreadLocal {
        export class LinkedSlotVolatile extends ValueType {
            private Value: LinkedSlot;

        }

        export class LinkedSlot {
            private _next: LinkedSlot;
            private _previous: LinkedSlot;
            private _slotArray: LinkedSlotVolatile[];
            private _value: T;

            protected constructor(slotArray: LinkedSlotVolatile[]) {
                throw new Error("not yet implemented");
            }

        }

        export class IdManager {
            private _nextIdToTry: number;
            private _idsThatDoNotTrackAllValues: number;
            private _usedIdToTracksAllValuesMap: Dictionary<number, boolean>;
            private _freeIds: List<number>;

            private get IdsThatDoNotTrackValuesCount(): number {
                throw new Error("not yet implemented");
            }

            public constructor() {
                throw new Error("not yet implemented");
            }

            private GetId(trackAllValues: boolean): number {
                throw new Error("not yet implemented");
            }
            private IdTracksAllValues(id: number): boolean {
                throw new Error("not yet implemented");
            }
            private ReturnId(id: number, idTracksAllValues: boolean) {
                throw new Error("not yet implemented");
            }
        }

        export class FinalizationHelper {
            private SlotArray: LinkedSlotVolatile[];

            protected constructor(slotArray: LinkedSlotVolatile[]) {
                throw new Error("not yet implemented");
            }

            private Finalize() {
                throw new Error("not yet implemented");
            }
        }
    }
    export class CompressedStack implements ISerializable {
        private constructor() {
            throw new Error("not yet implemented");
        }

        public GetObjectData(info: SerializationInfo, context: StreamingContext) {
            throw new Error("not yet implemented");
        }
        public static Capture(): CompressedStack {
            throw new Error("not yet implemented");
        }
        public CreateCopy(): CompressedStack {
            throw new Error("not yet implemented");
        }
        public static GetCompressedStack(): CompressedStack {
            throw new Error("not yet implemented");
        }
        public static Run(compressedStack: CompressedStack, callback: ContextCallback, state: any) {
            throw new Error("not yet implemented");
        }
    }
    export enum EventResetMode {
        AutoReset = 0,
        ManualReset = 1,
    }
    export enum OpenExistingResult {
        Success = 0,
        NameNotFound = 1,
        PathNotFound = 2,
        NameInvalid = 3,
    }
    export class EventWaitHandle extends WaitHandle implements IDisposable {
        public constructor(initialState: boolean, mode: EventResetMode) {
            throw new Error("not yet implemented");
        }
        public constructor(initialState: boolean, mode: EventResetMode, name: string) {
            throw new Error("not yet implemented");
        }
        public constructor(initialState: boolean, mode: EventResetMode, name: string, createdNew: boolean) {
            throw new Error("not yet implemented");
        }
        private constructor(handle: SafeWaitHandle) {
            throw new Error("not yet implemented");
        }

        public static OpenExisting(name: string): EventWaitHandle {
            throw new Error("not yet implemented");
        }
        public static TryOpenExisting(name: string, out result: EventWaitHandle): boolean {
            throw new Error("not yet implemented");
        }
        private CreateEventCore(initialState: boolean, mode: EventResetMode, name: string, out createdNew: boolean) {
            throw new Error("not yet implemented");
        }
        private static OpenExistingWorker(name: string, out result: EventWaitHandle): OpenExistingResult {
            throw new Error("not yet implemented");
        }
        public Reset(): boolean {
            throw new Error("not yet implemented");
        }
        public Set(): boolean {
            throw new Error("not yet implemented");
        }
        private static Set(waitHandle: SafeWaitHandle): boolean {
            throw new Error("not yet implemented");
        }
    }
    export class ManualResetEvent extends EventWaitHandle implements IDisposable {
        public constructor(initialState: boolean) {
            throw new Error("not yet implemented");
        }

    }
    export interface ITimer implements IDisposable, IAsyncDisposable {
        Change(dueTime: TimeSpan, period: TimeSpan): boolean;
    }
    export class CallbackNode {
        public Registrations: Registrations;
        public Prev: CallbackNode;
        public Next: CallbackNode;
        public Id: number;
        public Callback: Delegate;
        public CallbackState: any;
        public ExecutionContext: ExecutionContext;
        public SynchronizationContext: SynchronizationContext;

        public constructor(registrations: Registrations) {
            throw new Error("not yet implemented");
        }

        public ExecuteCallback() {
            throw new Error("not yet implemented");
        }
    }
    export namespace CallbackNode {
        export class ____c {
            public static readonly ____9: ____c;
            public static ____9__9_0: ContextCallback;

            private static staticctor_initialize = (() => {
                throw new Error("not yet implemented");
            })();
            private constructor() { }
            public constructor() {
                throw new Error("not yet implemented");
            }

            private __ExecuteCallback__b__9_0(s: any) {
                throw new Error("not yet implemented");
            }
        }
    }
    export class Registrations {
        public Source: CancellationTokenSource;
        public Callbacks: CallbackNode;
        public FreeNodeList: CallbackNode;
        public NextAvailableId: number;
        public ExecutingCallbackId: number;
        public ThreadIDExecutingCallbacks: number;
        private _lock: number;

        public constructor(source: CancellationTokenSource) {
            throw new Error("not yet implemented");
        }

        private Recycle(node: CallbackNode) {
            throw new Error("not yet implemented");
        }
        public Unregister(id: number, node: CallbackNode): boolean {
            throw new Error("not yet implemented");
        }
        public UnregisterAll() {
            throw new Error("not yet implemented");
        }
        public WaitForCallbackToComplete(id: number) {
            throw new Error("not yet implemented");
        }
        public WaitForCallbackToCompleteAsync(id: number): ValueTask {
            throw new Error("not yet implemented");
        }
        public EnterLock() {
            throw new Error("not yet implemented");
        }
        public ExitLock() {
            throw new Error("not yet implemented");
        }
        private static __EnterLock__g__Contention_13_0(ref value: number) {
            throw new Error("not yet implemented");
        }
    }
    export namespace Registrations {
        export class __WaitForCallbackToCompleteAsync__d__12 extends ValueType implements IAsyncStateMachine {
            public ____1__state: number;
            public ____t__builder: AsyncValueTaskMethodBuilder;
            public ____4__this: Registrations;
            public id: number;
            private ____u__1: ConfiguredTaskAwaiter;

            private __explicit__MoveNext() {
                throw new Error("not yet implemented");
            }
            private __explicit__SetStateMachine(stateMachine: IAsyncStateMachine) {
                throw new Error("not yet implemented");
            }
        }
    }
    export class TimerCallback extends MulticastDelegate implements ICloneable, ISerializable {
        public constructor(object: any, method: number) {
            throw new Error("not yet implemented");
        }

        public Invoke(state: any) {
            throw new Error("not yet implemented");
        }
        public BeginInvoke(state: any, callback: AsyncCallback, object: any): IAsyncResult {
            throw new Error("not yet implemented");
        }
        public EndInvoke(result: IAsyncResult) {
            throw new Error("not yet implemented");
        }
    }
    export class CancellationTokenRegistration extends ValueType implements IEquatable<CancellationTokenRegistration>, IDisposable, IAsyncDisposable {
        private _id: number;
        private _node: CallbackNode;

        public get Token(): CancellationToken {
            throw new Error("not yet implemented");
        }

        protected constructor(id: number, node: CallbackNode) {
            throw new Error("not yet implemented");
        }

        public Dispose() {
            throw new Error("not yet implemented");
        }
        public DisposeAsync(): ValueTask {
            throw new Error("not yet implemented");
        }
        public Unregister(): boolean {
            throw new Error("not yet implemented");
        }
        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public Equals(other: CancellationTokenRegistration): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        private static __Dispose__g__WaitForCallbackIfNecessary_3_0(id: number, node: CallbackNode) {
            throw new Error("not yet implemented");
        }
        private static __DisposeAsync__g__WaitForCallbackIfNecessaryAsync_4_0(id: number, node: CallbackNode): ValueTask {
            throw new Error("not yet implemented");
        }
    }
    export class CancellationTokenSource implements IDisposable {
        private static readonly s_canceledSource: CancellationTokenSource;
        private static readonly s_neverCanceledSource: CancellationTokenSource;
        private static readonly s_timerCallback: TimerCallback;

        private _state: number;
        private _disposed: boolean;
        private _timer: ITimer;
        private _kernelEvent: ManualResetEvent;
        private _registrations: Registrations;

        public get IsCancellationRequested(): boolean {
            throw new Error("not yet implemented");
        }
        private get IsCancellationCompleted(): boolean {
            throw new Error("not yet implemented");
        }
        public get Token(): CancellationToken {
            throw new Error("not yet implemented");
        }
        private get WaitHandle(): WaitHandle {
            throw new Error("not yet implemented");
        }

        public constructor() {
            throw new Error("not yet implemented");
        }
        public constructor(delay: TimeSpan) {
            throw new Error("not yet implemented");
        }
        public constructor(delay: TimeSpan, timeProvider: TimeProvider) {
            throw new Error("not yet implemented");
        }
        public constructor(millisecondsDelay: number) {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

        private static TimerCallback(state: any) {
            throw new Error("not yet implemented");
        }
        private InitializeWithTimer(millisecondsDelay: TimeSpan, timeProvider: TimeProvider) {
            throw new Error("not yet implemented");
        }
        public Cancel() {
            throw new Error("not yet implemented");
        }
        public Cancel(throwOnFirstException: boolean) {
            throw new Error("not yet implemented");
        }
        public CancelAsync(): Task {
            throw new Error("not yet implemented");
        }
        public CancelAfter(delay: TimeSpan) {
            throw new Error("not yet implemented");
        }
        public CancelAfter(millisecondsDelay: number) {
            throw new Error("not yet implemented");
        }
        private CancelAfter(millisecondsDelay: number) {
            throw new Error("not yet implemented");
        }
        public TryReset(): boolean {
            throw new Error("not yet implemented");
        }
        public Dispose() {
            throw new Error("not yet implemented");
        }
        private Dispose(disposing: boolean) {
            throw new Error("not yet implemented");
        }
        private ThrowIfDisposed() {
            throw new Error("not yet implemented");
        }
        private Register(callback: Delegate, stateForCallback: any, syncContext: SynchronizationContext, executionContext: ExecutionContext): CancellationTokenRegistration {
            throw new Error("not yet implemented");
        }
        private NotifyCancellation(throwOnFirstException: boolean) {
            throw new Error("not yet implemented");
        }
        private TransitionToCancellationRequested(): boolean {
            throw new Error("not yet implemented");
        }
        private ExecuteCallbackHandlers(throwOnFirstException: boolean) {
            throw new Error("not yet implemented");
        }
        public static CreateLinkedTokenSource(token1: CancellationToken, token2: CancellationToken): CancellationTokenSource {
            throw new Error("not yet implemented");
        }
        public static CreateLinkedTokenSource(token: CancellationToken): CancellationTokenSource {
            throw new Error("not yet implemented");
        }
        public static CreateLinkedTokenSource(tokens: CancellationToken[]): CancellationTokenSource {
            throw new Error("not yet implemented");
        }
        private static Invoke(d: Delegate, state: any, source: CancellationTokenSource) {
            throw new Error("not yet implemented");
        }
    }
    export namespace CancellationTokenSource {
        export class Linked1CancellationTokenSource extends CancellationTokenSource implements IDisposable {
            private _reg1: CancellationTokenRegistration;

            protected constructor(token1: CancellationToken) {
                throw new Error("not yet implemented");
            }

            private Dispose(disposing: boolean) {
                throw new Error("not yet implemented");
            }
        }

        export class Linked2CancellationTokenSource extends CancellationTokenSource implements IDisposable {
            private _reg1: CancellationTokenRegistration;
            private _reg2: CancellationTokenRegistration;

            protected constructor(token1: CancellationToken, token2: CancellationToken) {
                throw new Error("not yet implemented");
            }

            private Dispose(disposing: boolean) {
                throw new Error("not yet implemented");
            }
        }

        export class LinkedNCancellationTokenSource extends CancellationTokenSource implements IDisposable {
            private static readonly s_linkedTokenCancelDelegate: Action<any>;

            private _linkingRegistrations: CancellationTokenRegistration[];

            protected constructor(tokens: CancellationToken[]) {
                throw new Error("not yet implemented");
            }
            private static staticctor_initialize = (() => {
                throw new Error("not yet implemented");
            })();
            private constructor() { }

            private Dispose(disposing: boolean) {
                throw new Error("not yet implemented");
            }
        }
        export namespace LinkedNCancellationTokenSource {
            export class ____c {
                public static readonly ____9: ____c;

                private static staticctor_initialize = (() => {
                    throw new Error("not yet implemented");
                })();
                private constructor() { }
                public constructor() {
                    throw new Error("not yet implemented");
                }

                private ___cctor__b__4_0(s: any) {
                    throw new Error("not yet implemented");
                }
            }
        }

        export class Registrations {
            public Source: CancellationTokenSource;
            public Callbacks: CallbackNode;
            public FreeNodeList: CallbackNode;
            public NextAvailableId: number;
            public ExecutingCallbackId: number;
            public ThreadIDExecutingCallbacks: number;
            private _lock: number;

            public constructor(source: CancellationTokenSource) {
                throw new Error("not yet implemented");
            }

            private Recycle(node: CallbackNode) {
                throw new Error("not yet implemented");
            }
            public Unregister(id: number, node: CallbackNode): boolean {
                throw new Error("not yet implemented");
            }
            public UnregisterAll() {
                throw new Error("not yet implemented");
            }
            public WaitForCallbackToComplete(id: number) {
                throw new Error("not yet implemented");
            }
            public WaitForCallbackToCompleteAsync(id: number): ValueTask {
                throw new Error("not yet implemented");
            }
            public EnterLock() {
                throw new Error("not yet implemented");
            }
            public ExitLock() {
                throw new Error("not yet implemented");
            }
            private static __EnterLock__g__Contention_13_0(ref value: number) {
                throw new Error("not yet implemented");
            }
        }
        export namespace Registrations {
            export class __WaitForCallbackToCompleteAsync__d__12 extends ValueType implements IAsyncStateMachine {
                public ____1__state: number;
                public ____t__builder: AsyncValueTaskMethodBuilder;
                public ____4__this: Registrations;
                public id: number;
                private ____u__1: ConfiguredTaskAwaiter;

                private __explicit__MoveNext() {
                    throw new Error("not yet implemented");
                }
                private __explicit__SetStateMachine(stateMachine: IAsyncStateMachine) {
                    throw new Error("not yet implemented");
                }
            }
        }

        export class CallbackNode {
            public Registrations: Registrations;
            public Prev: CallbackNode;
            public Next: CallbackNode;
            public Id: number;
            public Callback: Delegate;
            public CallbackState: any;
            public ExecutionContext: ExecutionContext;
            public SynchronizationContext: SynchronizationContext;

            public constructor(registrations: Registrations) {
                throw new Error("not yet implemented");
            }

            public ExecuteCallback() {
                throw new Error("not yet implemented");
            }
        }
        export namespace CallbackNode {
            export class ____c {
                public static readonly ____9: ____c;
                public static ____9__9_0: ContextCallback;

                private static staticctor_initialize = (() => {
                    throw new Error("not yet implemented");
                })();
                private constructor() { }
                public constructor() {
                    throw new Error("not yet implemented");
                }

                private __ExecuteCallback__b__9_0(s: any) {
                    throw new Error("not yet implemented");
                }
            }
        }

        export class ____c {
            public static readonly ____9: ____c;
            public static ____9__27_0: Action<any>;
            public static ____9__38_0: SendOrPostCallback;

            private static staticctor_initialize = (() => {
                throw new Error("not yet implemented");
            })();
            private constructor() { }
            public constructor() {
                throw new Error("not yet implemented");
            }

            private __CancelAsync__b__27_0(s: any) {
                throw new Error("not yet implemented");
            }
            private __ExecuteCallbackHandlers__b__38_0(s: any) {
                throw new Error("not yet implemented");
            }
        }
    }
    export class CancellationToken extends ValueType implements IEquatable<CancellationToken> {
        public static get None(): CancellationToken {
            throw new Error("not yet implemented");
        }

        private _source: CancellationTokenSource;

        public get IsCancellationRequested(): boolean {
            throw new Error("not yet implemented");
        }
        public get CanBeCanceled(): boolean {
            throw new Error("not yet implemented");
        }
        public get WaitHandle(): WaitHandle {
            throw new Error("not yet implemented");
        }

        protected constructor(source: CancellationTokenSource) {
            throw new Error("not yet implemented");
        }
        public constructor(canceled: boolean) {
            throw new Error("not yet implemented");
        }

        public Register(callback: Action): CancellationTokenRegistration {
            throw new Error("not yet implemented");
        }
        public Register(callback: Action, useSynchronizationContext: boolean): CancellationTokenRegistration {
            throw new Error("not yet implemented");
        }
        public Register(callback: Action<any>, state: any): CancellationTokenRegistration {
            throw new Error("not yet implemented");
        }
        public Register(callback: Action<any, CancellationToken>, state: any): CancellationTokenRegistration {
            throw new Error("not yet implemented");
        }
        public Register(callback: Action<any>, state: any, useSynchronizationContext: boolean): CancellationTokenRegistration {
            throw new Error("not yet implemented");
        }
        public UnsafeRegister(callback: Action<any>, state: any): CancellationTokenRegistration {
            throw new Error("not yet implemented");
        }
        public UnsafeRegister(callback: Action<any, CancellationToken>, state: any): CancellationTokenRegistration {
            throw new Error("not yet implemented");
        }
        private Register(callback: Delegate, state: any, useSynchronizationContext: boolean, useExecutionContext: boolean): CancellationTokenRegistration {
            throw new Error("not yet implemented");
        }
        public Equals(other: CancellationToken): boolean {
            throw new Error("not yet implemented");
        }
        public Equals(other: any): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public ThrowIfCancellationRequested() {
            throw new Error("not yet implemented");
        }
        private ThrowOperationCanceledException() {
            throw new Error("not yet implemented");
        }
    }
    export namespace CancellationToken {
        export class ____c {
            public static readonly ____9: ____c;
            public static ____9__12_0: Action<any>;

            private static staticctor_initialize = (() => {
                throw new Error("not yet implemented");
            })();
            private constructor() { }
            public constructor() {
                throw new Error("not yet implemented");
            }

            private __Register__b__12_0(obj: any) {
                throw new Error("not yet implemented");
            }
        }
    }
    export class TaskNode extends Task<boolean> implements IAsyncResult, IDisposable {
        private Prev: TaskNode;
        private Next: TaskNode;

        protected constructor() {
            throw new Error("not yet implemented");
        }

    }
    export class SemaphoreSlim implements IDisposable {
        private static readonly s_cancellationTokenCanceledEventHandler: Action<any>;

        private m_currentCount: number;
        private m_maxCount: number;
        private m_waitCount: number;
        private m_countOfWaitersPulsedToWake: number;
        private m_lockObjAndDisposed: StrongBox<boolean>;
        private m_waitHandle: ManualResetEvent;
        private m_asyncHead: TaskNode;
        private m_asyncTail: TaskNode;

        public get CurrentCount(): number {
            throw new Error("not yet implemented");
        }
        public get AvailableWaitHandle(): WaitHandle {
            throw new Error("not yet implemented");
        }

        public constructor(initialCount: number) {
            throw new Error("not yet implemented");
        }
        public constructor(initialCount: number, maxCount: number) {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

        public Wait() {
            throw new Error("not yet implemented");
        }
        public Wait(cancellationToken: CancellationToken) {
            throw new Error("not yet implemented");
        }
        public Wait(timeout: TimeSpan): boolean {
            throw new Error("not yet implemented");
        }
        public Wait(timeout: TimeSpan, cancellationToken: CancellationToken): boolean {
            throw new Error("not yet implemented");
        }
        public Wait(millisecondsTimeout: number): boolean {
            throw new Error("not yet implemented");
        }
        public Wait(millisecondsTimeout: number, cancellationToken: CancellationToken): boolean {
            throw new Error("not yet implemented");
        }
        private WaitUntilCountOrTimeout(millisecondsTimeout: number, startTime: number, cancellationToken: CancellationToken): boolean {
            throw new Error("not yet implemented");
        }
        public WaitAsync(): Task {
            throw new Error("not yet implemented");
        }
        public WaitAsync(cancellationToken: CancellationToken): Task {
            throw new Error("not yet implemented");
        }
        public WaitAsync(millisecondsTimeout: number): Task<boolean> {
            throw new Error("not yet implemented");
        }
        public WaitAsync(timeout: TimeSpan): Task<boolean> {
            throw new Error("not yet implemented");
        }
        public WaitAsync(timeout: TimeSpan, cancellationToken: CancellationToken): Task<boolean> {
            throw new Error("not yet implemented");
        }
        public WaitAsync(millisecondsTimeout: number, cancellationToken: CancellationToken): Task<boolean> {
            throw new Error("not yet implemented");
        }
        private CreateAndAddAsyncWaiter(): TaskNode {
            throw new Error("not yet implemented");
        }
        private RemoveAsyncWaiter(task: TaskNode): boolean {
            throw new Error("not yet implemented");
        }
        private WaitUntilCountOrTimeoutAsync(asyncWaiter: TaskNode, millisecondsTimeout: number, cancellationToken: CancellationToken): Task<boolean> {
            throw new Error("not yet implemented");
        }
        public Release(): number {
            throw new Error("not yet implemented");
        }
        public Release(releaseCount: number): number {
            throw new Error("not yet implemented");
        }
        public Dispose() {
            throw new Error("not yet implemented");
        }
        private Dispose(disposing: boolean) {
            throw new Error("not yet implemented");
        }
        private static CancellationTokenCanceledEventHandler(obj: any) {
            throw new Error("not yet implemented");
        }
        private CheckDispose() {
            throw new Error("not yet implemented");
        }
    }
    export namespace SemaphoreSlim {
        export class TaskNode extends Task<boolean> implements IAsyncResult, IDisposable {
            private Prev: TaskNode;
            private Next: TaskNode;

            protected constructor() {
                throw new Error("not yet implemented");
            }

        }

        export class __WaitUntilCountOrTimeoutAsync__d__31 extends ValueType implements IAsyncStateMachine {
            public ____1__state: number;
            public ____t__builder: AsyncTaskMethodBuilder<boolean>;
            public asyncWaiter: TaskNode;
            public millisecondsTimeout: number;
            public cancellationToken: CancellationToken;
            public ____4__this: SemaphoreSlim;
            private ____u__1: ConfiguredTaskAwaiter;
            private ____u__2: ConfiguredTaskAwaiter;

            private __explicit__MoveNext() {
                throw new Error("not yet implemented");
            }
            private __explicit__SetStateMachine(stateMachine: IAsyncStateMachine) {
                throw new Error("not yet implemented");
            }
        }
    }
    export interface IDeferredDisposable {
        OnFinalRelease(disposed: boolean): void;
    }
    export class DeferredDisposableLifetime<T> extends ValueType {
        private _count: number;

        public AddRef(): boolean {
            throw new Error("not yet implemented");
        }
        public Release(obj: T) {
            throw new Error("not yet implemented");
        }
        public Dispose(obj: T) {
            throw new Error("not yet implemented");
        }
    }
    export class NativeOverlapped extends ValueType {
        public InternalLow: number;
        public InternalHigh: number;
        public OffsetLow: number;
        public OffsetHigh: number;
        public EventHandle: number;

    }
    export class IOCompletionCallback extends MulticastDelegate implements ICloneable, ISerializable {
        public constructor(object: any, method: number) {
            throw new Error("not yet implemented");
        }

        public Invoke(errorCode: number, numBytes: number, pOVERLAP: NativeOverlapped*) {
            throw new Error("not yet implemented");
        }
        public BeginInvoke(errorCode: number, numBytes: number, pOVERLAP: NativeOverlapped*, callback: AsyncCallback, object: any): IAsyncResult {
            throw new Error("not yet implemented");
        }
        public EndInvoke(result: IAsyncResult) {
            throw new Error("not yet implemented");
        }
    }
    export class OverlappedData {
        private _pinnedData: GCHandle[];
        private _callback: IOCompletionCallback;
        private _state: any;
        private _executionContext: ExecutionContext;
        private _boundHandle: ThreadPoolBoundHandle;
        private _preAllocated: PreAllocatedOverlapped;
        private _completed: boolean;

        public constructor() {
            throw new Error("not yet implemented");
        }

        private Reset() {
            throw new Error("not yet implemented");
        }
    }
    export class ExecutionContextCallbackArgs {
        private _errorCode: number;
        private _bytesWritten: number;
        private _overlapped: Win32ThreadPoolNativeOverlapped*;
        private _data: OverlappedData;

        public constructor() {
            throw new Error("not yet implemented");
        }

    }
    export class Win32ThreadPoolNativeOverlapped extends ValueType {
        private static s_executionContextCallback: ContextCallback;
        private static s_dataArray: OverlappedData[];
        private static s_dataCount: number;
        private static s_freeList: number;
        private static t_executionContextCallbackArgs: ExecutionContextCallbackArgs;

        private _overlapped: NativeOverlapped;
        private _nextFree: number;
        private _dataIndex: number;

        private get Data(): OverlappedData {
            throw new Error("not yet implemented");
        }

        private static Allocate(callback: IOCompletionCallback, state: any, pinData: any, preAllocated: PreAllocatedOverlapped, flowExecutionControl: boolean): Win32ThreadPoolNativeOverlapped* {
            throw new Error("not yet implemented");
        }
        private static AllocateNew(): Win32ThreadPoolNativeOverlapped* {
            throw new Error("not yet implemented");
        }
        private SetData(callback: IOCompletionCallback, state: any, pinData: any, preAllocated: PreAllocatedOverlapped, flowExecutionContext: boolean) {
            throw new Error("not yet implemented");
        }
        private static Free(overlapped: Win32ThreadPoolNativeOverlapped*) {
            throw new Error("not yet implemented");
        }
        private static ToNativeOverlapped(overlapped: Win32ThreadPoolNativeOverlapped*): NativeOverlapped* {
            throw new Error("not yet implemented");
        }
        private static FromNativeOverlapped(overlapped: NativeOverlapped*): Win32ThreadPoolNativeOverlapped* {
            throw new Error("not yet implemented");
        }
        private static CompleteWithCallback(errorCode: number, bytesWritten: number, overlapped: Win32ThreadPoolNativeOverlapped*) {
            throw new Error("not yet implemented");
        }
        private static OnExecutionContextCallback(state: any) {
            throw new Error("not yet implemented");
        }
    }
    export namespace Win32ThreadPoolNativeOverlapped {
        export class ExecutionContextCallbackArgs {
            private _errorCode: number;
            private _bytesWritten: number;
            private _overlapped: Win32ThreadPoolNativeOverlapped*;
            private _data: OverlappedData;

            public constructor() {
                throw new Error("not yet implemented");
            }

        }

        export class OverlappedData {
            private _pinnedData: GCHandle[];
            private _callback: IOCompletionCallback;
            private _state: any;
            private _executionContext: ExecutionContext;
            private _boundHandle: ThreadPoolBoundHandle;
            private _preAllocated: PreAllocatedOverlapped;
            private _completed: boolean;

            public constructor() {
                throw new Error("not yet implemented");
            }

            private Reset() {
                throw new Error("not yet implemented");
            }
        }

        export class ____O {
            public static __0____OnExecutionContextCallback: ContextCallback;

        }
    }
    export class Overlapped {
        private _asyncResult: IAsyncResult;
        private _callback: any;
        private _pNativeOverlapped: NativeOverlapped*;
        private _eventHandle: number;
        private _offsetLow: number;
        private _offsetHigh: number;

        public get AsyncResult(): IAsyncResult {
            throw new Error("not yet implemented");
        }
        public set AsyncResult(value: IAsyncResult) {
            throw new Error("not yet implemented");
        }
        public get OffsetLow(): number {
            throw new Error("not yet implemented");
        }
        public set OffsetLow(value: number) {
            throw new Error("not yet implemented");
        }
        public get OffsetHigh(): number {
            throw new Error("not yet implemented");
        }
        public set OffsetHigh(value: number) {
            throw new Error("not yet implemented");
        }
        public get EventHandle(): number {
            throw new Error("not yet implemented");
        }
        public set EventHandle(value: number) {
            throw new Error("not yet implemented");
        }
        public get EventHandleIntPtr(): number {
            throw new Error("not yet implemented");
        }
        public set EventHandleIntPtr(value: number) {
            throw new Error("not yet implemented");
        }

        public constructor() {
            throw new Error("not yet implemented");
        }
        public constructor(offsetLo: number, offsetHi: number, hEvent: number, ar: IAsyncResult) {
            throw new Error("not yet implemented");
        }
        public constructor(offsetLo: number, offsetHi: number, hEvent: number, ar: IAsyncResult) {
            throw new Error("not yet implemented");
        }

        public Pack(iocb: IOCompletionCallback): NativeOverlapped* {
            throw new Error("not yet implemented");
        }
        public Pack(iocb: IOCompletionCallback, userData: any): NativeOverlapped* {
            throw new Error("not yet implemented");
        }
        public UnsafePack(iocb: IOCompletionCallback): NativeOverlapped* {
            throw new Error("not yet implemented");
        }
        public UnsafePack(iocb: IOCompletionCallback, userData: any): NativeOverlapped* {
            throw new Error("not yet implemented");
        }
        public static Unpack(nativeOverlappedPtr: NativeOverlapped*): Overlapped {
            throw new Error("not yet implemented");
        }
        public static Free(nativeOverlappedPtr: NativeOverlapped*) {
            throw new Error("not yet implemented");
        }
        private AllocateNativeOverlapped(userData: any): NativeOverlapped* {
            throw new Error("not yet implemented");
        }
        private static FreeNativeOverlapped(pNativeOverlapped: NativeOverlapped*) {
            throw new Error("not yet implemented");
        }
        private static GCHandleCountRef(pNativeOverlapped: NativeOverlapped*): number {
            throw new Error("not yet implemented");
        }
        private static GCHandleRef(pNativeOverlapped: NativeOverlapped*, index: number): GCHandle {
            throw new Error("not yet implemented");
        }
        private static GetOverlappedFromNative(pNativeOverlapped: NativeOverlapped*): Overlapped {
            throw new Error("not yet implemented");
        }
    }
    export class ThreadPoolBoundHandleOverlapped extends Overlapped {
        private static readonly s_completionCallback: IOCompletionCallback;

        private _userCallback: IOCompletionCallback;
        private _userState: any;
        private _preAllocated: PreAllocatedOverlapped;
        private _nativeOverlapped: NativeOverlapped*;
        private _boundHandle: ThreadPoolBoundHandle;
        private _completed: boolean;

        public constructor(callback: IOCompletionCallback, state: any, pinData: any, preAllocated: PreAllocatedOverlapped, flowExecutionContext: boolean) {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

        private static CompletionCallback(errorCode: number, numBytes: number, nativeOverlapped: NativeOverlapped*) {
            throw new Error("not yet implemented");
        }
    }
    export class PreAllocatedOverlapped implements IDisposable, IDeferredDisposable {
        private _overlappedWindowsThreadPool: Win32ThreadPoolNativeOverlapped*;
        private _lifetime: DeferredDisposableLifetime<PreAllocatedOverlapped>;
        private _overlappedPortableCore: ThreadPoolBoundHandleOverlapped;

        public constructor(callback: IOCompletionCallback, state: any, pinData: any) {
            throw new Error("not yet implemented");
        }
        private constructor(callback: IOCompletionCallback, state: any, pinData: any, flowExecutionContext: boolean) {
            throw new Error("not yet implemented");
        }

        private static UnsafeCreateWindowsThreadPool(callback: IOCompletionCallback, state: any, pinData: any): PreAllocatedOverlapped {
            throw new Error("not yet implemented");
        }
        private AddRefWindowsThreadPool(): boolean {
            throw new Error("not yet implemented");
        }
        private ReleaseWindowsThreadPool() {
            throw new Error("not yet implemented");
        }
        private DisposeWindowsThreadPool() {
            throw new Error("not yet implemented");
        }
        private IDeferredDisposableOnFinalReleaseWindowsThreadPool(disposed: boolean) {
            throw new Error("not yet implemented");
        }
        public static UnsafeCreate(callback: IOCompletionCallback, state: any, pinData: any): PreAllocatedOverlapped {
            throw new Error("not yet implemented");
        }
        private AddRef(): boolean {
            throw new Error("not yet implemented");
        }
        private Release() {
            throw new Error("not yet implemented");
        }
        public Dispose() {
            throw new Error("not yet implemented");
        }
        private Finalize() {
            throw new Error("not yet implemented");
        }
        private __explicit__IDeferredDisposable_OnFinalRelease(disposed: boolean) {
            throw new Error("not yet implemented");
        }
        public OnFinalRelease(disposed: boolean) {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private static UnsafeCreatePortableCore(callback: IOCompletionCallback, state: any, pinData: any): PreAllocatedOverlapped {
            throw new Error("not yet implemented");
        }
        private AddRefPortableCore(): boolean {
            throw new Error("not yet implemented");
        }
        private ReleasePortableCore() {
            throw new Error("not yet implemented");
        }
        private DisposePortableCore() {
            throw new Error("not yet implemented");
        }
        private IDeferredDisposableOnFinalReleasePortableCore(disposed: boolean) {
            throw new Error("not yet implemented");
        }
    }
    export class ThreadPoolBoundHandle implements IDisposable, IDeferredDisposable {
        private _handle: SafeHandle;
        private _threadPoolHandle: SafeThreadPoolIOHandle;
        private _lifetime: DeferredDisposableLifetime<ThreadPoolBoundHandle>;
        private _isDisposed: boolean;

        public get Handle(): SafeHandle {
            throw new Error("not yet implemented");
        }

        private constructor(handle: SafeHandle, threadPoolHandle: SafeThreadPoolIOHandle) {
            throw new Error("not yet implemented");
        }
        private constructor(handle: SafeHandle) {
            throw new Error("not yet implemented");
        }

        private static BindHandleWindowsThreadPool(handle: SafeHandle): ThreadPoolBoundHandle {
            throw new Error("not yet implemented");
        }
        private AllocateNativeOverlappedWindowsThreadPool(callback: IOCompletionCallback, state: any, pinData: any): NativeOverlapped* {
            throw new Error("not yet implemented");
        }
        private UnsafeAllocateNativeOverlappedWindowsThreadPool(callback: IOCompletionCallback, state: any, pinData: any): NativeOverlapped* {
            throw new Error("not yet implemented");
        }
        private AllocateNativeOverlappedWindowsThreadPool(callback: IOCompletionCallback, state: any, pinData: any, flowExecutionContext: boolean): NativeOverlapped* {
            throw new Error("not yet implemented");
        }
        private AllocateNativeOverlappedWindowsThreadPool(preAllocated: PreAllocatedOverlapped): NativeOverlapped* {
            throw new Error("not yet implemented");
        }
        private FreeNativeOverlappedWindowsThreadPool(overlapped: NativeOverlapped*) {
            throw new Error("not yet implemented");
        }
        private static GetNativeOverlappedStateWindowsThreadPool(overlapped: NativeOverlapped*): any {
            throw new Error("not yet implemented");
        }
        private static GetOverlappedData(overlapped: Win32ThreadPoolNativeOverlapped*, expectedBoundHandle: ThreadPoolBoundHandle): OverlappedData {
            throw new Error("not yet implemented");
        }
        private static OnNativeIOCompleted(instance: number, context: number, overlappedPtr: number, ioResult: number, numberOfBytesTransferred: number, ioPtr: number) {
            throw new Error("not yet implemented");
        }
        private AddRef(): boolean {
            throw new Error("not yet implemented");
        }
        private Release() {
            throw new Error("not yet implemented");
        }
        private DisposeWindowsThreadPool() {
            throw new Error("not yet implemented");
        }
        private FinalizeWindowsThreadPool() {
            throw new Error("not yet implemented");
        }
        private IDeferredDisposableOnFinalReleaseWindowsThreadPool(disposed: boolean) {
            throw new Error("not yet implemented");
        }
        private AllocateNativeOverlappedPortableCore(callback: IOCompletionCallback, state: any, pinData: any): NativeOverlapped* {
            throw new Error("not yet implemented");
        }
        private UnsafeAllocateNativeOverlappedPortableCore(callback: IOCompletionCallback, state: any, pinData: any): NativeOverlapped* {
            throw new Error("not yet implemented");
        }
        private AllocateNativeOverlappedPortableCore(callback: IOCompletionCallback, state: any, pinData: any, flowExecutionContext: boolean): NativeOverlapped* {
            throw new Error("not yet implemented");
        }
        private AllocateNativeOverlappedPortableCore(preAllocated: PreAllocatedOverlapped): NativeOverlapped* {
            throw new Error("not yet implemented");
        }
        private FreeNativeOverlappedPortableCore(overlapped: NativeOverlapped*) {
            throw new Error("not yet implemented");
        }
        private static GetNativeOverlappedStatePortableCore(overlapped: NativeOverlapped*): any {
            throw new Error("not yet implemented");
        }
        private static GetOverlappedWrapper(overlapped: NativeOverlapped*): ThreadPoolBoundHandleOverlapped {
            throw new Error("not yet implemented");
        }
        private DisposePortableCore() {
            throw new Error("not yet implemented");
        }
        private static BindHandleCore(handle: SafeHandle): ThreadPoolBoundHandle {
            throw new Error("not yet implemented");
        }
        public static BindHandle(handle: SafeHandle): ThreadPoolBoundHandle {
            throw new Error("not yet implemented");
        }
        public AllocateNativeOverlapped(callback: IOCompletionCallback, state: any, pinData: any): NativeOverlapped* {
            throw new Error("not yet implemented");
        }
        public UnsafeAllocateNativeOverlapped(callback: IOCompletionCallback, state: any, pinData: any): NativeOverlapped* {
            throw new Error("not yet implemented");
        }
        public AllocateNativeOverlapped(preAllocated: PreAllocatedOverlapped): NativeOverlapped* {
            throw new Error("not yet implemented");
        }
        public FreeNativeOverlapped(overlapped: NativeOverlapped*) {
            throw new Error("not yet implemented");
        }
        public static GetNativeOverlappedState(overlapped: NativeOverlapped*): any {
            throw new Error("not yet implemented");
        }
        public Dispose() {
            throw new Error("not yet implemented");
        }
        private Finalize() {
            throw new Error("not yet implemented");
        }
        private __explicit__IDeferredDisposable_OnFinalRelease(disposed: boolean) {
            throw new Error("not yet implemented");
        }
        public OnFinalRelease(disposed: boolean) {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
    }
    export class Thread extends CriticalFinalizerObject {
        private static readonly __OptimalMaxSpinWaitsPerSpinIteration__k__BackingField: number;
        private static s_asyncLocalPrincipal: AsyncLocal<IPrincipal>;
        private static readonly s_isProcessorNumberReallyFast: boolean;
        private static t_currentThread: Thread;

        private static get OptimalMaxSpinWaitsPerSpinIteration(): number {
            throw new Error("not yet implemented");
        }
        public static get CurrentPrincipal(): IPrincipal {
            throw new Error("not yet implemented");
        }
        public static set CurrentPrincipal(value: IPrincipal) {
            throw new Error("not yet implemented");
        }
        public static get CurrentThread(): Thread {
            throw new Error("not yet implemented");
        }
        private static get CurrentOSThreadId(): number {
            throw new Error("not yet implemented");
        }

        private _executionContext: ExecutionContext;
        private _synchronizationContext: SynchronizationContext;
        private _name: string;
        private _startHelper: StartHelper;
        private _DONT_USE_InternalThread: number;
        private _priority: number;
        private _managedThreadId: number;
        private _mayNeedResetForThreadPool: boolean;

        public get ManagedThreadId(): number {
            throw new Error("not yet implemented");
        }
        public get IsAlive(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsBackground(): boolean {
            throw new Error("not yet implemented");
        }
        public set IsBackground(value: boolean) {
            throw new Error("not yet implemented");
        }
        public get IsThreadPoolThread(): boolean {
            throw new Error("not yet implemented");
        }
        private set IsThreadPoolThread(value: boolean) {
            throw new Error("not yet implemented");
        }
        public get Priority(): ThreadPriority {
            throw new Error("not yet implemented");
        }
        public set Priority(value: ThreadPriority) {
            throw new Error("not yet implemented");
        }
        public get ThreadState(): ThreadState {
            throw new Error("not yet implemented");
        }
        public get CurrentCulture(): CultureInfo {
            throw new Error("not yet implemented");
        }
        public set CurrentCulture(value: CultureInfo) {
            throw new Error("not yet implemented");
        }
        public get CurrentUICulture(): CultureInfo {
            throw new Error("not yet implemented");
        }
        public set CurrentUICulture(value: CultureInfo) {
            throw new Error("not yet implemented");
        }
        public get ExecutionContext(): ExecutionContext {
            throw new Error("not yet implemented");
        }
        public get Name(): string {
            throw new Error("not yet implemented");
        }
        public set Name(value: string) {
            throw new Error("not yet implemented");
        }
        public get ApartmentState(): ApartmentState {
            throw new Error("not yet implemented");
        }
        public set ApartmentState(value: ApartmentState) {
            throw new Error("not yet implemented");
        }

        private constructor() {
            throw new Error("not yet implemented");
        }
        public constructor(start: ThreadStart) {
            throw new Error("not yet implemented");
        }
        public constructor(start: ThreadStart, maxStackSize: number) {
            throw new Error("not yet implemented");
        }
        public constructor(start: ParameterizedThreadStart) {
            throw new Error("not yet implemented");
        }
        public constructor(start: ParameterizedThreadStart, maxStackSize: number) {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

        private GetNativeHandle(): ThreadHandle {
            throw new Error("not yet implemented");
        }
        private StartCore() {
            throw new Error("not yet implemented");
        }
        private static StartInternal(t: ThreadHandle, stackSize: number, priority: number, pThreadName: string*) {
            throw new Error("not yet implemented");
        }
        private StartCallback() {
            throw new Error("not yet implemented");
        }
        private static InternalGetCurrentThread(): number {
            throw new Error("not yet implemented");
        }
        private static SleepInternal(millisecondsTimeout: number) {
            throw new Error("not yet implemented");
        }
        private static SpinWaitInternal(iterations: number) {
            throw new Error("not yet implemented");
        }
        public static SpinWait(iterations: number) {
            throw new Error("not yet implemented");
        }
        private static YieldInternal(): BOOL {
            throw new Error("not yet implemented");
        }
        public static Yield(): boolean {
            throw new Error("not yet implemented");
        }
        private static InitializeCurrentThread(): Thread {
            throw new Error("not yet implemented");
        }
        private static GetCurrentThreadNative(): Thread {
            throw new Error("not yet implemented");
        }
        private Initialize() {
            throw new Error("not yet implemented");
        }
        private Finalize() {
            throw new Error("not yet implemented");
        }
        private InternalFinalize() {
            throw new Error("not yet implemented");
        }
        private static InformThreadNameChange(t: ThreadHandle, name: string, len: number) {
            throw new Error("not yet implemented");
        }
        private IsBackgroundNative(): boolean {
            throw new Error("not yet implemented");
        }
        private SetBackgroundNative(isBackground: boolean) {
            throw new Error("not yet implemented");
        }
        private GetPriorityNative(): number {
            throw new Error("not yet implemented");
        }
        private SetPriorityNative(priority: number) {
            throw new Error("not yet implemented");
        }
        private static GetCurrentOSThreadId(): number {
            throw new Error("not yet implemented");
        }
        private GetThreadStateNative(): number {
            throw new Error("not yet implemented");
        }
        public GetApartmentState(): ApartmentState {
            throw new Error("not yet implemented");
        }
        private SetApartmentStateUnchecked(state: ApartmentState, throwOnError: boolean): boolean {
            throw new Error("not yet implemented");
        }
        private GetApartmentStateNative(): number {
            throw new Error("not yet implemented");
        }
        private SetApartmentStateNative(state: number): number {
            throw new Error("not yet implemented");
        }
        public DisableComObjectEagerCleanup() {
            throw new Error("not yet implemented");
        }
        public Interrupt() {
            throw new Error("not yet implemented");
        }
        public Join(millisecondsTimeout: number): boolean {
            throw new Error("not yet implemented");
        }
        private ResetThreadPoolThread() {
            throw new Error("not yet implemented");
        }
        private static ThrowIfNoThreadStart(internalThread: boolean) {
            throw new Error("not yet implemented");
        }
        public Start(parameter: any) {
            throw new Error("not yet implemented");
        }
        public UnsafeStart(parameter: any) {
            throw new Error("not yet implemented");
        }
        private Start(parameter: any, captureContext: boolean, internalThread: boolean) {
            throw new Error("not yet implemented");
        }
        public Start() {
            throw new Error("not yet implemented");
        }
        public UnsafeStart() {
            throw new Error("not yet implemented");
        }
        private InternalUnsafeStart() {
            throw new Error("not yet implemented");
        }
        private Start(captureContext: boolean, internalThread: boolean) {
            throw new Error("not yet implemented");
        }
        private RequireCurrentThread() {
            throw new Error("not yet implemented");
        }
        private SetCultureOnUnstartedThread(value: CultureInfo, uiCulture: boolean) {
            throw new Error("not yet implemented");
        }
        private ThreadNameChanged(value: string) {
            throw new Error("not yet implemented");
        }
        public static Sleep(millisecondsTimeout: number) {
            throw new Error("not yet implemented");
        }
        private SetThreadPoolWorkerThreadName() {
            throw new Error("not yet implemented");
        }
        private ResetThreadPoolThreadSlow() {
            throw new Error("not yet implemented");
        }
        public Abort() {
            throw new Error("not yet implemented");
        }
        public Abort(stateInfo: any) {
            throw new Error("not yet implemented");
        }
        public static ResetAbort() {
            throw new Error("not yet implemented");
        }
        public Suspend() {
            throw new Error("not yet implemented");
        }
        public Resume() {
            throw new Error("not yet implemented");
        }
        public static BeginCriticalRegion() {
            throw new Error("not yet implemented");
        }
        public static EndCriticalRegion() {
            throw new Error("not yet implemented");
        }
        public static BeginThreadAffinity() {
            throw new Error("not yet implemented");
        }
        public static EndThreadAffinity() {
            throw new Error("not yet implemented");
        }
        public static AllocateDataSlot(): LocalDataStoreSlot {
            throw new Error("not yet implemented");
        }
        public static AllocateNamedDataSlot(name: string): LocalDataStoreSlot {
            throw new Error("not yet implemented");
        }
        public static GetNamedDataSlot(name: string): LocalDataStoreSlot {
            throw new Error("not yet implemented");
        }
        public static FreeNamedDataSlot(name: string) {
            throw new Error("not yet implemented");
        }
        public static GetData(slot: LocalDataStoreSlot): any {
            throw new Error("not yet implemented");
        }
        public static SetData(slot: LocalDataStoreSlot, data: any) {
            throw new Error("not yet implemented");
        }
        public SetApartmentState(state: ApartmentState) {
            throw new Error("not yet implemented");
        }
        public TrySetApartmentState(state: ApartmentState): boolean {
            throw new Error("not yet implemented");
        }
        private SetApartmentState(state: ApartmentState, throwOnError: boolean): boolean {
            throw new Error("not yet implemented");
        }
        public GetCompressedStack(): CompressedStack {
            throw new Error("not yet implemented");
        }
        public SetCompressedStack(stack: CompressedStack) {
            throw new Error("not yet implemented");
        }
        public static GetDomain(): AppDomain {
            throw new Error("not yet implemented");
        }
        public static GetDomainID(): number {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public Join() {
            throw new Error("not yet implemented");
        }
        public Join(timeout: TimeSpan): boolean {
            throw new Error("not yet implemented");
        }
        public static MemoryBarrier() {
            throw new Error("not yet implemented");
        }
        public static Sleep(timeout: TimeSpan) {
            throw new Error("not yet implemented");
        }
        public static VolatileRead(ref address: number): number {
            throw new Error("not yet implemented");
        }
        public static VolatileRead(ref address: number): number {
            throw new Error("not yet implemented");
        }
        public static VolatileRead(ref address: number): number {
            throw new Error("not yet implemented");
        }
        public static VolatileRead(ref address: number): number {
            throw new Error("not yet implemented");
        }
        public static VolatileRead(ref address: number): number {
            throw new Error("not yet implemented");
        }
        public static VolatileRead(ref address: number): number {
            throw new Error("not yet implemented");
        }
        public static VolatileRead(ref address: any): any {
            throw new Error("not yet implemented");
        }
        public static VolatileRead(ref address: number): number {
            throw new Error("not yet implemented");
        }
        public static VolatileRead(ref address: number): number {
            throw new Error("not yet implemented");
        }
        public static VolatileRead(ref address: number): number {
            throw new Error("not yet implemented");
        }
        public static VolatileRead(ref address: number): number {
            throw new Error("not yet implemented");
        }
        public static VolatileRead(ref address: number): number {
            throw new Error("not yet implemented");
        }
        public static VolatileRead(ref address: number): number {
            throw new Error("not yet implemented");
        }
        public static VolatileWrite(ref address: number, value: number) {
            throw new Error("not yet implemented");
        }
        public static VolatileWrite(ref address: number, value: number) {
            throw new Error("not yet implemented");
        }
        public static VolatileWrite(ref address: number, value: number) {
            throw new Error("not yet implemented");
        }
        public static VolatileWrite(ref address: number, value: number) {
            throw new Error("not yet implemented");
        }
        public static VolatileWrite(ref address: number, value: number) {
            throw new Error("not yet implemented");
        }
        public static VolatileWrite(ref address: number, value: number) {
            throw new Error("not yet implemented");
        }
        public static VolatileWrite(ref address: any, value: any) {
            throw new Error("not yet implemented");
        }
        public static VolatileWrite(ref address: number, value: number) {
            throw new Error("not yet implemented");
        }
        public static VolatileWrite(ref address: number, value: number) {
            throw new Error("not yet implemented");
        }
        public static VolatileWrite(ref address: number, value: number) {
            throw new Error("not yet implemented");
        }
        public static VolatileWrite(ref address: number, value: number) {
            throw new Error("not yet implemented");
        }
        public static VolatileWrite(ref address: number, value: number) {
            throw new Error("not yet implemented");
        }
        public static VolatileWrite(ref address: number, value: number) {
            throw new Error("not yet implemented");
        }
        public static GetCurrentProcessorId(): number {
            throw new Error("not yet implemented");
        }
        private static UninterruptibleSleep0() {
            throw new Error("not yet implemented");
        }
        private static GetCurrentProcessorNumber(): number {
            throw new Error("not yet implemented");
        }
        private static __InformThreadNameChange__g____PInvoke_26_0(__t_native: ThreadHandle, __name_native: number*, __len_native: number) {
            throw new Error("not yet implemented");
        }
    }
    export namespace Thread {
        export class StartHelper {
            private static readonly s_threadStartContextCallback: ContextCallback;

            private _maxStackSize: number;
            private _start: Delegate;
            private _startArg: any;
            private _culture: CultureInfo;
            private _uiCulture: CultureInfo;
            private _executionContext: ExecutionContext;

            protected constructor(start: Delegate) {
                throw new Error("not yet implemented");
            }
            private static staticctor_initialize = (() => {
                throw new Error("not yet implemented");
            })();
            private constructor() { }

            private static Callback(state: any) {
                throw new Error("not yet implemented");
            }
            private Run() {
                throw new Error("not yet implemented");
            }
            private RunWorker() {
                throw new Error("not yet implemented");
            }
            private InitializeCulture() {
                throw new Error("not yet implemented");
            }
        }

        export class LocalDataStore {
            private static s_nameToSlotMap: Dictionary<string, LocalDataStoreSlot>;

            public static AllocateSlot(): LocalDataStoreSlot {
                throw new Error("not yet implemented");
            }
            private static EnsureNameToSlotMap(): Dictionary<string, LocalDataStoreSlot> {
                throw new Error("not yet implemented");
            }
            public static AllocateNamedSlot(name: string): LocalDataStoreSlot {
                throw new Error("not yet implemented");
            }
            public static GetNamedSlot(name: string): LocalDataStoreSlot {
                throw new Error("not yet implemented");
            }
            public static FreeNamedSlot(name: string) {
                throw new Error("not yet implemented");
            }
            private static GetThreadLocal(slot: LocalDataStoreSlot): ThreadLocal<any> {
                throw new Error("not yet implemented");
            }
            public static GetData(slot: LocalDataStoreSlot): any {
                throw new Error("not yet implemented");
            }
            public static SetData(slot: LocalDataStoreSlot, value: any) {
                throw new Error("not yet implemented");
            }
        }
    }
    export class AsyncFlowControl extends ValueType implements IEquatable<AsyncFlowControl>, IDisposable {
        private _thread: Thread;

        private Initialize(currentThread: Thread) {
            throw new Error("not yet implemented");
        }
        public Undo() {
            throw new Error("not yet implemented");
        }
        public Dispose() {
            throw new Error("not yet implemented");
        }
        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public Equals(obj: AsyncFlowControl): boolean {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
    }
    export class ExecutionContext implements IDisposable, ISerializable {
        private static readonly Default: ExecutionContext;
        private static s_defaultFlowSuppressed: ExecutionContext;

        private m_localValues: IAsyncLocalValueMap;
        private m_localChangeNotifications: IAsyncLocal[];
        private m_isFlowSuppressed: boolean;
        private m_isDefault: boolean;

        private get HasChangeNotifications(): boolean {
            throw new Error("not yet implemented");
        }
        private get IsDefault(): boolean {
            throw new Error("not yet implemented");
        }

        private constructor() {
            throw new Error("not yet implemented");
        }
        private constructor(localValues: IAsyncLocalValueMap, localChangeNotifications: IAsyncLocal[], isFlowSuppressed: boolean) {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

        public GetObjectData(info: SerializationInfo, context: StreamingContext) {
            throw new Error("not yet implemented");
        }
        public static Capture(): ExecutionContext {
            throw new Error("not yet implemented");
        }
        private static CaptureForRestore(): ExecutionContext {
            throw new Error("not yet implemented");
        }
        private ShallowClone(isFlowSuppressed: boolean): ExecutionContext {
            throw new Error("not yet implemented");
        }
        public static SuppressFlow(): AsyncFlowControl {
            throw new Error("not yet implemented");
        }
        public static RestoreFlow() {
            throw new Error("not yet implemented");
        }
        public static IsFlowSuppressed(): boolean {
            throw new Error("not yet implemented");
        }
        public static Run(executionContext: ExecutionContext, callback: ContextCallback, state: any) {
            throw new Error("not yet implemented");
        }
        private static RunInternal(executionContext: ExecutionContext, callback: ContextCallback, state: any) {
            throw new Error("not yet implemented");
        }
        public static Restore(executionContext: ExecutionContext) {
            throw new Error("not yet implemented");
        }
        private static RestoreInternal(executionContext: ExecutionContext) {
            throw new Error("not yet implemented");
        }
        private static RunFromThreadPoolDispatchLoop(threadPoolThread: Thread, executionContext: ExecutionContext, callback: ContextCallback, state: any) {
            throw new Error("not yet implemented");
        }
        private static RunForThreadPoolUnsafe(executionContext: ExecutionContext, callback: Action<TState>, ref state: TState) {
            throw new Error("not yet implemented");
        }
        private static RestoreChangedContextToThread(currentThread: Thread, contextToRestore: ExecutionContext, currentContext: ExecutionContext) {
            throw new Error("not yet implemented");
        }
        private static ResetThreadPoolThread(currentThread: Thread) {
            throw new Error("not yet implemented");
        }
        private static OnValuesChanged(previousExecutionCtx: ExecutionContext, nextExecutionCtx: ExecutionContext) {
            throw new Error("not yet implemented");
        }
        private static ThrowNullContext() {
            throw new Error("not yet implemented");
        }
        private static GetLocalValue(local: IAsyncLocal): any {
            throw new Error("not yet implemented");
        }
        private static SetLocalValue(local: IAsyncLocal, newValue: any, needChangeNotifications: boolean) {
            throw new Error("not yet implemented");
        }
        public CreateCopy(): ExecutionContext {
            throw new Error("not yet implemented");
        }
        public Dispose() {
            throw new Error("not yet implemented");
        }
    }
    export class ManualResetEventSlim implements IDisposable {
        private static readonly s_cancellationTokenCallback: Action<any>;

        private m_lock: any;
        private m_eventObj: ManualResetEvent;
        private m_combinedState: number;

        public get WaitHandle(): WaitHandle {
            throw new Error("not yet implemented");
        }
        public get IsSet(): boolean {
            throw new Error("not yet implemented");
        }
        private set IsSet(value: boolean) {
            throw new Error("not yet implemented");
        }
        public get SpinCount(): number {
            throw new Error("not yet implemented");
        }
        private set SpinCount(value: number) {
            throw new Error("not yet implemented");
        }
        private get Waiters(): number {
            throw new Error("not yet implemented");
        }
        private set Waiters(value: number) {
            throw new Error("not yet implemented");
        }
        private get IsDisposed(): boolean {
            throw new Error("not yet implemented");
        }

        public constructor() {
            throw new Error("not yet implemented");
        }
        public constructor(initialState: boolean) {
            throw new Error("not yet implemented");
        }
        public constructor(initialState: boolean, spinCount: number) {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

        private Initialize(initialState: boolean, spinCount: number) {
            throw new Error("not yet implemented");
        }
        private EnsureLockObjectCreated() {
            throw new Error("not yet implemented");
        }
        private LazyInitializeEvent() {
            throw new Error("not yet implemented");
        }
        public Set() {
            throw new Error("not yet implemented");
        }
        private Set(duringCancellation: boolean) {
            throw new Error("not yet implemented");
        }
        public Reset() {
            throw new Error("not yet implemented");
        }
        public Wait() {
            throw new Error("not yet implemented");
        }
        public Wait(cancellationToken: CancellationToken) {
            throw new Error("not yet implemented");
        }
        public Wait(timeout: TimeSpan): boolean {
            throw new Error("not yet implemented");
        }
        public Wait(timeout: TimeSpan, cancellationToken: CancellationToken): boolean {
            throw new Error("not yet implemented");
        }
        public Wait(millisecondsTimeout: number): boolean {
            throw new Error("not yet implemented");
        }
        public Wait(millisecondsTimeout: number, cancellationToken: CancellationToken): boolean {
            throw new Error("not yet implemented");
        }
        public Dispose() {
            throw new Error("not yet implemented");
        }
        private Dispose(disposing: boolean) {
            throw new Error("not yet implemented");
        }
        private static CancellationTokenCallback(obj: any) {
            throw new Error("not yet implemented");
        }
        private UpdateStateAtomically(newBits: number, updateBitsMask: number) {
            throw new Error("not yet implemented");
        }
        private static ExtractStatePortionAndShiftRight(state: number, mask: number, rightBitShiftCount: number): number {
            throw new Error("not yet implemented");
        }
        private static ExtractStatePortion(state: number, mask: number): number {
            throw new Error("not yet implemented");
        }
    }
    export class WaitCallback extends MulticastDelegate implements ICloneable, ISerializable {
        public constructor(object: any, method: number) {
            throw new Error("not yet implemented");
        }

        public Invoke(state: any) {
            throw new Error("not yet implemented");
        }
        public BeginInvoke(state: any, callback: AsyncCallback, object: any): IAsyncResult {
            throw new Error("not yet implemented");
        }
        public EndInvoke(result: IAsyncResult) {
            throw new Error("not yet implemented");
        }
    }
    export enum StackCrawlMark {
        LookForMe = 0,
        LookForMyCaller = 1,
        LookForMyCallersCaller = 2,
        LookForThread = 3,
    }
}
export namespace System.Threading.Tasks {
    export class UnobservedTaskExceptionEventArgs extends EventArgs {
        private m_exception: AggregateException;
        private m_observed: boolean;

        public get Observed(): boolean {
            throw new Error("not yet implemented");
        }
        public get Exception(): AggregateException {
            throw new Error("not yet implemented");
        }

        public constructor(exception: AggregateException) {
            throw new Error("not yet implemented");
        }

        public SetObserved() {
            throw new Error("not yet implemented");
        }
    }
    export abstract class TaskScheduler {
        private static s_activeTaskSchedulers: ConditionalWeakTable<TaskScheduler, any>;
        private static readonly s_defaultTaskScheduler: TaskScheduler;
        private static s_taskSchedulerIdCounter: number;
        private static UnobservedTaskException: EventHandler<UnobservedTaskExceptionEventArgs>;

        public static get Default(): TaskScheduler {
            throw new Error("not yet implemented");
        }
        public static get Current(): TaskScheduler {
            throw new Error("not yet implemented");
        }
        private static get InternalCurrent(): TaskScheduler {
            throw new Error("not yet implemented");
        }

        private m_taskSchedulerId: number;

        public get MaximumConcurrencyLevel(): number {
            throw new Error("not yet implemented");
        }
        public get Id(): number {
            throw new Error("not yet implemented");
        }

        protected constructor() {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

        private QueueTask(task: Task): void;
        private TryExecuteTaskInline(task: Task, taskWasPreviouslyQueued: boolean): boolean;
        private GetScheduledTasks(): IEnumerable<Task>;
        private TryRunInline(task: Task, taskWasPreviouslyQueued: boolean): boolean {
            throw new Error("not yet implemented");
        }
        private TryDequeue(task: Task): boolean {
            throw new Error("not yet implemented");
        }
        private NotifyWorkItemProgress() {
            throw new Error("not yet implemented");
        }
        private InternalQueueTask(task: Task) {
            throw new Error("not yet implemented");
        }
        private AddToActiveTaskSchedulers() {
            throw new Error("not yet implemented");
        }
        public static FromCurrentSynchronizationContext(): TaskScheduler {
            throw new Error("not yet implemented");
        }
        private TryExecuteTask(task: Task): boolean {
            throw new Error("not yet implemented");
        }
        private static PublishUnobservedTaskException(sender: any, ueea: UnobservedTaskExceptionEventArgs) {
            throw new Error("not yet implemented");
        }
        private GetScheduledTasksForDebugger(): Task[] {
            throw new Error("not yet implemented");
        }
        private static GetTaskSchedulersForDebugger(): TaskScheduler[] {
            throw new Error("not yet implemented");
        }
    }
    export namespace TaskScheduler {
        export class SystemThreadingTasks_TaskSchedulerDebugView {
            private m_taskScheduler: TaskScheduler;

            public get Id(): number {
                throw new Error("not yet implemented");
            }
            public get ScheduledTasks(): IEnumerable<Task> {
                throw new Error("not yet implemented");
            }

            public constructor(scheduler: TaskScheduler) {
                throw new Error("not yet implemented");
            }

        }
    }
    export enum TaskCreationOptions {
        None = 0x0,
        PreferFairness = 0x1,
        LongRunning = 0x2,
        AttachedToParent = 0x4,
        DenyChildAttach = 0x8,
        HideScheduler = 0x10,
        RunContinuationsAsynchronously = 0x40,
    }
    export enum TaskContinuationOptions {
        None = 0x0,
        PreferFairness = 0x1,
        LongRunning = 0x2,
        AttachedToParent = 0x4,
        DenyChildAttach = 0x8,
        HideScheduler = 0x10,
        LazyCancellation = 0x20,
        RunContinuationsAsynchronously = 0x40,
        NotOnRanToCompletion = 0x10000,
        NotOnFaulted = 0x20000,
        OnlyOnCanceled = 0x30000,
        NotOnCanceled = 0x40000,
        OnlyOnFaulted = 0x50000,
        OnlyOnRanToCompletion = 0x60000,
        ExecuteSynchronously = 0x80000,
    }
    export class TaskFactory<TResult> {
        private m_defaultCancellationToken: CancellationToken;
        private m_defaultScheduler: TaskScheduler;
        private m_defaultCreationOptions: TaskCreationOptions;
        private m_defaultContinuationOptions: TaskContinuationOptions;

        private get DefaultScheduler(): TaskScheduler {
            throw new Error("not yet implemented");
        }
        public get CancellationToken(): CancellationToken {
            throw new Error("not yet implemented");
        }
        public get Scheduler(): TaskScheduler {
            throw new Error("not yet implemented");
        }
        public get CreationOptions(): TaskCreationOptions {
            throw new Error("not yet implemented");
        }
        public get ContinuationOptions(): TaskContinuationOptions {
            throw new Error("not yet implemented");
        }

        public constructor() {
            throw new Error("not yet implemented");
        }
        public constructor(cancellationToken: CancellationToken) {
            throw new Error("not yet implemented");
        }
        public constructor(scheduler: TaskScheduler) {
            throw new Error("not yet implemented");
        }
        public constructor(creationOptions: TaskCreationOptions, continuationOptions: TaskContinuationOptions) {
            throw new Error("not yet implemented");
        }
        public constructor(cancellationToken: CancellationToken, creationOptions: TaskCreationOptions, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler) {
            throw new Error("not yet implemented");
        }

        private GetDefaultScheduler(currTask: Task): TaskScheduler {
            throw new Error("not yet implemented");
        }
        public StartNew(function: Func<TResult>): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public StartNew(function: Func<TResult>, cancellationToken: CancellationToken): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public StartNew(function: Func<TResult>, creationOptions: TaskCreationOptions): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public StartNew(function: Func<TResult>, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions, scheduler: TaskScheduler): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public StartNew(function: Func<any, TResult>, state: any): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public StartNew(function: Func<any, TResult>, state: any, cancellationToken: CancellationToken): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public StartNew(function: Func<any, TResult>, state: any, creationOptions: TaskCreationOptions): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public StartNew(function: Func<any, TResult>, state: any, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions, scheduler: TaskScheduler): Task<TResult> {
            throw new Error("not yet implemented");
        }
        private static FromAsyncCoreLogic(iar: IAsyncResult, endFunction: Func<IAsyncResult, TResult>, endAction: Action<IAsyncResult>, promise: Task<TResult>, requiresSynchronization: boolean) {
            throw new Error("not yet implemented");
        }
        public FromAsync(asyncResult: IAsyncResult, endMethod: Func<IAsyncResult, TResult>): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public FromAsync(asyncResult: IAsyncResult, endMethod: Func<IAsyncResult, TResult>, creationOptions: TaskCreationOptions): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public FromAsync(asyncResult: IAsyncResult, endMethod: Func<IAsyncResult, TResult>, creationOptions: TaskCreationOptions, scheduler: TaskScheduler): Task<TResult> {
            throw new Error("not yet implemented");
        }
        private static FromAsyncImpl(asyncResult: IAsyncResult, endFunction: Func<IAsyncResult, TResult>, endAction: Action<IAsyncResult>, creationOptions: TaskCreationOptions, scheduler: TaskScheduler): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public FromAsync(beginMethod: Func<AsyncCallback, any, IAsyncResult>, endMethod: Func<IAsyncResult, TResult>, state: any): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public FromAsync(beginMethod: Func<AsyncCallback, any, IAsyncResult>, endMethod: Func<IAsyncResult, TResult>, state: any, creationOptions: TaskCreationOptions): Task<TResult> {
            throw new Error("not yet implemented");
        }
        private static FromAsyncImpl(beginMethod: Func<AsyncCallback, any, IAsyncResult>, endFunction: Func<IAsyncResult, TResult>, endAction: Action<IAsyncResult>, state: any, creationOptions: TaskCreationOptions): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public FromAsync(beginMethod: Func<TArg1, AsyncCallback, any, IAsyncResult>, endMethod: Func<IAsyncResult, TResult>, arg1: TArg1, state: any): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public FromAsync(beginMethod: Func<TArg1, AsyncCallback, any, IAsyncResult>, endMethod: Func<IAsyncResult, TResult>, arg1: TArg1, state: any, creationOptions: TaskCreationOptions): Task<TResult> {
            throw new Error("not yet implemented");
        }
        private static FromAsyncImpl(beginMethod: Func<TArg1, AsyncCallback, any, IAsyncResult>, endFunction: Func<IAsyncResult, TResult>, endAction: Action<IAsyncResult>, arg1: TArg1, state: any, creationOptions: TaskCreationOptions): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public FromAsync(beginMethod: Func<TArg1, TArg2, AsyncCallback, any, IAsyncResult>, endMethod: Func<IAsyncResult, TResult>, arg1: TArg1, arg2: TArg2, state: any): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public FromAsync(beginMethod: Func<TArg1, TArg2, AsyncCallback, any, IAsyncResult>, endMethod: Func<IAsyncResult, TResult>, arg1: TArg1, arg2: TArg2, state: any, creationOptions: TaskCreationOptions): Task<TResult> {
            throw new Error("not yet implemented");
        }
        private static FromAsyncImpl(beginMethod: Func<TArg1, TArg2, AsyncCallback, any, IAsyncResult>, endFunction: Func<IAsyncResult, TResult>, endAction: Action<IAsyncResult>, arg1: TArg1, arg2: TArg2, state: any, creationOptions: TaskCreationOptions): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public FromAsync(beginMethod: Func<TArg1, TArg2, TArg3, AsyncCallback, any, IAsyncResult>, endMethod: Func<IAsyncResult, TResult>, arg1: TArg1, arg2: TArg2, arg3: TArg3, state: any): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public FromAsync(beginMethod: Func<TArg1, TArg2, TArg3, AsyncCallback, any, IAsyncResult>, endMethod: Func<IAsyncResult, TResult>, arg1: TArg1, arg2: TArg2, arg3: TArg3, state: any, creationOptions: TaskCreationOptions): Task<TResult> {
            throw new Error("not yet implemented");
        }
        private static FromAsyncImpl(beginMethod: Func<TArg1, TArg2, TArg3, AsyncCallback, any, IAsyncResult>, endFunction: Func<IAsyncResult, TResult>, endAction: Action<IAsyncResult>, arg1: TArg1, arg2: TArg2, arg3: TArg3, state: any, creationOptions: TaskCreationOptions): Task<TResult> {
            throw new Error("not yet implemented");
        }
        private static FromAsyncTrim(thisRef: TInstance, args: TArgs, beginMethod: Func<TInstance, TArgs, AsyncCallback, any, IAsyncResult>, endMethod: Func<TInstance, IAsyncResult, TResult>): Task<TResult> {
            throw new Error("not yet implemented");
        }
        private static CreateCanceledTask(continuationOptions: TaskContinuationOptions, ct: CancellationToken): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAll(tasks: Task[], continuationFunction: Func<Task[], TResult>): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAll(tasks: Task[], continuationFunction: Func<Task[], TResult>, cancellationToken: CancellationToken): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAll(tasks: Task[], continuationFunction: Func<Task[], TResult>, continuationOptions: TaskContinuationOptions): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAll(tasks: Task[], continuationFunction: Func<Task[], TResult>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAll(tasks: Task<TAntecedentResult>[], continuationFunction: Func<Task<TAntecedentResult>[], TResult>): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAll(tasks: Task<TAntecedentResult>[], continuationFunction: Func<Task<TAntecedentResult>[], TResult>, cancellationToken: CancellationToken): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAll(tasks: Task<TAntecedentResult>[], continuationFunction: Func<Task<TAntecedentResult>[], TResult>, continuationOptions: TaskContinuationOptions): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAll(tasks: Task<TAntecedentResult>[], continuationFunction: Func<Task<TAntecedentResult>[], TResult>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task<TResult> {
            throw new Error("not yet implemented");
        }
        private static ContinueWhenAllImpl(tasks: Task<TAntecedentResult>[], continuationFunction: Func<Task<TAntecedentResult>[], TResult>, continuationAction: Action<Task<TAntecedentResult>[]>, continuationOptions: TaskContinuationOptions, cancellationToken: CancellationToken, scheduler: TaskScheduler): Task<TResult> {
            throw new Error("not yet implemented");
        }
        private static ContinueWhenAllImpl(tasks: Task[], continuationFunction: Func<Task[], TResult>, continuationAction: Action<Task[]>, continuationOptions: TaskContinuationOptions, cancellationToken: CancellationToken, scheduler: TaskScheduler): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAny(tasks: Task[], continuationFunction: Func<Task, TResult>): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAny(tasks: Task[], continuationFunction: Func<Task, TResult>, cancellationToken: CancellationToken): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAny(tasks: Task[], continuationFunction: Func<Task, TResult>, continuationOptions: TaskContinuationOptions): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAny(tasks: Task[], continuationFunction: Func<Task, TResult>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAny(tasks: Task<TAntecedentResult>[], continuationFunction: Func<Task<TAntecedentResult>, TResult>): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAny(tasks: Task<TAntecedentResult>[], continuationFunction: Func<Task<TAntecedentResult>, TResult>, cancellationToken: CancellationToken): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAny(tasks: Task<TAntecedentResult>[], continuationFunction: Func<Task<TAntecedentResult>, TResult>, continuationOptions: TaskContinuationOptions): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAny(tasks: Task<TAntecedentResult>[], continuationFunction: Func<Task<TAntecedentResult>, TResult>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task<TResult> {
            throw new Error("not yet implemented");
        }
        private static ContinueWhenAnyImpl(tasks: Task[], continuationFunction: Func<Task, TResult>, continuationAction: Action<Task>, continuationOptions: TaskContinuationOptions, cancellationToken: CancellationToken, scheduler: TaskScheduler): Task<TResult> {
            throw new Error("not yet implemented");
        }
        private static ContinueWhenAnyImpl(tasks: Task<TAntecedentResult>[], continuationFunction: Func<Task<TAntecedentResult>, TResult>, continuationAction: Action<Task<TAntecedentResult>>, continuationOptions: TaskContinuationOptions, cancellationToken: CancellationToken, scheduler: TaskScheduler): Task<TResult> {
            throw new Error("not yet implemented");
        }
    }
    export namespace TaskFactory {
        export class FromAsyncTrimPromise<TResult, TInstance> extends Task<TResult> implements IAsyncResult, IDisposable {
            private static readonly s_completeFromAsyncResult: AsyncCallback;

            private m_thisRef: TInstance;
            private m_endMethod: Func<TInstance, IAsyncResult, TResult>;

            protected constructor(thisRef: TInstance, endMethod: Func<TInstance, IAsyncResult, TResult>) {
                throw new Error("not yet implemented");
            }
            private static staticctor_initialize = (() => {
                throw new Error("not yet implemented");
            })();
            private constructor() { }

            private static CompleteFromAsyncResult(asyncResult: IAsyncResult) {
                throw new Error("not yet implemented");
            }
            private Complete(thisRef: TInstance, endMethod: Func<TInstance, IAsyncResult, TResult>, asyncResult: IAsyncResult, requiresSynchronization: boolean) {
                throw new Error("not yet implemented");
            }
        }

        export class ____c {
            public static readonly ____9: ____c;
            public static ____9__57_0: Func<Task<Task[]>, any, TResult>;
            public static ____9__57_1: Func<Task<Task[]>, any, TResult>;
            public static ____9__66_0: Func<Task<Task>, any, TResult>;
            public static ____9__66_1: Func<Task<Task>, any, TResult>;

            private static staticctor_initialize = (() => {
                throw new Error("not yet implemented");
            })();
            private constructor() { }
            public constructor() {
                throw new Error("not yet implemented");
            }

            private __ContinueWhenAllImpl__b__57_0(completedTasks: Task<Task[]>, state: any): TResult {
                throw new Error("not yet implemented");
            }
            private __ContinueWhenAllImpl__b__57_1(completedTasks: Task<Task[]>, state: any): TResult {
                throw new Error("not yet implemented");
            }
            private __ContinueWhenAnyImpl__b__66_0(completedTask: Task<Task>, state: any): TResult {
                throw new Error("not yet implemented");
            }
            private __ContinueWhenAnyImpl__b__66_1(completedTask: Task<Task>, state: any): TResult {
                throw new Error("not yet implemented");
            }
        }

        export class <>c__56<TResult, TAntecedentResult> {
            public static readonly ____9: <>c__56<TResult, TAntecedentResult>;
            public static ____9__56_0: Func<Task<Task<TAntecedentResult>[]>, any, TResult>;
            public static ____9__56_1: Func<Task<Task<TAntecedentResult>[]>, any, TResult>;

            private static staticctor_initialize = (() => {
                throw new Error("not yet implemented");
            })();
            private constructor() { }
            public constructor() {
                throw new Error("not yet implemented");
            }

            private __ContinueWhenAllImpl__b__56_0(starter: Task<Task<TAntecedentResult>[]>, continuationFunction: any): TResult {
                throw new Error("not yet implemented");
            }
            private __ContinueWhenAllImpl__b__56_1(starter: Task<Task<TAntecedentResult>[]>, continuationAction: any): TResult {
                throw new Error("not yet implemented");
            }
        }

        export class <>c__67<TResult, TAntecedentResult> {
            public static readonly ____9: <>c__67<TResult, TAntecedentResult>;
            public static ____9__67_0: Func<Task<Task<TAntecedentResult>>, any, TResult>;
            public static ____9__67_1: Func<Task<Task<TAntecedentResult>>, any, TResult>;

            private static staticctor_initialize = (() => {
                throw new Error("not yet implemented");
            })();
            private constructor() { }
            public constructor() {
                throw new Error("not yet implemented");
            }

            private __ContinueWhenAnyImpl__b__67_0(starter: Task<Task<TAntecedentResult>>, continuationFunction: any): TResult {
                throw new Error("not yet implemented");
            }
            private __ContinueWhenAnyImpl__b__67_1(starter: Task<Task<TAntecedentResult>>, continuationAction: any): TResult {
                throw new Error("not yet implemented");
            }
        }

        export class ____c__DisplayClass32_0 {
            public asyncResult: IAsyncResult;
            public endFunction: Func<IAsyncResult, TResult>;
            public endAction: Action<IAsyncResult>;
            public promise: Task<TResult>;
            public t: Task;
            public scheduler: TaskScheduler;

            public constructor() {
                throw new Error("not yet implemented");
            }

            private __FromAsyncImpl__b__0(__p0__: any) {
                throw new Error("not yet implemented");
            }
            private __FromAsyncImpl__b__1(__p0__: any, __p1__: boolean) {
                throw new Error("not yet implemented");
            }
        }

        export class ____c__DisplayClass35_0 {
            public endFunction: Func<IAsyncResult, TResult>;
            public endAction: Action<IAsyncResult>;
            public promise: Task<TResult>;

            public constructor() {
                throw new Error("not yet implemented");
            }

            private __FromAsyncImpl__b__0(iar: IAsyncResult) {
                throw new Error("not yet implemented");
            }
        }

        export class <>c__DisplayClass38_0<TResult, TArg1> {
            public endFunction: Func<IAsyncResult, TResult>;
            public endAction: Action<IAsyncResult>;
            public promise: Task<TResult>;

            public constructor() {
                throw new Error("not yet implemented");
            }

            private __FromAsyncImpl__b__0(iar: IAsyncResult) {
                throw new Error("not yet implemented");
            }
        }

        export class <>c__DisplayClass41_0<TResult, TArg1, TArg2> {
            public endFunction: Func<IAsyncResult, TResult>;
            public endAction: Action<IAsyncResult>;
            public promise: Task<TResult>;

            public constructor() {
                throw new Error("not yet implemented");
            }

            private __FromAsyncImpl__b__0(iar: IAsyncResult) {
                throw new Error("not yet implemented");
            }
        }

        export class <>c__DisplayClass44_0<TResult, TArg1, TArg2, TArg3> {
            public endFunction: Func<IAsyncResult, TResult>;
            public endAction: Action<IAsyncResult>;
            public promise: Task<TResult>;

            public constructor() {
                throw new Error("not yet implemented");
            }

            private __FromAsyncImpl__b__0(iar: IAsyncResult) {
                throw new Error("not yet implemented");
            }
        }
    }
    export enum InternalTaskOptions {
        None = 0x0,
        ContinuationTask = 0x200,
        PromiseTask = 0x400,
        HiddenState = 0x800,
        LazyCancellation = 0x1000,
        QueuedByRuntime = 0x2000,
        DoNotDispose = 0x4000,
        InternalOptionsMask = 0xff00,
    }
    export enum ConfigureAwaitOptions {
        None = 0x0,
        ContinueOnCapturedContext = 0x1,
        SuppressThrowing = 0x2,
        ForceYielding = 0x4,
    }
    export class Task<TResult> extends Task implements IAsyncResult, IDisposable {
        private static readonly s_defaultResultTask: Task<TResult>;
        private static s_Factory: TaskFactory<TResult>;

        public static get Factory(): TaskFactory<TResult> {
            throw new Error("not yet implemented");
        }

        private m_result: TResult;

        private get DebuggerDisplayResultDescription(): string {
            throw new Error("not yet implemented");
        }
        private get DebuggerDisplayMethodDescription(): string {
            throw new Error("not yet implemented");
        }
        public get Result(): TResult {
            throw new Error("not yet implemented");
        }
        private get ResultOnSuccess(): TResult {
            throw new Error("not yet implemented");
        }

        protected constructor() {
            throw new Error("not yet implemented");
        }
        protected constructor(state: any, options: TaskCreationOptions) {
            throw new Error("not yet implemented");
        }
        protected constructor(result: TResult) {
            throw new Error("not yet implemented");
        }
        protected constructor(canceled: boolean, result: TResult, creationOptions: TaskCreationOptions, ct: CancellationToken) {
            throw new Error("not yet implemented");
        }
        public constructor(function: Func<TResult>) {
            throw new Error("not yet implemented");
        }
        public constructor(function: Func<TResult>, cancellationToken: CancellationToken) {
            throw new Error("not yet implemented");
        }
        public constructor(function: Func<TResult>, creationOptions: TaskCreationOptions) {
            throw new Error("not yet implemented");
        }
        public constructor(function: Func<TResult>, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions) {
            throw new Error("not yet implemented");
        }
        public constructor(function: Func<any, TResult>, state: any) {
            throw new Error("not yet implemented");
        }
        public constructor(function: Func<any, TResult>, state: any, cancellationToken: CancellationToken) {
            throw new Error("not yet implemented");
        }
        public constructor(function: Func<any, TResult>, state: any, creationOptions: TaskCreationOptions) {
            throw new Error("not yet implemented");
        }
        public constructor(function: Func<any, TResult>, state: any, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions) {
            throw new Error("not yet implemented");
        }
        protected constructor(valueSelector: Func<TResult>, parent: Task, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions, internalOptions: InternalTaskOptions, scheduler: TaskScheduler) {
            throw new Error("not yet implemented");
        }
        protected constructor(valueSelector: Delegate, state: any, parent: Task, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions, internalOptions: InternalTaskOptions, scheduler: TaskScheduler) {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

        private static StartNew(parent: Task, function: Func<TResult>, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions, internalOptions: InternalTaskOptions, scheduler: TaskScheduler): Task<TResult> {
            throw new Error("not yet implemented");
        }
        private static StartNew(parent: Task, function: Func<any, TResult>, state: any, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions, internalOptions: InternalTaskOptions, scheduler: TaskScheduler): Task<TResult> {
            throw new Error("not yet implemented");
        }
        private TrySetResult(result: TResult): boolean {
            throw new Error("not yet implemented");
        }
        private DangerousSetResult(result: TResult) {
            throw new Error("not yet implemented");
        }
        private GetResultCore(waitCompletionNotification: boolean): TResult {
            throw new Error("not yet implemented");
        }
        private InnerInvoke() {
            throw new Error("not yet implemented");
        }
        public GetAwaiter(): TaskAwaiter<TResult> {
            throw new Error("not yet implemented");
        }
        public ConfigureAwait(continueOnCapturedContext: boolean): ConfiguredTaskAwaitable<TResult> {
            throw new Error("not yet implemented");
        }
        public ConfigureAwait(options: ConfigureAwaitOptions): ConfiguredTaskAwaitable<TResult> {
            throw new Error("not yet implemented");
        }
        public WaitAsync(cancellationToken: CancellationToken): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public WaitAsync(timeout: TimeSpan): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public WaitAsync(timeout: TimeSpan, timeProvider: TimeProvider): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public WaitAsync(timeout: TimeSpan, cancellationToken: CancellationToken): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public WaitAsync(timeout: TimeSpan, timeProvider: TimeProvider, cancellationToken: CancellationToken): Task<TResult> {
            throw new Error("not yet implemented");
        }
        private WaitAsync(millisecondsTimeout: number, timeProvider: TimeProvider, cancellationToken: CancellationToken): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWith(continuationAction: Action<Task<TResult>>): Task {
            throw new Error("not yet implemented");
        }
        public ContinueWith(continuationAction: Action<Task<TResult>>, cancellationToken: CancellationToken): Task {
            throw new Error("not yet implemented");
        }
        public ContinueWith(continuationAction: Action<Task<TResult>>, scheduler: TaskScheduler): Task {
            throw new Error("not yet implemented");
        }
        public ContinueWith(continuationAction: Action<Task<TResult>>, continuationOptions: TaskContinuationOptions): Task {
            throw new Error("not yet implemented");
        }
        public ContinueWith(continuationAction: Action<Task<TResult>>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task {
            throw new Error("not yet implemented");
        }
        private ContinueWith(continuationAction: Action<Task<TResult>>, scheduler: TaskScheduler, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions): Task {
            throw new Error("not yet implemented");
        }
        public ContinueWith(continuationAction: Action<Task<TResult>, any>, state: any): Task {
            throw new Error("not yet implemented");
        }
        public ContinueWith(continuationAction: Action<Task<TResult>, any>, state: any, cancellationToken: CancellationToken): Task {
            throw new Error("not yet implemented");
        }
        public ContinueWith(continuationAction: Action<Task<TResult>, any>, state: any, scheduler: TaskScheduler): Task {
            throw new Error("not yet implemented");
        }
        public ContinueWith(continuationAction: Action<Task<TResult>, any>, state: any, continuationOptions: TaskContinuationOptions): Task {
            throw new Error("not yet implemented");
        }
        public ContinueWith(continuationAction: Action<Task<TResult>, any>, state: any, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task {
            throw new Error("not yet implemented");
        }
        private ContinueWith(continuationAction: Action<Task<TResult>, any>, state: any, scheduler: TaskScheduler, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions): Task {
            throw new Error("not yet implemented");
        }
        public ContinueWith(continuationFunction: Func<Task<TResult>, TNewResult>): Task<TNewResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWith(continuationFunction: Func<Task<TResult>, TNewResult>, cancellationToken: CancellationToken): Task<TNewResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWith(continuationFunction: Func<Task<TResult>, TNewResult>, scheduler: TaskScheduler): Task<TNewResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWith(continuationFunction: Func<Task<TResult>, TNewResult>, continuationOptions: TaskContinuationOptions): Task<TNewResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWith(continuationFunction: Func<Task<TResult>, TNewResult>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task<TNewResult> {
            throw new Error("not yet implemented");
        }
        private ContinueWith(continuationFunction: Func<Task<TResult>, TNewResult>, scheduler: TaskScheduler, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions): Task<TNewResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWith(continuationFunction: Func<Task<TResult>, any, TNewResult>, state: any): Task<TNewResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWith(continuationFunction: Func<Task<TResult>, any, TNewResult>, state: any, cancellationToken: CancellationToken): Task<TNewResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWith(continuationFunction: Func<Task<TResult>, any, TNewResult>, state: any, scheduler: TaskScheduler): Task<TNewResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWith(continuationFunction: Func<Task<TResult>, any, TNewResult>, state: any, continuationOptions: TaskContinuationOptions): Task<TNewResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWith(continuationFunction: Func<Task<TResult>, any, TNewResult>, state: any, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task<TNewResult> {
            throw new Error("not yet implemented");
        }
        private ContinueWith(continuationFunction: Func<Task<TResult>, any, TNewResult>, state: any, scheduler: TaskScheduler, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions): Task<TNewResult> {
            throw new Error("not yet implemented");
        }
        private static __ConfigureAwait__g__ThrowForInvalidOptions_36_0(options: ConfigureAwaitOptions) {
            throw new Error("not yet implemented");
        }
    }
    export class ValueTask<TResult> extends ValueType implements IEquatable<ValueTask<TResult>> {
        private static s_canceledTask: Task<TResult>;

        private _obj: any;
        private _result: TResult;
        private _token: number;
        private _continueOnCapturedContext: boolean;

        public get IsCompleted(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsCompletedSuccessfully(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsFaulted(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsCanceled(): boolean {
            throw new Error("not yet implemented");
        }
        public get Result(): TResult {
            throw new Error("not yet implemented");
        }

        public constructor(result: TResult) {
            throw new Error("not yet implemented");
        }
        public constructor(task: Task<TResult>) {
            throw new Error("not yet implemented");
        }
        public constructor(source: IValueTaskSource<TResult>, token: number) {
            throw new Error("not yet implemented");
        }
        private constructor(obj: any, result: TResult, token: number, continueOnCapturedContext: boolean) {
            throw new Error("not yet implemented");
        }

        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public Equals(other: ValueTask<TResult>): boolean {
            throw new Error("not yet implemented");
        }
        public AsTask(): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public Preserve(): ValueTask<TResult> {
            throw new Error("not yet implemented");
        }
        private GetTaskForValueTaskSource(t: IValueTaskSource<TResult>): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public GetAwaiter(): ValueTaskAwaiter<TResult> {
            throw new Error("not yet implemented");
        }
        public ConfigureAwait(continueOnCapturedContext: boolean): ConfiguredValueTaskAwaitable<TResult> {
            throw new Error("not yet implemented");
        }
        public ToString(): string {
            throw new Error("not yet implemented");
        }
    }
    export namespace ValueTask {
        export class ValueTaskSourceAsTask extends Task<TResult> implements IAsyncResult, IDisposable {
            private static readonly s_completionAction: Action<any>;

            private _source: IValueTaskSource<TResult>;
            private _token: number;

            public constructor(source: IValueTaskSource<TResult>, token: number) {
                throw new Error("not yet implemented");
            }
            private static staticctor_initialize = (() => {
                throw new Error("not yet implemented");
            })();
            private constructor() { }

            private static ___cctor__g__ThrowUnexpectedStateForKnownCallback_4_1(state: any) {
                throw new Error("not yet implemented");
            }
        }
        export namespace ValueTaskSourceAsTask {
            export class ____c {
                public static readonly ____9: ____c;

                private static staticctor_initialize = (() => {
                    throw new Error("not yet implemented");
                })();
                private constructor() { }
                public constructor() {
                    throw new Error("not yet implemented");
                }

                private ___cctor__b__4_0(state: any) {
                    throw new Error("not yet implemented");
                }
            }
        }
    }
    export interface ITaskCompletionAction {
        get InvokeMayRunArbitraryCode(): boolean;

        Invoke(completingTask: Task): void;
    }
    export class TaskExceptionHolder {
        private m_task: Task;
        private m_faultExceptions: List<ExceptionDispatchInfo>;
        private m_cancellationException: ExceptionDispatchInfo;
        private m_isHandled: boolean;

        private get ContainsFaultList(): boolean {
            throw new Error("not yet implemented");
        }

        protected constructor(task: Task) {
            throw new Error("not yet implemented");
        }

        private Finalize() {
            throw new Error("not yet implemented");
        }
        private Add(exceptionObject: any, representsCancellation: boolean) {
            throw new Error("not yet implemented");
        }
        private SetCancellationException(exceptionObject: any) {
            throw new Error("not yet implemented");
        }
        private AddFaultException(exceptionObject: any) {
            throw new Error("not yet implemented");
        }
        private MarkAsUnhandled() {
            throw new Error("not yet implemented");
        }
        private MarkAsHandled(calledFromFinalizer: boolean) {
            throw new Error("not yet implemented");
        }
        private CreateExceptionObject(calledFromFinalizer: boolean, includeThisException: Exception): AggregateException {
            throw new Error("not yet implemented");
        }
        private GetExceptionDispatchInfos(): List<ExceptionDispatchInfo> {
            throw new Error("not yet implemented");
        }
        private GetCancellationExceptionDispatchInfo(): ExceptionDispatchInfo {
            throw new Error("not yet implemented");
        }
    }
    export class ContingentProperties {
        private m_capturedContext: ExecutionContext;
        private m_completionEvent: ManualResetEventSlim;
        private m_exceptionsHolder: TaskExceptionHolder;
        private m_cancellationToken: CancellationToken;
        private m_cancellationRegistration: StrongBox<CancellationTokenRegistration>;
        private m_internalCancellationRequested: number;
        private m_completionCountdown: number;
        private m_exceptionalChildren: List<Task>;
        private m_parent: Task;

        public constructor() {
            throw new Error("not yet implemented");
        }

        private SetCompleted() {
            throw new Error("not yet implemented");
        }
        private static SetEvent(mres: ManualResetEventSlim) {
            throw new Error("not yet implemented");
        }
        private UnregisterCancellationCallback() {
            throw new Error("not yet implemented");
        }
    }
    export class TaskFactory {
        private m_defaultCancellationToken: CancellationToken;
        private m_defaultScheduler: TaskScheduler;
        private m_defaultCreationOptions: TaskCreationOptions;
        private m_defaultContinuationOptions: TaskContinuationOptions;

        private get DefaultScheduler(): TaskScheduler {
            throw new Error("not yet implemented");
        }
        public get CancellationToken(): CancellationToken {
            throw new Error("not yet implemented");
        }
        public get Scheduler(): TaskScheduler {
            throw new Error("not yet implemented");
        }
        public get CreationOptions(): TaskCreationOptions {
            throw new Error("not yet implemented");
        }
        public get ContinuationOptions(): TaskContinuationOptions {
            throw new Error("not yet implemented");
        }

        public constructor() {
            throw new Error("not yet implemented");
        }
        public constructor(cancellationToken: CancellationToken) {
            throw new Error("not yet implemented");
        }
        public constructor(scheduler: TaskScheduler) {
            throw new Error("not yet implemented");
        }
        public constructor(creationOptions: TaskCreationOptions, continuationOptions: TaskContinuationOptions) {
            throw new Error("not yet implemented");
        }
        public constructor(cancellationToken: CancellationToken, creationOptions: TaskCreationOptions, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler) {
            throw new Error("not yet implemented");
        }

        private GetDefaultScheduler(currTask: Task): TaskScheduler {
            throw new Error("not yet implemented");
        }
        private static CheckCreationOptions(creationOptions: TaskCreationOptions) {
            throw new Error("not yet implemented");
        }
        public StartNew(action: Action): Task {
            throw new Error("not yet implemented");
        }
        public StartNew(action: Action, cancellationToken: CancellationToken): Task {
            throw new Error("not yet implemented");
        }
        public StartNew(action: Action, creationOptions: TaskCreationOptions): Task {
            throw new Error("not yet implemented");
        }
        public StartNew(action: Action, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions, scheduler: TaskScheduler): Task {
            throw new Error("not yet implemented");
        }
        public StartNew(action: Action<any>, state: any): Task {
            throw new Error("not yet implemented");
        }
        public StartNew(action: Action<any>, state: any, cancellationToken: CancellationToken): Task {
            throw new Error("not yet implemented");
        }
        public StartNew(action: Action<any>, state: any, creationOptions: TaskCreationOptions): Task {
            throw new Error("not yet implemented");
        }
        public StartNew(action: Action<any>, state: any, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions, scheduler: TaskScheduler): Task {
            throw new Error("not yet implemented");
        }
        public StartNew(function: Func<TResult>): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public StartNew(function: Func<TResult>, cancellationToken: CancellationToken): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public StartNew(function: Func<TResult>, creationOptions: TaskCreationOptions): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public StartNew(function: Func<TResult>, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions, scheduler: TaskScheduler): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public StartNew(function: Func<any, TResult>, state: any): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public StartNew(function: Func<any, TResult>, state: any, cancellationToken: CancellationToken): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public StartNew(function: Func<any, TResult>, state: any, creationOptions: TaskCreationOptions): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public StartNew(function: Func<any, TResult>, state: any, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions, scheduler: TaskScheduler): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public FromAsync(asyncResult: IAsyncResult, endMethod: Action<IAsyncResult>): Task {
            throw new Error("not yet implemented");
        }
        public FromAsync(asyncResult: IAsyncResult, endMethod: Action<IAsyncResult>, creationOptions: TaskCreationOptions): Task {
            throw new Error("not yet implemented");
        }
        public FromAsync(asyncResult: IAsyncResult, endMethod: Action<IAsyncResult>, creationOptions: TaskCreationOptions, scheduler: TaskScheduler): Task {
            throw new Error("not yet implemented");
        }
        public FromAsync(beginMethod: Func<AsyncCallback, any, IAsyncResult>, endMethod: Action<IAsyncResult>, state: any): Task {
            throw new Error("not yet implemented");
        }
        public FromAsync(beginMethod: Func<AsyncCallback, any, IAsyncResult>, endMethod: Action<IAsyncResult>, state: any, creationOptions: TaskCreationOptions): Task {
            throw new Error("not yet implemented");
        }
        public FromAsync(beginMethod: Func<TArg1, AsyncCallback, any, IAsyncResult>, endMethod: Action<IAsyncResult>, arg1: TArg1, state: any): Task {
            throw new Error("not yet implemented");
        }
        public FromAsync(beginMethod: Func<TArg1, AsyncCallback, any, IAsyncResult>, endMethod: Action<IAsyncResult>, arg1: TArg1, state: any, creationOptions: TaskCreationOptions): Task {
            throw new Error("not yet implemented");
        }
        public FromAsync(beginMethod: Func<TArg1, TArg2, AsyncCallback, any, IAsyncResult>, endMethod: Action<IAsyncResult>, arg1: TArg1, arg2: TArg2, state: any): Task {
            throw new Error("not yet implemented");
        }
        public FromAsync(beginMethod: Func<TArg1, TArg2, AsyncCallback, any, IAsyncResult>, endMethod: Action<IAsyncResult>, arg1: TArg1, arg2: TArg2, state: any, creationOptions: TaskCreationOptions): Task {
            throw new Error("not yet implemented");
        }
        public FromAsync(beginMethod: Func<TArg1, TArg2, TArg3, AsyncCallback, any, IAsyncResult>, endMethod: Action<IAsyncResult>, arg1: TArg1, arg2: TArg2, arg3: TArg3, state: any): Task {
            throw new Error("not yet implemented");
        }
        public FromAsync(beginMethod: Func<TArg1, TArg2, TArg3, AsyncCallback, any, IAsyncResult>, endMethod: Action<IAsyncResult>, arg1: TArg1, arg2: TArg2, arg3: TArg3, state: any, creationOptions: TaskCreationOptions): Task {
            throw new Error("not yet implemented");
        }
        public FromAsync(asyncResult: IAsyncResult, endMethod: Func<IAsyncResult, TResult>): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public FromAsync(asyncResult: IAsyncResult, endMethod: Func<IAsyncResult, TResult>, creationOptions: TaskCreationOptions): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public FromAsync(asyncResult: IAsyncResult, endMethod: Func<IAsyncResult, TResult>, creationOptions: TaskCreationOptions, scheduler: TaskScheduler): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public FromAsync(beginMethod: Func<AsyncCallback, any, IAsyncResult>, endMethod: Func<IAsyncResult, TResult>, state: any): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public FromAsync(beginMethod: Func<AsyncCallback, any, IAsyncResult>, endMethod: Func<IAsyncResult, TResult>, state: any, creationOptions: TaskCreationOptions): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public FromAsync(beginMethod: Func<TArg1, AsyncCallback, any, IAsyncResult>, endMethod: Func<IAsyncResult, TResult>, arg1: TArg1, state: any): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public FromAsync(beginMethod: Func<TArg1, AsyncCallback, any, IAsyncResult>, endMethod: Func<IAsyncResult, TResult>, arg1: TArg1, state: any, creationOptions: TaskCreationOptions): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public FromAsync(beginMethod: Func<TArg1, TArg2, AsyncCallback, any, IAsyncResult>, endMethod: Func<IAsyncResult, TResult>, arg1: TArg1, arg2: TArg2, state: any): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public FromAsync(beginMethod: Func<TArg1, TArg2, AsyncCallback, any, IAsyncResult>, endMethod: Func<IAsyncResult, TResult>, arg1: TArg1, arg2: TArg2, state: any, creationOptions: TaskCreationOptions): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public FromAsync(beginMethod: Func<TArg1, TArg2, TArg3, AsyncCallback, any, IAsyncResult>, endMethod: Func<IAsyncResult, TResult>, arg1: TArg1, arg2: TArg2, arg3: TArg3, state: any): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public FromAsync(beginMethod: Func<TArg1, TArg2, TArg3, AsyncCallback, any, IAsyncResult>, endMethod: Func<IAsyncResult, TResult>, arg1: TArg1, arg2: TArg2, arg3: TArg3, state: any, creationOptions: TaskCreationOptions): Task<TResult> {
            throw new Error("not yet implemented");
        }
        private static CheckFromAsyncOptions(creationOptions: TaskCreationOptions, hasBeginMethod: boolean) {
            throw new Error("not yet implemented");
        }
        private static CommonCWAllLogic(tasksCopy: Task[]): Task<Task[]> {
            throw new Error("not yet implemented");
        }
        private static CommonCWAllLogic(tasksCopy: Task<T>[]): Task<Task<T>[]> {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAll(tasks: Task[], continuationAction: Action<Task[]>): Task {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAll(tasks: Task[], continuationAction: Action<Task[]>, cancellationToken: CancellationToken): Task {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAll(tasks: Task[], continuationAction: Action<Task[]>, continuationOptions: TaskContinuationOptions): Task {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAll(tasks: Task[], continuationAction: Action<Task[]>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAll(tasks: Task<TAntecedentResult>[], continuationAction: Action<Task<TAntecedentResult>[]>): Task {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAll(tasks: Task<TAntecedentResult>[], continuationAction: Action<Task<TAntecedentResult>[]>, cancellationToken: CancellationToken): Task {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAll(tasks: Task<TAntecedentResult>[], continuationAction: Action<Task<TAntecedentResult>[]>, continuationOptions: TaskContinuationOptions): Task {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAll(tasks: Task<TAntecedentResult>[], continuationAction: Action<Task<TAntecedentResult>[]>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAll(tasks: Task[], continuationFunction: Func<Task[], TResult>): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAll(tasks: Task[], continuationFunction: Func<Task[], TResult>, cancellationToken: CancellationToken): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAll(tasks: Task[], continuationFunction: Func<Task[], TResult>, continuationOptions: TaskContinuationOptions): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAll(tasks: Task[], continuationFunction: Func<Task[], TResult>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAll(tasks: Task<TAntecedentResult>[], continuationFunction: Func<Task<TAntecedentResult>[], TResult>): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAll(tasks: Task<TAntecedentResult>[], continuationFunction: Func<Task<TAntecedentResult>[], TResult>, cancellationToken: CancellationToken): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAll(tasks: Task<TAntecedentResult>[], continuationFunction: Func<Task<TAntecedentResult>[], TResult>, continuationOptions: TaskContinuationOptions): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAll(tasks: Task<TAntecedentResult>[], continuationFunction: Func<Task<TAntecedentResult>[], TResult>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task<TResult> {
            throw new Error("not yet implemented");
        }
        private static CommonCWAnyLogic(tasks: IList<TTask>, isSyncBlocking: boolean): Task<TTask> {
            throw new Error("not yet implemented");
        }
        private static CommonCWAnyLogicCleanup(continuation: Task<Task>) {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAny(tasks: Task[], continuationAction: Action<Task>): Task {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAny(tasks: Task[], continuationAction: Action<Task>, cancellationToken: CancellationToken): Task {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAny(tasks: Task[], continuationAction: Action<Task>, continuationOptions: TaskContinuationOptions): Task {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAny(tasks: Task[], continuationAction: Action<Task>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAny(tasks: Task[], continuationFunction: Func<Task, TResult>): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAny(tasks: Task[], continuationFunction: Func<Task, TResult>, cancellationToken: CancellationToken): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAny(tasks: Task[], continuationFunction: Func<Task, TResult>, continuationOptions: TaskContinuationOptions): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAny(tasks: Task[], continuationFunction: Func<Task, TResult>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAny(tasks: Task<TAntecedentResult>[], continuationFunction: Func<Task<TAntecedentResult>, TResult>): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAny(tasks: Task<TAntecedentResult>[], continuationFunction: Func<Task<TAntecedentResult>, TResult>, cancellationToken: CancellationToken): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAny(tasks: Task<TAntecedentResult>[], continuationFunction: Func<Task<TAntecedentResult>, TResult>, continuationOptions: TaskContinuationOptions): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAny(tasks: Task<TAntecedentResult>[], continuationFunction: Func<Task<TAntecedentResult>, TResult>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAny(tasks: Task<TAntecedentResult>[], continuationAction: Action<Task<TAntecedentResult>>): Task {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAny(tasks: Task<TAntecedentResult>[], continuationAction: Action<Task<TAntecedentResult>>, cancellationToken: CancellationToken): Task {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAny(tasks: Task<TAntecedentResult>[], continuationAction: Action<Task<TAntecedentResult>>, continuationOptions: TaskContinuationOptions): Task {
            throw new Error("not yet implemented");
        }
        public ContinueWhenAny(tasks: Task<TAntecedentResult>[], continuationAction: Action<Task<TAntecedentResult>>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task {
            throw new Error("not yet implemented");
        }
        private static CheckMultiContinuationTasksAndCopy(tasks: Task[]): Task[] {
            throw new Error("not yet implemented");
        }
        private static CheckMultiContinuationTasksAndCopy(tasks: Task<TResult>[]): Task<TResult>[] {
            throw new Error("not yet implemented");
        }
        private static CheckMultiTaskContinuationOptions(continuationOptions: TaskContinuationOptions) {
            throw new Error("not yet implemented");
        }
    }
    export namespace TaskFactory {
        export class CompleteOnCountdownPromise extends Task<Task[]> implements IAsyncResult, IDisposable, ITaskCompletionAction {
            private _tasks: Task[];
            private _count: number;

            public get InvokeMayRunArbitraryCode(): boolean {
                throw new Error("not yet implemented");
            }
            private get ShouldNotifyDebuggerOfWaitCompletion(): boolean {
                throw new Error("not yet implemented");
            }

            protected constructor(tasksCopy: Task[]) {
                throw new Error("not yet implemented");
            }

            public Invoke(completingTask: Task) {
                throw new Error("not yet implemented");
            }
        }

        export class CompleteOnCountdownPromise<T> extends Task<Task<T>[]> implements IAsyncResult, IDisposable, ITaskCompletionAction {
            private _tasks: Task<T>[];
            private _count: number;

            public get InvokeMayRunArbitraryCode(): boolean {
                throw new Error("not yet implemented");
            }
            private get ShouldNotifyDebuggerOfWaitCompletion(): boolean {
                throw new Error("not yet implemented");
            }

            protected constructor(tasksCopy: Task<T>[]) {
                throw new Error("not yet implemented");
            }

            public Invoke(completingTask: Task) {
                throw new Error("not yet implemented");
            }
        }

        export class CompleteOnInvokePromise<TTask> extends Task<TTask> implements IAsyncResult, IDisposable, ITaskCompletionAction {
            private _tasks: IList<TTask>;
            private _stateFlags: number;

            public get InvokeMayRunArbitraryCode(): boolean {
                throw new Error("not yet implemented");
            }

            public constructor(tasks: IList<TTask>, isSyncBlocking: boolean) {
                throw new Error("not yet implemented");
            }

            public Invoke(completingTask: Task) {
                throw new Error("not yet implemented");
            }
        }
    }
    export enum TaskStateFlags {
        OptionsMask = 0xffff,
        Started = 0x10000,
        DelegateInvoked = 0x20000,
        Disposed = 0x40000,
        ExceptionObservedByParent = 0x80000,
        CancellationAcknowledged = 0x100000,
        Faulted = 0x200000,
        Canceled = 0x400000,
        WaitingOnChildren = 0x800000,
        RanToCompletion = 0x1000000,
        CompletedMask = 0x1600000,
        WaitingForActivation = 0x2000000,
        CompletionReserved = 0x4000000,
        WaitCompletionNotification = 0x10000000,
        ExecutionContextIsNull = 0x20000000,
        TaskScheduledWasFired = 0x40000000,
    }
    export abstract class TaskContinuation {
        protected constructor() {
            throw new Error("not yet implemented");
        }

        private Run(completedTask: Task, canInlineContinuationTask: boolean): void;
        private static InlineIfPossibleOrElseQueue(task: Task, needsProtection: boolean) {
            throw new Error("not yet implemented");
        }
        private GetDelegateContinuationsForDebugger(): Delegate[];
    }
    export class Task implements IAsyncResult, IDisposable {
        private static s_taskIdCounter: number;
        private static readonly s_taskCompletionSentinel: any;
        private static s_asyncDebuggingEnabled: boolean;
        private static s_currentActiveTasks: Dictionary<number, Task>;
        private static readonly __Factory__k__BackingField: TaskFactory;
        private static readonly s_cachedCompleted: Task<VoidTaskResult>;
        private static readonly s_ecCallback: ContextCallback;
        private static t_currentTask: Task;

        public static get CurrentId(): Nullable<number> {
            throw new Error("not yet implemented");
        }
        private static get InternalCurrent(): Task {
            throw new Error("not yet implemented");
        }
        public static get Factory(): TaskFactory {
            throw new Error("not yet implemented");
        }
        public static get CompletedTask(): Task {
            throw new Error("not yet implemented");
        }

        private m_taskId: number;
        private m_action: Delegate;
        private m_stateObject: any;
        private m_taskScheduler: TaskScheduler;
        private m_stateFlags: number;
        private m_continuationObject: any;
        private m_contingentProperties: ContingentProperties;

        private get ParentForDebugger(): Task {
            throw new Error("not yet implemented");
        }
        private get StateFlagsForDebugger(): number {
            throw new Error("not yet implemented");
        }
        private get StateFlags(): TaskStateFlags {
            throw new Error("not yet implemented");
        }
        private get DebuggerDisplayMethodDescription(): string {
            throw new Error("not yet implemented");
        }
        private get Options(): TaskCreationOptions {
            throw new Error("not yet implemented");
        }
        private get IsWaitNotificationEnabledOrNotRanToCompletion(): boolean {
            throw new Error("not yet implemented");
        }
        private get ShouldNotifyDebuggerOfWaitCompletion(): boolean {
            throw new Error("not yet implemented");
        }
        private get IsWaitNotificationEnabled(): boolean {
            throw new Error("not yet implemented");
        }
        public get Id(): number {
            throw new Error("not yet implemented");
        }
        public get Exception(): AggregateException {
            throw new Error("not yet implemented");
        }
        public get Status(): TaskStatus {
            throw new Error("not yet implemented");
        }
        public get IsCanceled(): boolean {
            throw new Error("not yet implemented");
        }
        private get IsCancellationRequested(): boolean {
            throw new Error("not yet implemented");
        }
        private get CancellationToken(): CancellationToken {
            throw new Error("not yet implemented");
        }
        private get IsCancellationAcknowledged(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsCompleted(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsCompletedSuccessfully(): boolean {
            throw new Error("not yet implemented");
        }
        public get CreationOptions(): TaskCreationOptions {
            throw new Error("not yet implemented");
        }
        private get __explicit__IAsyncResult_AsyncWaitHandle(): WaitHandle {
            throw new Error("not yet implemented");
        }
        public get AsyncWaitHandle(): WaitHandle {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        public get AsyncState(): any {
            throw new Error("not yet implemented");
        }
        private get __explicit__IAsyncResult_CompletedSynchronously(): boolean {
            throw new Error("not yet implemented");
        }
        public get CompletedSynchronously(): boolean {
            throw new Error("Invalid call (use ExplicitAs property)");
        }
        private get ExecutingTaskScheduler(): TaskScheduler {
            throw new Error("not yet implemented");
        }
        private get CompletedEvent(): ManualResetEventSlim {
            throw new Error("not yet implemented");
        }
        private get ExceptionRecorded(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsFaulted(): boolean {
            throw new Error("not yet implemented");
        }
        private get CapturedContext(): ExecutionContext {
            throw new Error("not yet implemented");
        }
        private set CapturedContext(value: ExecutionContext) {
            throw new Error("not yet implemented");
        }
        private get IsExceptionObservedByParent(): boolean {
            throw new Error("not yet implemented");
        }
        private get IsDelegateInvoked(): boolean {
            throw new Error("not yet implemented");
        }

        protected constructor(canceled: boolean, creationOptions: TaskCreationOptions, ct: CancellationToken) {
            throw new Error("not yet implemented");
        }
        protected constructor() {
            throw new Error("not yet implemented");
        }
        protected constructor(state: any, creationOptions: TaskCreationOptions, promiseStyle: boolean) {
            throw new Error("not yet implemented");
        }
        public constructor(action: Action) {
            throw new Error("not yet implemented");
        }
        public constructor(action: Action, cancellationToken: CancellationToken) {
            throw new Error("not yet implemented");
        }
        public constructor(action: Action, creationOptions: TaskCreationOptions) {
            throw new Error("not yet implemented");
        }
        public constructor(action: Action, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions) {
            throw new Error("not yet implemented");
        }
        public constructor(action: Action<any>, state: any) {
            throw new Error("not yet implemented");
        }
        public constructor(action: Action<any>, state: any, cancellationToken: CancellationToken) {
            throw new Error("not yet implemented");
        }
        public constructor(action: Action<any>, state: any, creationOptions: TaskCreationOptions) {
            throw new Error("not yet implemented");
        }
        public constructor(action: Action<any>, state: any, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions) {
            throw new Error("not yet implemented");
        }
        protected constructor(action: Delegate, state: any, parent: Task, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions, internalOptions: InternalTaskOptions, scheduler: TaskScheduler) {
            throw new Error("not yet implemented");
        }
        private static staticctor_initialize = (() => {
            throw new Error("not yet implemented");
        })();
        private constructor() { }

        private static AddToActiveTasks(task: Task): boolean {
            throw new Error("not yet implemented");
        }
        private static RemoveFromActiveTasks(task: Task) {
            throw new Error("not yet implemented");
        }
        private TaskConstructorCore(action: Delegate, state: any, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions, internalOptions: InternalTaskOptions, scheduler: TaskScheduler) {
            throw new Error("not yet implemented");
        }
        private AssignCancellationToken(cancellationToken: CancellationToken, antecedent: Task, continuation: TaskContinuation) {
            throw new Error("not yet implemented");
        }
        private static OptionsMethod(flags: number): TaskCreationOptions {
            throw new Error("not yet implemented");
        }
        private AtomicStateUpdate(newBits: number, illegalBits: number): boolean {
            throw new Error("not yet implemented");
        }
        private AtomicStateUpdateSlow(newBits: number, illegalBits: number): boolean {
            throw new Error("not yet implemented");
        }
        private AtomicStateUpdate(newBits: number, illegalBits: number, ref oldFlags: number): boolean {
            throw new Error("not yet implemented");
        }
        private SetNotificationForWaitCompletion(enabled: boolean) {
            throw new Error("not yet implemented");
        }
        private NotifyDebuggerOfWaitCompletionIfNecessary(): boolean {
            throw new Error("not yet implemented");
        }
        private static AnyTaskRequiresNotifyDebuggerOfWaitCompletion(tasks: Task[]): boolean {
            throw new Error("not yet implemented");
        }
        private NotifyDebuggerOfWaitCompletion() {
            throw new Error("not yet implemented");
        }
        private MarkStarted(): boolean {
            throw new Error("not yet implemented");
        }
        private FireTaskScheduledIfNeeded(ts: TaskScheduler) {
            throw new Error("not yet implemented");
        }
        private AddNewChild() {
            throw new Error("not yet implemented");
        }
        private DisregardChild() {
            throw new Error("not yet implemented");
        }
        public Start() {
            throw new Error("not yet implemented");
        }
        public Start(scheduler: TaskScheduler) {
            throw new Error("not yet implemented");
        }
        public RunSynchronously() {
            throw new Error("not yet implemented");
        }
        public RunSynchronously(scheduler: TaskScheduler) {
            throw new Error("not yet implemented");
        }
        private InternalRunSynchronously(scheduler: TaskScheduler, waitForCompletion: boolean) {
            throw new Error("not yet implemented");
        }
        private static InternalStartNew(creatingTask: Task, action: Delegate, state: any, cancellationToken: CancellationToken, scheduler: TaskScheduler, options: TaskCreationOptions, internalOptions: InternalTaskOptions): Task {
            throw new Error("not yet implemented");
        }
        private static NewId(): number {
            throw new Error("not yet implemented");
        }
        private static InternalCurrentIfAttached(creationOptions: TaskCreationOptions): Task {
            throw new Error("not yet implemented");
        }
        private EnsureContingentPropertiesInitialized(): ContingentProperties {
            throw new Error("not yet implemented");
        }
        private EnsureContingentPropertiesInitializedUnsafe(): ContingentProperties {
            throw new Error("not yet implemented");
        }
        private static IsCompletedMethod(flags: number): boolean {
            throw new Error("not yet implemented");
        }
        private SpinUntilCompleted() {
            throw new Error("not yet implemented");
        }
        public Dispose() {
            throw new Error("not yet implemented");
        }
        private Dispose(disposing: boolean) {
            throw new Error("not yet implemented");
        }
        private ScheduleAndStart(needsProtection: boolean) {
            throw new Error("not yet implemented");
        }
        private AddException(exceptionObject: any) {
            throw new Error("not yet implemented");
        }
        private AddException(exceptionObject: any, representsCancellation: boolean) {
            throw new Error("not yet implemented");
        }
        private GetExceptions(includeTaskCanceledExceptions: boolean): AggregateException {
            throw new Error("not yet implemented");
        }
        private GetExceptionDispatchInfos(): List<ExceptionDispatchInfo> {
            throw new Error("not yet implemented");
        }
        private GetCancellationExceptionDispatchInfo(): ExceptionDispatchInfo {
            throw new Error("not yet implemented");
        }
        private MarkExceptionsAsHandled() {
            throw new Error("not yet implemented");
        }
        private ThrowIfExceptional(includeTaskCanceledExceptions: boolean) {
            throw new Error("not yet implemented");
        }
        private static ThrowAsync(exception: Exception, targetContext: SynchronizationContext) {
            throw new Error("not yet implemented");
        }
        private UpdateExceptionObservedStatus() {
            throw new Error("not yet implemented");
        }
        private Finish(userDelegateExecute: boolean) {
            throw new Error("not yet implemented");
        }
        private FinishSlow(userDelegateExecute: boolean) {
            throw new Error("not yet implemented");
        }
        private FinishStageTwo() {
            throw new Error("not yet implemented");
        }
        private FinishStageThree() {
            throw new Error("not yet implemented");
        }
        private NotifyParentIfPotentiallyAttachedTask() {
            throw new Error("not yet implemented");
        }
        private ProcessChildCompletion(childTask: Task) {
            throw new Error("not yet implemented");
        }
        private AddExceptionsFromChildren(props: ContingentProperties) {
            throw new Error("not yet implemented");
        }
        private ExecuteEntry(): boolean {
            throw new Error("not yet implemented");
        }
        private ExecuteFromThreadPool(threadPoolThread: Thread) {
            throw new Error("not yet implemented");
        }
        private ExecuteEntryUnsafe(threadPoolThread: Thread) {
            throw new Error("not yet implemented");
        }
        private ExecuteEntryCancellationRequestedOrCanceled() {
            throw new Error("not yet implemented");
        }
        private ExecuteWithThreadLocal(ref currentTaskSlot: Task, threadPoolThread: Thread) {
            throw new Error("not yet implemented");
        }
        private InnerInvoke() {
            throw new Error("not yet implemented");
        }
        private HandleException(unhandledException: Exception) {
            throw new Error("not yet implemented");
        }
        public GetAwaiter(): TaskAwaiter {
            throw new Error("not yet implemented");
        }
        public ConfigureAwait(continueOnCapturedContext: boolean): ConfiguredTaskAwaitable {
            throw new Error("not yet implemented");
        }
        public ConfigureAwait(options: ConfigureAwaitOptions): ConfiguredTaskAwaitable {
            throw new Error("not yet implemented");
        }
        private SetContinuationForAwait(continuationAction: Action, continueOnCapturedContext: boolean, flowExecutionContext: boolean) {
            throw new Error("not yet implemented");
        }
        private UnsafeSetContinuationForAwait(stateMachineBox: IAsyncStateMachineBox, continueOnCapturedContext: boolean) {
            throw new Error("not yet implemented");
        }
        public static Yield(): YieldAwaitable {
            throw new Error("not yet implemented");
        }
        public Wait() {
            throw new Error("not yet implemented");
        }
        public Wait(timeout: TimeSpan): boolean {
            throw new Error("not yet implemented");
        }
        public Wait(timeout: TimeSpan, cancellationToken: CancellationToken): boolean {
            throw new Error("not yet implemented");
        }
        public Wait(cancellationToken: CancellationToken) {
            throw new Error("not yet implemented");
        }
        public Wait(millisecondsTimeout: number): boolean {
            throw new Error("not yet implemented");
        }
        public Wait(millisecondsTimeout: number, cancellationToken: CancellationToken): boolean {
            throw new Error("not yet implemented");
        }
        public WaitAsync(cancellationToken: CancellationToken): Task {
            throw new Error("not yet implemented");
        }
        public WaitAsync(timeout: TimeSpan): Task {
            throw new Error("not yet implemented");
        }
        public WaitAsync(timeout: TimeSpan, timeProvider: TimeProvider): Task {
            throw new Error("not yet implemented");
        }
        public WaitAsync(timeout: TimeSpan, cancellationToken: CancellationToken): Task {
            throw new Error("not yet implemented");
        }
        public WaitAsync(timeout: TimeSpan, timeProvider: TimeProvider, cancellationToken: CancellationToken): Task {
            throw new Error("not yet implemented");
        }
        private WaitAsync(millisecondsTimeout: number, timeProvider: TimeProvider, cancellationToken: CancellationToken): Task {
            throw new Error("not yet implemented");
        }
        private WrappedTryRunInline(): boolean {
            throw new Error("not yet implemented");
        }
        private InternalWait(millisecondsTimeout: number, cancellationToken: CancellationToken): boolean {
            throw new Error("not yet implemented");
        }
        private InternalWaitCore(millisecondsTimeout: number, cancellationToken: CancellationToken): boolean {
            throw new Error("not yet implemented");
        }
        private SpinThenBlockingWait(millisecondsTimeout: number, cancellationToken: CancellationToken): boolean {
            throw new Error("not yet implemented");
        }
        private SpinWait(millisecondsTimeout: number): boolean {
            throw new Error("not yet implemented");
        }
        private InternalCancel() {
            throw new Error("not yet implemented");
        }
        private InternalCancelContinueWithInitialState() {
            throw new Error("not yet implemented");
        }
        private RecordInternalCancellationRequest() {
            throw new Error("not yet implemented");
        }
        private RecordInternalCancellationRequest(tokenToRecord: CancellationToken, cancellationException: any) {
            throw new Error("not yet implemented");
        }
        private CancellationCleanupLogic() {
            throw new Error("not yet implemented");
        }
        private SetCancellationAcknowledged() {
            throw new Error("not yet implemented");
        }
        private TrySetResult(): boolean {
            throw new Error("not yet implemented");
        }
        private TrySetException(exceptionObject: any): boolean {
            throw new Error("not yet implemented");
        }
        private TrySetCanceled(tokenToRecord: CancellationToken): boolean {
            throw new Error("not yet implemented");
        }
        private TrySetCanceled(tokenToRecord: CancellationToken, cancellationException: any): boolean {
            throw new Error("not yet implemented");
        }
        private FinishContinuations() {
            throw new Error("not yet implemented");
        }
        private RunContinuations(continuationObject: any) {
            throw new Error("not yet implemented");
        }
        private RunOrQueueCompletionAction(completionAction: ITaskCompletionAction, allowInlining: boolean) {
            throw new Error("not yet implemented");
        }
        private static LogFinishCompletionNotification() {
            throw new Error("not yet implemented");
        }
        public ContinueWith(continuationAction: Action<Task>): Task {
            throw new Error("not yet implemented");
        }
        public ContinueWith(continuationAction: Action<Task>, cancellationToken: CancellationToken): Task {
            throw new Error("not yet implemented");
        }
        public ContinueWith(continuationAction: Action<Task>, scheduler: TaskScheduler): Task {
            throw new Error("not yet implemented");
        }
        public ContinueWith(continuationAction: Action<Task>, continuationOptions: TaskContinuationOptions): Task {
            throw new Error("not yet implemented");
        }
        public ContinueWith(continuationAction: Action<Task>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task {
            throw new Error("not yet implemented");
        }
        private ContinueWith(continuationAction: Action<Task>, scheduler: TaskScheduler, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions): Task {
            throw new Error("not yet implemented");
        }
        public ContinueWith(continuationAction: Action<Task, any>, state: any): Task {
            throw new Error("not yet implemented");
        }
        public ContinueWith(continuationAction: Action<Task, any>, state: any, cancellationToken: CancellationToken): Task {
            throw new Error("not yet implemented");
        }
        public ContinueWith(continuationAction: Action<Task, any>, state: any, scheduler: TaskScheduler): Task {
            throw new Error("not yet implemented");
        }
        public ContinueWith(continuationAction: Action<Task, any>, state: any, continuationOptions: TaskContinuationOptions): Task {
            throw new Error("not yet implemented");
        }
        public ContinueWith(continuationAction: Action<Task, any>, state: any, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task {
            throw new Error("not yet implemented");
        }
        private ContinueWith(continuationAction: Action<Task, any>, state: any, scheduler: TaskScheduler, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions): Task {
            throw new Error("not yet implemented");
        }
        public ContinueWith(continuationFunction: Func<Task, TResult>): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWith(continuationFunction: Func<Task, TResult>, cancellationToken: CancellationToken): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWith(continuationFunction: Func<Task, TResult>, scheduler: TaskScheduler): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWith(continuationFunction: Func<Task, TResult>, continuationOptions: TaskContinuationOptions): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWith(continuationFunction: Func<Task, TResult>, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task<TResult> {
            throw new Error("not yet implemented");
        }
        private ContinueWith(continuationFunction: Func<Task, TResult>, scheduler: TaskScheduler, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWith(continuationFunction: Func<Task, any, TResult>, state: any): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWith(continuationFunction: Func<Task, any, TResult>, state: any, cancellationToken: CancellationToken): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWith(continuationFunction: Func<Task, any, TResult>, state: any, scheduler: TaskScheduler): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWith(continuationFunction: Func<Task, any, TResult>, state: any, continuationOptions: TaskContinuationOptions): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public ContinueWith(continuationFunction: Func<Task, any, TResult>, state: any, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions, scheduler: TaskScheduler): Task<TResult> {
            throw new Error("not yet implemented");
        }
        private ContinueWith(continuationFunction: Func<Task, any, TResult>, state: any, scheduler: TaskScheduler, cancellationToken: CancellationToken, continuationOptions: TaskContinuationOptions): Task<TResult> {
            throw new Error("not yet implemented");
        }
        private static CreationOptionsFromContinuationOptions(continuationOptions: TaskContinuationOptions, out creationOptions: TaskCreationOptions, out internalOptions: InternalTaskOptions) {
            throw new Error("not yet implemented");
        }
        private ContinueWithCore(continuationTask: Task, scheduler: TaskScheduler, cancellationToken: CancellationToken, options: TaskContinuationOptions) {
            throw new Error("not yet implemented");
        }
        private AddCompletionAction(action: ITaskCompletionAction, addBeforeOthers: boolean) {
            throw new Error("not yet implemented");
        }
        private AddTaskContinuationComplex(tc: any, addBeforeOthers: boolean): boolean {
            throw new Error("not yet implemented");
        }
        private AddTaskContinuation(tc: any, addBeforeOthers: boolean): boolean {
            throw new Error("not yet implemented");
        }
        private RemoveContinuation(continuationObject: any) {
            throw new Error("not yet implemented");
        }
        public static WaitAll(tasks: Task[]) {
            throw new Error("not yet implemented");
        }
        public static WaitAll(tasks: Task[], timeout: TimeSpan): boolean {
            throw new Error("not yet implemented");
        }
        public static WaitAll(tasks: Task[], millisecondsTimeout: number): boolean {
            throw new Error("not yet implemented");
        }
        public static WaitAll(tasks: Task[], cancellationToken: CancellationToken) {
            throw new Error("not yet implemented");
        }
        public static WaitAll(tasks: Task[], millisecondsTimeout: number, cancellationToken: CancellationToken): boolean {
            throw new Error("not yet implemented");
        }
        private static WaitAllCore(tasks: Task[], millisecondsTimeout: number, cancellationToken: CancellationToken): boolean {
            throw new Error("not yet implemented");
        }
        private static AddToList(item: T, ref list: List<T>, initSize: number) {
            throw new Error("not yet implemented");
        }
        private static WaitAllBlockingCore(tasks: List<Task>, millisecondsTimeout: number, cancellationToken: CancellationToken): boolean {
            throw new Error("not yet implemented");
        }
        private static AddExceptionsForCompletedTask(ref exceptions: List<Exception>, t: Task) {
            throw new Error("not yet implemented");
        }
        public static WaitAny(tasks: Task[]): number {
            throw new Error("not yet implemented");
        }
        public static WaitAny(tasks: Task[], timeout: TimeSpan): number {
            throw new Error("not yet implemented");
        }
        public static WaitAny(tasks: Task[], cancellationToken: CancellationToken): number {
            throw new Error("not yet implemented");
        }
        public static WaitAny(tasks: Task[], millisecondsTimeout: number): number {
            throw new Error("not yet implemented");
        }
        public static WaitAny(tasks: Task[], millisecondsTimeout: number, cancellationToken: CancellationToken): number {
            throw new Error("not yet implemented");
        }
        private static WaitAnyCore(tasks: Task[], millisecondsTimeout: number, cancellationToken: CancellationToken): number {
            throw new Error("not yet implemented");
        }
        public static FromResult(result: TResult): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public static FromException(exception: Exception): Task {
            throw new Error("not yet implemented");
        }
        public static FromException(exception: Exception): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public static FromCanceled(cancellationToken: CancellationToken): Task {
            throw new Error("not yet implemented");
        }
        public static FromCanceled(cancellationToken: CancellationToken): Task<TResult> {
            throw new Error("not yet implemented");
        }
        private static FromCanceled(exception: OperationCanceledException): Task {
            throw new Error("not yet implemented");
        }
        private static FromCanceled(exception: OperationCanceledException): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public static Run(action: Action): Task {
            throw new Error("not yet implemented");
        }
        public static Run(action: Action, cancellationToken: CancellationToken): Task {
            throw new Error("not yet implemented");
        }
        public static Run(function: Func<TResult>): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public static Run(function: Func<TResult>, cancellationToken: CancellationToken): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public static Run(function: Func<Task>): Task {
            throw new Error("not yet implemented");
        }
        public static Run(function: Func<Task>, cancellationToken: CancellationToken): Task {
            throw new Error("not yet implemented");
        }
        public static Run(function: Func<Task<TResult>>): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public static Run(function: Func<Task<TResult>>, cancellationToken: CancellationToken): Task<TResult> {
            throw new Error("not yet implemented");
        }
        public static Delay(delay: TimeSpan): Task {
            throw new Error("not yet implemented");
        }
        public static Delay(delay: TimeSpan, timeProvider: TimeProvider): Task {
            throw new Error("not yet implemented");
        }
        public static Delay(delay: TimeSpan, cancellationToken: CancellationToken): Task {
            throw new Error("not yet implemented");
        }
        public static Delay(delay: TimeSpan, timeProvider: TimeProvider, cancellationToken: CancellationToken): Task {
            throw new Error("not yet implemented");
        }
        public static Delay(millisecondsDelay: number): Task {
            throw new Error("not yet implemented");
        }
        public static Delay(millisecondsDelay: number, cancellationToken: CancellationToken): Task {
            throw new Error("not yet implemented");
        }
        private static Delay(millisecondsDelay: number, timeProvider: TimeProvider, cancellationToken: CancellationToken): Task {
            throw new Error("not yet implemented");
        }
        private static ValidateTimeout(timeout: TimeSpan, argument: ExceptionArgument): number {
            throw new Error("not yet implemented");
        }
        public static WhenAll(tasks: IEnumerable<Task>): Task {
            throw new Error("not yet implemented");
        }
        public static WhenAll(tasks: Task[]): Task {
            throw new Error("not yet implemented");
        }
        private static WhenAll(tasks: ReadOnlySpan<Task>): Task {
            throw new Error("not yet implemented");
        }
        public static WhenAll(tasks: IEnumerable<Task<TResult>>): Task<TResult[]> {
            throw new Error("not yet implemented");
        }
        public static WhenAll(tasks: Task<TResult>[]): Task<TResult[]> {
            throw new Error("not yet implemented");
        }
        private static InternalWhenAll(tasks: Task<TResult>[]): Task<TResult[]> {
            throw new Error("not yet implemented");
        }
        public static WhenAny(tasks: Task[]): Task<Task> {
            throw new Error("not yet implemented");
        }
        private static WhenAny(tasks: ReadOnlySpan<TTask>): Task<TTask> {
            throw new Error("not yet implemented");
        }
        public static WhenAny(task1: Task, task2: Task): Task<Task> {
            throw new Error("not yet implemented");
        }
        private static WhenAny(task1: TTask, task2: TTask): Task<TTask> {
            throw new Error("not yet implemented");
        }
        public static WhenAny(tasks: IEnumerable<Task>): Task<Task> {
            throw new Error("not yet implemented");
        }
        private static WhenAny(tasks: IEnumerable<TTask>): Task<TTask> {
            throw new Error("not yet implemented");
        }
        public static WhenAny(tasks: Task<TResult>[]): Task<Task<TResult>> {
            throw new Error("not yet implemented");
        }
        public static WhenAny(task1: Task<TResult>, task2: Task<TResult>): Task<Task<TResult>> {
            throw new Error("not yet implemented");
        }
        public static WhenAny(tasks: IEnumerable<Task<TResult>>): Task<Task<TResult>> {
            throw new Error("not yet implemented");
        }
        private static CreateUnwrapPromise(outerTask: Task, lookForOce: boolean): Task<TResult> {
            throw new Error("not yet implemented");
        }
        private GetDelegateContinuationsForDebugger(): Delegate[] {
            throw new Error("not yet implemented");
        }
        private static GetDelegatesFromContinuationObject(continuationObject: any): Delegate[] {
            throw new Error("not yet implemented");
        }
        private static GetActiveTaskFromId(taskId: number): Task {
            throw new Error("not yet implemented");
        }
        private __EnsureContingentPropertiesInitialized__g__InitializeContingentProperties_81_0(): ContingentProperties {
            throw new Error("not yet implemented");
        }

        public readonly ExplicitAsIAsyncResult: IAsyncResult = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'AsyncWaitHandle') {
                    return target.__explicit__IAsyncResult_AsyncWaitHandle;
                }
                if (prop === 'CompletedSynchronously') {
                    return target.__explicit__IAsyncResult_CompletedSynchronously;
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
        public readonly ExplicitAsIDisposable: IDisposable = new Proxy(this, {
            get(target, prop, receiver) {
                if (prop === 'AsyncWaitHandle') {
                    return target.__explicit__IAsyncResult_AsyncWaitHandle;
                }
                if (prop === 'CompletedSynchronously') {
                    return target.__explicit__IAsyncResult_CompletedSynchronously;
                }
        
                return Reflect.get(target, prop, receiver);
            }
        });
    }
    export namespace Task {
        export enum TaskStateFlags {
            OptionsMask = 0xffff,
            Started = 0x10000,
            DelegateInvoked = 0x20000,
            Disposed = 0x40000,
            ExceptionObservedByParent = 0x80000,
            CancellationAcknowledged = 0x100000,
            Faulted = 0x200000,
            Canceled = 0x400000,
            WaitingOnChildren = 0x800000,
            RanToCompletion = 0x1000000,
            CompletedMask = 0x1600000,
            WaitingForActivation = 0x2000000,
            CompletionReserved = 0x4000000,
            WaitCompletionNotification = 0x10000000,
            ExecutionContextIsNull = 0x20000000,
            TaskScheduledWasFired = 0x40000000,
        }

        export class ContingentProperties {
            private m_capturedContext: ExecutionContext;
            private m_completionEvent: ManualResetEventSlim;
            private m_exceptionsHolder: TaskExceptionHolder;
            private m_cancellationToken: CancellationToken;
            private m_cancellationRegistration: StrongBox<CancellationTokenRegistration>;
            private m_internalCancellationRequested: number;
            private m_completionCountdown: number;
            private m_exceptionalChildren: List<Task>;
            private m_parent: Task;

            public constructor() {
                throw new Error("not yet implemented");
            }

            private SetCompleted() {
                throw new Error("not yet implemented");
            }
            private static SetEvent(mres: ManualResetEventSlim) {
                throw new Error("not yet implemented");
            }
            private UnregisterCancellationCallback() {
                throw new Error("not yet implemented");
            }
        }

        export class CancellationPromise<TResult> extends Task<TResult> implements IAsyncResult, IDisposable, ITaskCompletionAction {
            private _task: Task;
            private _registration: CancellationTokenRegistration;
            private _timer: ITimer;

            private get __explicit__ITaskCompletionAction_InvokeMayRunArbitraryCode(): boolean {
                throw new Error("not yet implemented");
            }
            public get InvokeMayRunArbitraryCode(): boolean {
                throw new Error("Invalid call (use ExplicitAs property)");
            }

            protected constructor(source: Task, millisecondsDelay: number, timeProvider: TimeProvider, token: CancellationToken) {
                throw new Error("not yet implemented");
            }

            private __explicit__ITaskCompletionAction_Invoke(completingTask: Task) {
                throw new Error("not yet implemented");
            }
            public Invoke(completingTask: Task) {
                throw new Error("Invalid call (use ExplicitAs property)");
            }
            private Cleanup() {
                throw new Error("not yet implemented");
            }

            public readonly ExplicitAsIAsyncResult: IAsyncResult = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'InvokeMayRunArbitraryCode') {
                        return target.__explicit__ITaskCompletionAction_InvokeMayRunArbitraryCode;
                    }
            
                    if (prop === 'Invoke') {
                        return target.__explicit__ITaskCompletionAction_Invoke.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
            public readonly ExplicitAsIDisposable: IDisposable = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'InvokeMayRunArbitraryCode') {
                        return target.__explicit__ITaskCompletionAction_InvokeMayRunArbitraryCode;
                    }
            
                    if (prop === 'Invoke') {
                        return target.__explicit__ITaskCompletionAction_Invoke.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
            public readonly ExplicitAsITaskCompletionAction: ITaskCompletionAction = new Proxy(this, {
                get(target, prop, receiver) {
                    if (prop === 'InvokeMayRunArbitraryCode') {
                        return target.__explicit__ITaskCompletionAction_InvokeMayRunArbitraryCode;
                    }
            
                    if (prop === 'Invoke') {
                        return target.__explicit__ITaskCompletionAction_Invoke.bind(target);
                    }
            
                    return Reflect.get(target, prop, receiver);
                }
            });
        }
        export namespace CancellationPromise {
            export class ____c {
                public static readonly ____9: ____c;
                public static ____9__3_1: TimerCallback;
                public static ____9__3_0: Action<any, CancellationToken>;

                private static staticctor_initialize = (() => {
                    throw new Error("not yet implemented");
                })();
                private constructor() { }
                public constructor() {
                    throw new Error("not yet implemented");
                }

                private ___ctor__b__3_1(state: any) {
                    throw new Error("not yet implemented");
                }
                private ___ctor__b__3_0(state: any, cancellationToken: CancellationToken) {
                    throw new Error("not yet implemented");
                }
            }
        }

        export class SetOnInvokeMres extends ManualResetEventSlim implements IDisposable, ITaskCompletionAction {
            public get InvokeMayRunArbitraryCode(): boolean {
                throw new Error("not yet implemented");
            }

            protected constructor() {
                throw new Error("not yet implemented");
            }

            public Invoke(completingTask: Task) {
                throw new Error("not yet implemented");
            }
        }

        export class SetOnCountdownMres extends ManualResetEventSlim implements IDisposable, ITaskCompletionAction {
            private _count: number;

            public get InvokeMayRunArbitraryCode(): boolean {
                throw new Error("not yet implemented");
            }

            protected constructor(count: number) {
                throw new Error("not yet implemented");
            }

            public Invoke(completingTask: Task) {
                throw new Error("not yet implemented");
            }
        }

        export class DelayPromise extends Task implements IAsyncResult, IDisposable {
            private static readonly s_timerCallback: TimerCallback;

            private _timer: ITimer;

            protected constructor(millisecondsDelay: number, timeProvider: TimeProvider) {
                throw new Error("not yet implemented");
            }
            private static staticctor_initialize = (() => {
                throw new Error("not yet implemented");
            })();
            private constructor() { }

            private static TimerCallback(state: any) {
                throw new Error("not yet implemented");
            }
            private CompleteTimedOut() {
                throw new Error("not yet implemented");
            }
            private Cleanup() {
                throw new Error("not yet implemented");
            }
        }

        export class DelayPromiseWithCancellation extends DelayPromise implements IAsyncResult, IDisposable {
            private _registration: CancellationTokenRegistration;

            protected constructor(millisecondsDelay: number, timeProvider: TimeProvider, token: CancellationToken) {
                throw new Error("not yet implemented");
            }

            private Cleanup() {
                throw new Error("not yet implemented");
            }
        }
        export namespace DelayPromiseWithCancellation {
            export class ____c {
                public static readonly ____9: ____c;
                public static ____9__1_0: Action<any, CancellationToken>;

                private static staticctor_initialize = (() => {
                    throw new Error("not yet implemented");
                })();
                private constructor() { }
                public constructor() {
                    throw new Error("not yet implemented");
                }

                private ___ctor__b__1_0(state: any, cancellationToken: CancellationToken) {
                    throw new Error("not yet implemented");
                }
            }
        }

        export class WhenAllPromise extends Task implements IAsyncResult, IDisposable, ITaskCompletionAction {
            private _failedOrCanceled: any;
            private _remainingToComplete: number;

            public get InvokeMayRunArbitraryCode(): boolean {
                throw new Error("not yet implemented");
            }

            protected constructor(tasks: ReadOnlySpan<Task>) {
                throw new Error("not yet implemented");
            }

            public Invoke(completedTask: Task) {
                throw new Error("not yet implemented");
            }
            private static __Invoke__g__HandleTask_3_0(task: Task, ref _null_: ____c__DisplayClass3_0) {
                throw new Error("not yet implemented");
            }
        }
        export namespace WhenAllPromise {
            export class ____c__DisplayClass3_0 extends ValueType {
                public observedExceptions: List<ExceptionDispatchInfo>;
                public canceledTask: Task;

            }
        }

        export class WhenAllPromise<T> extends Task<T[]> implements IAsyncResult, IDisposable, ITaskCompletionAction {
            private m_tasks: Task<T>[];
            private m_count: number;

            public get InvokeMayRunArbitraryCode(): boolean {
                throw new Error("not yet implemented");
            }
            private get ShouldNotifyDebuggerOfWaitCompletion(): boolean {
                throw new Error("not yet implemented");
            }

            protected constructor(tasks: Task<T>[]) {
                throw new Error("not yet implemented");
            }

            public Invoke(ignored: Task) {
                throw new Error("not yet implemented");
            }
        }

        export class TwoTaskWhenAnyPromise<TTask> extends Task<TTask> implements IAsyncResult, IDisposable, ITaskCompletionAction {
            private _task1: TTask;
            private _task2: TTask;

            public get InvokeMayRunArbitraryCode(): boolean {
                throw new Error("not yet implemented");
            }

            public constructor(task1: TTask, task2: TTask) {
                throw new Error("not yet implemented");
            }

            public Invoke(completingTask: Task) {
                throw new Error("not yet implemented");
            }
        }

        export class ____c {
            public static readonly ____9: ____c;
            public static ____9__36_0: Action<any>;
            public static ____9__36_1: Action<any>;
            public static ____9__128_0: SendOrPostCallback;
            public static ____9__128_1: WaitCallback;
            public static ____9__135_0: Predicate<Task>;
            public static ____9__215_0: Predicate<any>;

            private static staticctor_initialize = (() => {
                throw new Error("not yet implemented");
            })();
            private constructor() { }
            public constructor() {
                throw new Error("not yet implemented");
            }

            private __AssignCancellationToken__b__36_0(t: any) {
                throw new Error("not yet implemented");
            }
            private __AssignCancellationToken__b__36_1(t: any) {
                throw new Error("not yet implemented");
            }
            private __ThrowAsync__b__128_0(state: any) {
                throw new Error("not yet implemented");
            }
            private __ThrowAsync__b__128_1(state: any) {
                throw new Error("not yet implemented");
            }
            private __FinishSlow__b__135_0(t: Task): boolean {
                throw new Error("not yet implemented");
            }
            private __AddTaskContinuationComplex__b__215_0(l: any): boolean {
                throw new Error("not yet implemented");
            }
            private ___cctor__b__281_0(obj: any) {
                throw new Error("not yet implemented");
            }
        }
    }
    export class ValueTask extends ValueType implements IEquatable<ValueTask> {
        private static s_canceledTask: Task;

        public static get CompletedTask(): ValueTask {
            throw new Error("not yet implemented");
        }

        private _obj: any;
        private _token: number;
        private _continueOnCapturedContext: boolean;

        public get IsCompleted(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsCompletedSuccessfully(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsFaulted(): boolean {
            throw new Error("not yet implemented");
        }
        public get IsCanceled(): boolean {
            throw new Error("not yet implemented");
        }

        public constructor(task: Task) {
            throw new Error("not yet implemented");
        }
        public constructor(source: IValueTaskSource, token: number) {
            throw new Error("not yet implemented");
        }
        private constructor(obj: any, token: number, continueOnCapturedContext: boolean) {
            throw new Error("not yet implemented");
        }

        public static FromResult(result: TResult): ValueTask<TResult> {
            throw new Error("not yet implemented");
        }
        public static FromCanceled(cancellationToken: CancellationToken): ValueTask {
            throw new Error("not yet implemented");
        }
        public static FromCanceled(cancellationToken: CancellationToken): ValueTask<TResult> {
            throw new Error("not yet implemented");
        }
        public static FromException(exception: Exception): ValueTask {
            throw new Error("not yet implemented");
        }
        public static FromException(exception: Exception): ValueTask<TResult> {
            throw new Error("not yet implemented");
        }
        public GetHashCode(): number {
            throw new Error("not yet implemented");
        }
        public Equals(obj: any): boolean {
            throw new Error("not yet implemented");
        }
        public Equals(other: ValueTask): boolean {
            throw new Error("not yet implemented");
        }
        public AsTask(): Task {
            throw new Error("not yet implemented");
        }
        public Preserve(): ValueTask {
            throw new Error("not yet implemented");
        }
        private GetTaskForValueTaskSource(t: IValueTaskSource): Task {
            throw new Error("not yet implemented");
        }
        private ThrowIfCompletedUnsuccessfully() {
            throw new Error("not yet implemented");
        }
        private static DangerousCreateFromTypedValueTask(valueTask: ValueTask<TResult>): ValueTask {
            throw new Error("not yet implemented");
        }
        public GetAwaiter(): ValueTaskAwaiter {
            throw new Error("not yet implemented");
        }
        public ConfigureAwait(continueOnCapturedContext: boolean): ConfiguredValueTaskAwaitable {
            throw new Error("not yet implemented");
        }
    }
    export namespace ValueTask {
        export class ValueTaskSourceAsTask extends Task implements IAsyncResult, IDisposable {
            private static readonly s_completionAction: Action<any>;

            private _source: IValueTaskSource;
            private _token: number;

            protected constructor(source: IValueTaskSource, token: number) {
                throw new Error("not yet implemented");
            }
            private static staticctor_initialize = (() => {
                throw new Error("not yet implemented");
            })();
            private constructor() { }

            private static ___cctor__g__ThrowUnexpectedStateForKnownCallback_4_1(state: any) {
                throw new Error("not yet implemented");
            }
        }
        export namespace ValueTaskSourceAsTask {
            export class ____c {
                public static readonly ____9: ____c;

                private static staticctor_initialize = (() => {
                    throw new Error("not yet implemented");
                })();
                private constructor() { }
                public constructor() {
                    throw new Error("not yet implemented");
                }

                private ___cctor__b__4_0(state: any) {
                    throw new Error("not yet implemented");
                }
            }
        }
    }
    export enum TaskStatus {
        Created = 0,
        WaitingForActivation = 1,
        WaitingToRun = 2,
        Running = 3,
        WaitingForChildrenToComplete = 4,
        RanToCompletion = 5,
        Canceled = 6,
        Faulted = 7,
    }
}
export namespace System.Threading.Tasks.Sources {
    export enum ValueTaskSourceStatus {
        Pending = 0,
        Succeeded = 1,
        Faulted = 2,
        Canceled = 3,
    }
    export enum ValueTaskSourceOnCompletedFlags {
        None = 0x0,
        UseSchedulingContext = 0x1,
        FlowExecutionContext = 0x2,
    }
    export interface IValueTaskSource<TResult> {
        GetStatus(token: number): ValueTaskSourceStatus;
        OnCompleted(continuation: Action<any>, state: any, token: number, flags: ValueTaskSourceOnCompletedFlags): void;
        GetResult(token: number): TResult;
    }
    export interface IValueTaskSource {
        GetStatus(token: number): ValueTaskSourceStatus;
        OnCompleted(continuation: Action<any>, state: any, token: number, flags: ValueTaskSourceOnCompletedFlags): void;
        GetResult(token: number): void;
    }
    export class ManualResetValueTaskSourceCore<TResult> extends ValueType {
        private _continuation: Action<any>;
        private _continuationState: any;
        private _capturedContext: any;
        private _error: ExceptionDispatchInfo;
        private _result: TResult;
        private _version: number;
        private _completed: boolean;
        private _runContinuationsAsynchronously: boolean;

        public get RunContinuationsAsynchronously(): boolean {
            throw new Error("not yet implemented");
        }
        public set RunContinuationsAsynchronously(value: boolean) {
            throw new Error("not yet implemented");
        }
        public get Version(): number {
            throw new Error("not yet implemented");
        }

        public Reset() {
            throw new Error("not yet implemented");
        }
        public SetResult(result: TResult) {
            throw new Error("not yet implemented");
        }
        public SetException(error: Exception) {
            throw new Error("not yet implemented");
        }
        public GetStatus(token: number): ValueTaskSourceStatus {
            throw new Error("not yet implemented");
        }
        public GetResult(token: number): TResult {
            throw new Error("not yet implemented");
        }
        private ThrowForFailedGetResult() {
            throw new Error("not yet implemented");
        }
        public OnCompleted(continuation: Action<any>, state: any, token: number, flags: ValueTaskSourceOnCompletedFlags) {
            throw new Error("not yet implemented");
        }
        private ValidateToken(token: number) {
            throw new Error("not yet implemented");
        }
        private SignalCompletion() {
            throw new Error("not yet implemented");
        }
    }
}
